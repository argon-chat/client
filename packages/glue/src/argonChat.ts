//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------
import { 
  CborReader, 
  CborWriter, 
  
  DateOnly, 
  DateTimeOffset, 
  Duration, 
  TimeOnly, 
  Guid, 
  
  IonFormatterStorage,

  IonArray, 
  IonMaybe,

  IIonService,
  IIonUnion,
  
  ServiceExecutor,
  IonClientContext,
  IonRequest,
  IonWsClient,
  IonInterceptor
} from "@argon-chat/ion.webcore";

type guid = Guid;
type timeonly = TimeOnly;
type duration = Duration;
type datetime = DateTimeOffset;
type dateonly = DateOnly;

declare type bool = boolean;

declare type i1 = number;
declare type i2 = number;
declare type i4 = number;
declare type i8 = bigint;
declare type i16 = bigint;


declare type u1 = number;
declare type u2 = number;
declare type u4 = number;
declare type u8 = bigint;
declare type u16 = bigint;


declare type f2 = number;
declare type f4 = number;
declare type f8 = number;

export interface ChannelEntitlementOverwrite {
  channelId: guid;
  archetypeId: guid | null;
  serverMemberId: guid | null;
  allow: ArgonEntitlement;
  deny: ArgonEntitlement;
  creatorId: guid;
  id: guid;
};


export interface Archetype {
  id: guid;
  spaceId: guid;
  name: string;
  description: string;
  isMentionable: bool;
  colour: i4;
  isHidden: bool;
  isLocked: bool;
  isGroup: bool;
  isDefault: bool;
  iconFileId: string | null;
  entitlement: ArgonEntitlement;
};


export interface CreateChannelRequest {
  spaceId: guid;
  name: string;
  kind: ChannelType;
  desc: string;
  groupId: guid | null;
};


export interface RealtimeChannel {
  channel: ArgonChannel;
  users: IonArray<RealtimeChannelUser>;
  meetInfo: LinkedMeetingInfo | null;
};


export interface LinkedMeetingInfo {
  meetingId: guid;
  meetingUrl: string;
  meetingCode: string;
  startDate: datetime;
};


export interface ArgonChannel {
  type: ChannelType;
  spaceId: guid;
  channelId: guid;
  name: string;
  description: string | null;
  groupId: guid | null;
  fractionalIndex: string | null;
};


export interface ArgonMessage {
  messageId: i8;
  replyId: i8 | null;
  channelId: guid;
  spaceId: guid;
  text: string;
  entities: IonArray<IMessageEntity>;
  timeSent: datetime;
  sender: guid;
};


export interface RealtimeChannelUser {
  userId: guid;
  state: ChannelMemberState;
};


export interface NotificationCounterKv {
  counterType: string;
  count: i8;
};


export interface UserActivityPresence {
  kind: ActivityPresenceKind;
  startTimestampSeconds: u8;
  titleName: string;
};


export interface ChannelGroup {
  spaceId: guid;
  groupId: guid;
  name: string;
  desc: string | null;
  isCollapsed: bool;
  fractionalIndex: string | null;
};


export enum ChannelType
{
  Text = 0,
  Voice = 1,
  Announcement = 2,
}


export enum JoinToChannelError
{
  NONE = 0,
  CHANNEL_IS_NOT_VOICE = 1,
}


export enum EntityType
{
  Hashtag = 0,
  Mention = 1,
  Email = 2,
  Url = 3,
  Monospace = 4,
  Quote = 5,
  Spoiler = 6,
  Strikethrough = 7,
  Bold = 8,
  Italic = 9,
  Underline = 10,
  Fraction = 11,
  Ordinal = 12,
  Capitalized = 13,
  SystemCallStarted = 14,
  SystemCallEnded = 15,
  SystemCallTimeout = 16,
  SystemUserJoined = 17,
}


export enum StartStreamError
{
  NONE = 0,
  BAD_PARAMS = 1,
  INTERNAL_ERROR = 2,
}


export enum ActivityPresenceKind
{
  GAME = 0,
  SOFTWARE = 1,
  STREAMING = 2,
  LISTEN = 3,
}


export enum ChannelMemberState
{
  NONE = 0,
  MUTED = 2,
  MUTED_BY_SERVER = 4,
  MUTED_HEADPHONES = 8,
  MUTED_HEADPHONES_BY_SERVER = 16,
  STREAMING = 32,
}


export interface FeatureFlagData {
  flagId: string;
  isEnabled: bool;
  variant: string | null;
  scope: i4;
};


export interface UserBlock {
  userId: guid;
  blockedId: guid;
  blockedAt: datetime;
};


export interface FriendRequest {
  requesterId: guid;
  targetId: guid;
  requestedAt: datetime;
};


export interface Friendship {
  userId: guid;
  friendId: guid;
  friendAt: datetime;
};


export interface UserChat {
  peerId: guid;
  isPinned: bool;
  userId: guid;
  lastMsg: string | null;
  lastMessageAt: datetime;
  pinnedAt: datetime | null;
  unreadCount: i4;
};


export interface DirectMessage {
  messageId: i8;
  senderId: guid;
  receiverId: guid;
  text: string;
  entities: IonArray<IMessageEntity>;
  createdAt: datetime;
  replyTo: i8 | null;
};


export enum SendFriendStatus
{
  TargetNotFound = 0,
  CannotFriendYourself = 1,
  Blocked = 2,
  AlreadyFriends = 3,
  AutoAccepted = 4,
  AlreadySent = 5,
  SuccessSent = 6,
  FailedSent = 7,
}


export enum BadAuthKind
{
  SESSION_EXPIRED = 0,
  REQUIRED_RELOGIN = 1,
  BAD_TOKEN = 2,
}


export interface InventoryItem {
  id: string;
  instanceId: guid;
  grantedDate: datetime;
  usable: bool;
  giftable: bool;
  usableVector: ItemUseVector | null;
  receivedFrom: guid | null;
  ttl: duration | null;
};


export interface DetailedInventoryItem {
  item: InventoryItem;
  containedItems: IonArray<InventoryItem>;
};


export interface InventoryNotification {
  inventoryItemId: guid;
  id: string;
  createdAt: datetime;
};


export enum ItemUseVector
{
  RedeemCode = 0,
  Premium = 1,
  Box = 2,
  QualifierBox = 3,
}


export enum RedeemError
{
  NOT_FOUND = 0,
  INACTIVE = 1,
  EXPIRED = 2,
  LIMIT_REACHED = 3,
  ALREADY = 4,
}


export interface SecurityDetails {
  otpEnabled: bool;
  passkeys: IonArray<Passkey>;
  email: string | null;
  phone: string | null;
  autoDeletePeriod: AutoDeletePeriod;
};


export interface Passkey {
  id: guid;
  name: string;
  createdAt: datetime;
  lastUsedAt: datetime | null;
};


export interface PasskeyCredentialDescriptor {
  id: string;
  type: string;
};


export interface AutoDeletePeriod {
  months: i4 | null;
  enabled: bool;
};


export enum EmailChangeError
{
  NONE = 0,
  INVALID_EMAIL = 1,
  EMAIL_ALREADY_USED = 2,
  INVALID_PASSWORD = 3,
  INVALID_VERIFICATION_CODE = 4,
  VERIFICATION_CODE_EXPIRED = 5,
  RATE_LIMITED = 6,
  INTERNAL_ERROR = 7,
}


export enum PhoneChangeError
{
  NONE = 0,
  INVALID_PHONE = 1,
  PHONE_ALREADY_USED = 2,
  INVALID_PASSWORD = 3,
  INVALID_VERIFICATION_CODE = 4,
  VERIFICATION_CODE_EXPIRED = 5,
  RATE_LIMITED = 6,
  INTERNAL_ERROR = 7,
}


export enum PasswordChangeError
{
  NONE = 0,
  INVALID_CURRENT_PASSWORD = 1,
  PASSWORD_TOO_WEAK = 2,
  PASSWORD_TOO_SHORT = 3,
  PASSWORD_SAME_AS_CURRENT = 4,
  RATE_LIMITED = 5,
  INTERNAL_ERROR = 6,
}


export enum OTPError
{
  NONE = 0,
  ALREADY_ENABLED = 1,
  NOT_ENABLED = 2,
  INVALID_CODE = 3,
  RATE_LIMITED = 4,
  INTERNAL_ERROR = 5,
}


export enum PasskeyError
{
  NONE = 0,
  NOT_FOUND = 1,
  LIMIT_REACHED = 2,
  INVALID_PUBLIC_KEY = 3,
  INTERNAL_ERROR = 4,
}


export enum AutoDeleteError
{
  NONE = 0,
  PREMIUM_REQUIRED = 1,
  INVALID_PERIOD = 2,
  INTERNAL_ERROR = 3,
}


export interface ArgonSpaceBase {
  spaceId: guid;
  name: string;
  description: string;
  avatarFieldId: string | null;
  topBannerFileId: string | null;
};


export interface ArgonSpace {
  spaceId: guid;
  name: string;
  description: string;
  avatarFieldId: string | null;
  topBannerFileId: string | null;
  channels: IonArray<ArgonChannel>;
  members: IonArray<SpaceMember>;
  archetypes: IonArray<Archetype>;
};


export interface ArchetypeGroup {
  archetype: Archetype;
  members: IonArray<guid>;
};


export interface SpaceMemberArchetype {
  serverMemberId: guid;
  archetypeId: guid;
};


export interface SpaceMember {
  userId: guid;
  spaceId: guid;
  joinedAt: datetime;
  memberId: guid;
  user: ArgonUser;
  archetypes: IonArray<SpaceMemberArchetype>;
};


export interface RealtimeServerMember {
  member: SpaceMember;
  status: UserStatus;
  presence: UserActivityPresence | null;
};


export interface InviteCodeEntity {
  code: InviteCode;
  spaceId: guid;
  issuerId: guid;
  expireTime: datetime;
  used: u8;
};


export interface InviteCode {
  inviteCode: string;
};


export interface ArgonUser {
  userId: guid;
  username: string;
  displayName: string;
  avatarFileId: string | null;
};


export interface ArgonUserProfile {
  userId: guid;
  customStatus: string | null;
  customStatusIconId: string | null;
  bannerFileID: string | null;
  dateOfBirth: dateonly | null;
  bio: string | null;
  isPremium: bool;
  badges: IonArray<string>;
  archetypes: IonArray<SpaceMemberArchetype>;
};


export enum UserStatus
{
  Offline = 0,
  Online = 1,
  Away = 2,
  InGame = 3,
  Listen = 4,
  TouchGrass = 5,
  DoNotDisturb = 6,
}


export enum ArgonEntitlement
{
  None = 0n as any,
  ViewChannel = 1n as any,
  ReadHistory = 2n as any,
  JoinToVoice = 4n as any,
  SendMessages = 32n as any,
  SendVoice = 64n as any,
  AttachFiles = 128n as any,
  AddReactions = 256n as any,
  AnyMentions = 512n as any,
  MentionEveryone = 1024n as any,
  ExternalEmoji = 2048n as any,
  ExternalStickers = 4096n as any,
  UseCommands = 8192n as any,
  PostEmbeddedLinks = 16384n as any,
  Connect = 1048576n as any,
  Speak = 2097152n as any,
  Video = 4194304n as any,
  Stream = 8388608n as any,
  UseASIO = 1073741824n as any,
  AdditionalStreams = 2147483648n as any,
  DisconnectMember = 1099511627776n as any,
  MoveMember = 2199023255552n as any,
  BanMember = 4398046511104n as any,
  MuteMember = 8796093022208n as any,
  KickMember = 17592186044416n as any,
  ManageChannels = 1125899906842624n as any,
  ManageArchetype = 2251799813685248n as any,
  ManageBots = 4503599627370496n as any,
  ManageEvents = 9007199254740992n as any,
  ManageBehaviour = 18014398509481984n as any,
  ManageServer = 36028797018963968n as any,
}


export interface ArgonIonTicket {
  userId: guid;
  ip: string;
  ray: string;
  clientName: string;
  hostName: string;
  appId: string;
  sessionId: guid;
  machineId: string;
  region: string;
};


export interface TodayStats {
  timeInVoice: i4;
  callsMade: i4;
  messagesSent: i4;
};


export interface MyLevelDetails {
  totalXp: i4;
  currentLevel: i4;
  xpForNextLevel: i4;
  xpForCurrentLevel: i4;
  readyToClaimCoin: bool;
};


export interface UserEditInput {
  displayName: string | null;
  avatarId: string | null;
};


export interface FeatureFlag {
  key: string;
  enabled: bool;
  variant: string | null;
  parameters: IonArray<FeatureFlagParameter>;
};


export interface FeatureFlagParameter {
  key: string;
  value: string;
};


export interface CreateServerRequest {
  name: string;
  description: string;
  avatarFieldId: string;
};


export interface UserCredentialsInput {
  email: string | null;
  phone: string | null;
  username: string | null;
  password: string | null;
  otpCode: string | null;
  captchaToken: string | null;
};


export interface UserLoginInput {
  email: string | null;
  phone: string | null;
  username: string | null;
};


export interface NewUserCredentialsInput {
  email: string;
  username: string;
  password: string;
  displayName: string;
  argreeTos: bool;
  birthDate: dateonly;
  argreeOptionalEmails: bool;
  captchaToken: string | null;
};


export enum UploadFileError
{
  NONE = 0,
  NOT_AUTHORIZED = 1,
  INTERNAL_ERROR = 2,
}


export enum CreateSpaceError
{
  UNKNOWN = 0,
  LIMIT_REACHED = 1,
}


export enum AcceptInviteError
{
  NONE = 0,
  NOT_FOUND = 1,
  EXPIRED = 2,
  YOU_ARE_BANNED = 3,
}


export enum AuthorizationError
{
  NONE = 0,
  BAD_CREDENTIALS = 1,
  REQUIRED_OTP = 2,
  BAD_OTP = 3,
}


export enum RegistrationError
{
  USERNAME_ALREADY_TAKEN = 0,
  USERNAME_RESERVED = 1,
  EMAIL_ALREADY_REGISTERED = 2,
  REGION_BANNED = 3,
  EMAIL_BANNED = 4,
  SSO_EMAILS_NOT_ALLOWED = 5,
  INTERNAL_ERROR = 6,
  VALIDATION_FAILED = 7,
}


export enum LockdownReason
{
  NONE = 0,
  UNDER_INVESTIGATION = 1,
  COMPROMISED_ACCOUNT = 2,
  PAYMENT_FRAUD = 3,
  MULTI_ACCOUNT_ABUSE = 4,
  DOXXING = 5,
  CSAM = 6,
  SPAM_SCAM_ACCOUNT = 7,
  INCITING_MOMENT = 8,
  NON_BINARY_PERSON = 9,
  TOS_VIOLATION = 10,
  LGBT_AGITATION = 11,
  DRUG_VIOLATION = 12,
  TERRORISM_AGITATION = 13,
  TERRORISM_CONTENT = 14,
  SELF_HARM_PROMOTION = 15,
  CHILD_ABUSE = 16,
  BAD_CLIENT = 17,
}


export enum LockdownSeverity
{
  Low = 0,
  Middle = 1,
  Critical = 2,
}


export interface RtcEndpoint {
  endpoint: string;
  ices: IonArray<IceEndpoint>;
};


export interface IceEndpoint {
  endpoint: string;
  username: string;
  password: string;
};


export interface ServiceUssdResult {
  success: bool;
  message: string;
};


export enum CallFailedError
{
  NONE = 0,
  CALLEE_OFFLINE = 1,
  INSUFFICIENT_BALANCE = 2,
  VERIFICATION_FAILED = 3,
  POOL_EMPTY_TRY_LATE = 4,
}


export enum DialCheckFailReason
{
  COUNTRY_NOT_SUPPORT = 0,
  INVALID_NUMBER_COUNTRY = 1,
  INSUFFICIENT_BALANCE = 2,
  NUMBER_NOT_AVAILABLE = 3,
  INSUFFICIENT_POOL = 4,
  UNKNOWN_ERROR = 5,
}



export abstract class IMessageEntity implements IIonUnion<IMessageEntity>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
    abstract type: EntityType;
  abstract offset: i4;
  abstract length: i4;
  abstract version: i4;

  
  
  public isMessageEntityBold(): this is MessageEntityBold {
    return this.UnionKey === "MessageEntityBold";
  }
  public isMessageEntityItalic(): this is MessageEntityItalic {
    return this.UnionKey === "MessageEntityItalic";
  }
  public isMessageEntityStrikethrough(): this is MessageEntityStrikethrough {
    return this.UnionKey === "MessageEntityStrikethrough";
  }
  public isMessageEntitySpoiler(): this is MessageEntitySpoiler {
    return this.UnionKey === "MessageEntitySpoiler";
  }
  public isMessageEntityMonospace(): this is MessageEntityMonospace {
    return this.UnionKey === "MessageEntityMonospace";
  }
  public isMessageEntityFraction(): this is MessageEntityFraction {
    return this.UnionKey === "MessageEntityFraction";
  }
  public isMessageEntityOrdinal(): this is MessageEntityOrdinal {
    return this.UnionKey === "MessageEntityOrdinal";
  }
  public isMessageEntityCapitalized(): this is MessageEntityCapitalized {
    return this.UnionKey === "MessageEntityCapitalized";
  }
  public isMessageEntityMention(): this is MessageEntityMention {
    return this.UnionKey === "MessageEntityMention";
  }
  public isMessageEntityEmail(): this is MessageEntityEmail {
    return this.UnionKey === "MessageEntityEmail";
  }
  public isMessageEntityHashTag(): this is MessageEntityHashTag {
    return this.UnionKey === "MessageEntityHashTag";
  }
  public isMessageEntityQuote(): this is MessageEntityQuote {
    return this.UnionKey === "MessageEntityQuote";
  }
  public isMessageEntityUnderline(): this is MessageEntityUnderline {
    return this.UnionKey === "MessageEntityUnderline";
  }
  public isMessageEntityUrl(): this is MessageEntityUrl {
    return this.UnionKey === "MessageEntityUrl";
  }
  public isMessageEntitySystemCallStarted(): this is MessageEntitySystemCallStarted {
    return this.UnionKey === "MessageEntitySystemCallStarted";
  }
  public isMessageEntitySystemCallEnded(): this is MessageEntitySystemCallEnded {
    return this.UnionKey === "MessageEntitySystemCallEnded";
  }
  public isMessageEntitySystemCallTimeout(): this is MessageEntitySystemCallTimeout {
    return this.UnionKey === "MessageEntitySystemCallTimeout";
  }
  public isMessageEntitySystemUserJoined(): this is MessageEntitySystemUserJoined {
    return this.UnionKey === "MessageEntitySystemUserJoined";
  }

}


export class MessageEntityBold extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4) { super(); }

  UnionKey: string = "MessageEntityBold";
  UnionIndex: number = 0;
}

export class MessageEntityItalic extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4) { super(); }

  UnionKey: string = "MessageEntityItalic";
  UnionIndex: number = 1;
}

export class MessageEntityStrikethrough extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4) { super(); }

  UnionKey: string = "MessageEntityStrikethrough";
  UnionIndex: number = 2;
}

export class MessageEntitySpoiler extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4) { super(); }

  UnionKey: string = "MessageEntitySpoiler";
  UnionIndex: number = 3;
}

export class MessageEntityMonospace extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4) { super(); }

  UnionKey: string = "MessageEntityMonospace";
  UnionIndex: number = 4;
}

export class MessageEntityFraction extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public numerator: i4, public denominator: i4) { super(); }

  UnionKey: string = "MessageEntityFraction";
  UnionIndex: number = 5;
}

export class MessageEntityOrdinal extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4) { super(); }

  UnionKey: string = "MessageEntityOrdinal";
  UnionIndex: number = 6;
}

export class MessageEntityCapitalized extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4) { super(); }

  UnionKey: string = "MessageEntityCapitalized";
  UnionIndex: number = 7;
}

export class MessageEntityMention extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public userId: guid) { super(); }

  UnionKey: string = "MessageEntityMention";
  UnionIndex: number = 8;
}

export class MessageEntityEmail extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public email: string) { super(); }

  UnionKey: string = "MessageEntityEmail";
  UnionIndex: number = 9;
}

export class MessageEntityHashTag extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public hashtag: string) { super(); }

  UnionKey: string = "MessageEntityHashTag";
  UnionIndex: number = 10;
}

export class MessageEntityQuote extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public quotedUserId: guid) { super(); }

  UnionKey: string = "MessageEntityQuote";
  UnionIndex: number = 11;
}

export class MessageEntityUnderline extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public colour: i4) { super(); }

  UnionKey: string = "MessageEntityUnderline";
  UnionIndex: number = 12;
}

export class MessageEntityUrl extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public domain: string, public path: string) { super(); }

  UnionKey: string = "MessageEntityUrl";
  UnionIndex: number = 13;
}

export class MessageEntitySystemCallStarted extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public callerId: guid, public callId: guid) { super(); }

  UnionKey: string = "MessageEntitySystemCallStarted";
  UnionIndex: number = 14;
}

export class MessageEntitySystemCallEnded extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public callerId: guid, public callId: guid, public durationSeconds: i4) { super(); }

  UnionKey: string = "MessageEntitySystemCallEnded";
  UnionIndex: number = 15;
}

export class MessageEntitySystemCallTimeout extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public callerId: guid, public callId: guid) { super(); }

  UnionKey: string = "MessageEntitySystemCallTimeout";
  UnionIndex: number = 16;
}

export class MessageEntitySystemUserJoined extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public userId: guid, public inviterId: guid | null) { super(); }

  UnionKey: string = "MessageEntitySystemUserJoined";
  UnionIndex: number = 17;
}



IonFormatterStorage.register("IMessageEntity", {
  read(reader: CborReader): IMessageEntity {
    reader.readStartArray();
    let value: IMessageEntity = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<MessageEntityBold>("MessageEntityBold").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<MessageEntityItalic>("MessageEntityItalic").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<MessageEntityStrikethrough>("MessageEntityStrikethrough").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<MessageEntitySpoiler>("MessageEntitySpoiler").read(reader);
    else if (unionIndex == 4)
      value = IonFormatterStorage.get<MessageEntityMonospace>("MessageEntityMonospace").read(reader);
    else if (unionIndex == 5)
      value = IonFormatterStorage.get<MessageEntityFraction>("MessageEntityFraction").read(reader);
    else if (unionIndex == 6)
      value = IonFormatterStorage.get<MessageEntityOrdinal>("MessageEntityOrdinal").read(reader);
    else if (unionIndex == 7)
      value = IonFormatterStorage.get<MessageEntityCapitalized>("MessageEntityCapitalized").read(reader);
    else if (unionIndex == 8)
      value = IonFormatterStorage.get<MessageEntityMention>("MessageEntityMention").read(reader);
    else if (unionIndex == 9)
      value = IonFormatterStorage.get<MessageEntityEmail>("MessageEntityEmail").read(reader);
    else if (unionIndex == 10)
      value = IonFormatterStorage.get<MessageEntityHashTag>("MessageEntityHashTag").read(reader);
    else if (unionIndex == 11)
      value = IonFormatterStorage.get<MessageEntityQuote>("MessageEntityQuote").read(reader);
    else if (unionIndex == 12)
      value = IonFormatterStorage.get<MessageEntityUnderline>("MessageEntityUnderline").read(reader);
    else if (unionIndex == 13)
      value = IonFormatterStorage.get<MessageEntityUrl>("MessageEntityUrl").read(reader);
    else if (unionIndex == 14)
      value = IonFormatterStorage.get<MessageEntitySystemCallStarted>("MessageEntitySystemCallStarted").read(reader);
    else if (unionIndex == 15)
      value = IonFormatterStorage.get<MessageEntitySystemCallEnded>("MessageEntitySystemCallEnded").read(reader);
    else if (unionIndex == 16)
      value = IonFormatterStorage.get<MessageEntitySystemCallTimeout>("MessageEntitySystemCallTimeout").read(reader);
    else if (unionIndex == 17)
      value = IonFormatterStorage.get<MessageEntitySystemUserJoined>("MessageEntitySystemUserJoined").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IMessageEntity): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<MessageEntityBold>("MessageEntityBold").write(writer, value as MessageEntityBold);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<MessageEntityItalic>("MessageEntityItalic").write(writer, value as MessageEntityItalic);
    }
    else if (value.UnionIndex == 2) {
        IonFormatterStorage.get<MessageEntityStrikethrough>("MessageEntityStrikethrough").write(writer, value as MessageEntityStrikethrough);
    }
    else if (value.UnionIndex == 3) {
        IonFormatterStorage.get<MessageEntitySpoiler>("MessageEntitySpoiler").write(writer, value as MessageEntitySpoiler);
    }
    else if (value.UnionIndex == 4) {
        IonFormatterStorage.get<MessageEntityMonospace>("MessageEntityMonospace").write(writer, value as MessageEntityMonospace);
    }
    else if (value.UnionIndex == 5) {
        IonFormatterStorage.get<MessageEntityFraction>("MessageEntityFraction").write(writer, value as MessageEntityFraction);
    }
    else if (value.UnionIndex == 6) {
        IonFormatterStorage.get<MessageEntityOrdinal>("MessageEntityOrdinal").write(writer, value as MessageEntityOrdinal);
    }
    else if (value.UnionIndex == 7) {
        IonFormatterStorage.get<MessageEntityCapitalized>("MessageEntityCapitalized").write(writer, value as MessageEntityCapitalized);
    }
    else if (value.UnionIndex == 8) {
        IonFormatterStorage.get<MessageEntityMention>("MessageEntityMention").write(writer, value as MessageEntityMention);
    }
    else if (value.UnionIndex == 9) {
        IonFormatterStorage.get<MessageEntityEmail>("MessageEntityEmail").write(writer, value as MessageEntityEmail);
    }
    else if (value.UnionIndex == 10) {
        IonFormatterStorage.get<MessageEntityHashTag>("MessageEntityHashTag").write(writer, value as MessageEntityHashTag);
    }
    else if (value.UnionIndex == 11) {
        IonFormatterStorage.get<MessageEntityQuote>("MessageEntityQuote").write(writer, value as MessageEntityQuote);
    }
    else if (value.UnionIndex == 12) {
        IonFormatterStorage.get<MessageEntityUnderline>("MessageEntityUnderline").write(writer, value as MessageEntityUnderline);
    }
    else if (value.UnionIndex == 13) {
        IonFormatterStorage.get<MessageEntityUrl>("MessageEntityUrl").write(writer, value as MessageEntityUrl);
    }
    else if (value.UnionIndex == 14) {
        IonFormatterStorage.get<MessageEntitySystemCallStarted>("MessageEntitySystemCallStarted").write(writer, value as MessageEntitySystemCallStarted);
    }
    else if (value.UnionIndex == 15) {
        IonFormatterStorage.get<MessageEntitySystemCallEnded>("MessageEntitySystemCallEnded").write(writer, value as MessageEntitySystemCallEnded);
    }
    else if (value.UnionIndex == 16) {
        IonFormatterStorage.get<MessageEntitySystemCallTimeout>("MessageEntitySystemCallTimeout").write(writer, value as MessageEntitySystemCallTimeout);
    }
    else if (value.UnionIndex == 17) {
        IonFormatterStorage.get<MessageEntitySystemUserJoined>("MessageEntitySystemUserJoined").write(writer, value as MessageEntitySystemUserJoined);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("MessageEntityBold", {
  read(reader: CborReader): MessageEntityBold {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new MessageEntityBold(type, offset, length, version);
  },
  write(writer: CborWriter, value: MessageEntityBold): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityItalic", {
  read(reader: CborReader): MessageEntityItalic {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new MessageEntityItalic(type, offset, length, version);
  },
  write(writer: CborWriter, value: MessageEntityItalic): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityStrikethrough", {
  read(reader: CborReader): MessageEntityStrikethrough {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new MessageEntityStrikethrough(type, offset, length, version);
  },
  write(writer: CborWriter, value: MessageEntityStrikethrough): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntitySpoiler", {
  read(reader: CborReader): MessageEntitySpoiler {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new MessageEntitySpoiler(type, offset, length, version);
  },
  write(writer: CborWriter, value: MessageEntitySpoiler): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityMonospace", {
  read(reader: CborReader): MessageEntityMonospace {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new MessageEntityMonospace(type, offset, length, version);
  },
  write(writer: CborWriter, value: MessageEntityMonospace): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityFraction", {
  read(reader: CborReader): MessageEntityFraction {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const numerator = IonFormatterStorage.get<i4>('i4').read(reader);
    const denominator = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 6);
    return new MessageEntityFraction(type, offset, length, version, numerator, denominator);
  },
  write(writer: CborWriter, value: MessageEntityFraction): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<i4>('i4').write(writer, value.numerator);
    IonFormatterStorage.get<i4>('i4').write(writer, value.denominator);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityOrdinal", {
  read(reader: CborReader): MessageEntityOrdinal {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new MessageEntityOrdinal(type, offset, length, version);
  },
  write(writer: CborWriter, value: MessageEntityOrdinal): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityCapitalized", {
  read(reader: CborReader): MessageEntityCapitalized {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new MessageEntityCapitalized(type, offset, length, version);
  },
  write(writer: CborWriter, value: MessageEntityCapitalized): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityMention", {
  read(reader: CborReader): MessageEntityMention {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityMention(type, offset, length, version, userId);
  },
  write(writer: CborWriter, value: MessageEntityMention): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityEmail", {
  read(reader: CborReader): MessageEntityEmail {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const email = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityEmail(type, offset, length, version, email);
  },
  write(writer: CborWriter, value: MessageEntityEmail): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<string>('string').write(writer, value.email);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityHashTag", {
  read(reader: CborReader): MessageEntityHashTag {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const hashtag = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityHashTag(type, offset, length, version, hashtag);
  },
  write(writer: CborWriter, value: MessageEntityHashTag): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<string>('string').write(writer, value.hashtag);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityQuote", {
  read(reader: CborReader): MessageEntityQuote {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const quotedUserId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityQuote(type, offset, length, version, quotedUserId);
  },
  write(writer: CborWriter, value: MessageEntityQuote): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.quotedUserId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityUnderline", {
  read(reader: CborReader): MessageEntityUnderline {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const colour = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityUnderline(type, offset, length, version, colour);
  },
  write(writer: CborWriter, value: MessageEntityUnderline): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<i4>('i4').write(writer, value.colour);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityUrl", {
  read(reader: CborReader): MessageEntityUrl {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const domain = IonFormatterStorage.get<string>('string').read(reader);
    const path = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 6);
    return new MessageEntityUrl(type, offset, length, version, domain, path);
  },
  write(writer: CborWriter, value: MessageEntityUrl): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<string>('string').write(writer, value.domain);
    IonFormatterStorage.get<string>('string').write(writer, value.path);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntitySystemCallStarted", {
  read(reader: CborReader): MessageEntitySystemCallStarted {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const callerId = IonFormatterStorage.get<guid>('guid').read(reader);
    const callId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 6);
    return new MessageEntitySystemCallStarted(type, offset, length, version, callerId, callId);
  },
  write(writer: CborWriter, value: MessageEntitySystemCallStarted): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callerId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntitySystemCallEnded", {
  read(reader: CborReader): MessageEntitySystemCallEnded {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const callerId = IonFormatterStorage.get<guid>('guid').read(reader);
    const callId = IonFormatterStorage.get<guid>('guid').read(reader);
    const durationSeconds = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 7);
    return new MessageEntitySystemCallEnded(type, offset, length, version, callerId, callId, durationSeconds);
  },
  write(writer: CborWriter, value: MessageEntitySystemCallEnded): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callerId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callId);
    IonFormatterStorage.get<i4>('i4').write(writer, value.durationSeconds);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntitySystemCallTimeout", {
  read(reader: CborReader): MessageEntitySystemCallTimeout {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const callerId = IonFormatterStorage.get<guid>('guid').read(reader);
    const callId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 6);
    return new MessageEntitySystemCallTimeout(type, offset, length, version, callerId, callId);
  },
  write(writer: CborWriter, value: MessageEntitySystemCallTimeout): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callerId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntitySystemUserJoined", {
  read(reader: CborReader): MessageEntitySystemUserJoined {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const inviterId = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    reader.readEndArrayAndSkip(arraySize - 6);
    return new MessageEntitySystemUserJoined(type, offset, length, version, userId, inviterId);
  },
  write(writer: CborWriter, value: MessageEntitySystemUserJoined): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.writeNullable<guid>(writer, value.inviterId, 'guid');
    writer.writeEndArray();
  }
});



export abstract class IInterlinkResult implements IIonUnion<IInterlinkResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessJoinVoice(): this is SuccessJoinVoice {
    return this.UnionKey === "SuccessJoinVoice";
  }
  public isFailedJoinVoice(): this is FailedJoinVoice {
    return this.UnionKey === "FailedJoinVoice";
  }

}


export class SuccessJoinVoice extends IInterlinkResult
{
  constructor(public rtc: RtcEndpoint, public token: string) { super(); }

  UnionKey: string = "SuccessJoinVoice";
  UnionIndex: number = 0;
}

export class FailedJoinVoice extends IInterlinkResult
{
  constructor(public error: JoinToChannelError) { super(); }

  UnionKey: string = "FailedJoinVoice";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IInterlinkResult", {
  read(reader: CborReader): IInterlinkResult {
    reader.readStartArray();
    let value: IInterlinkResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessJoinVoice>("SuccessJoinVoice").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedJoinVoice>("FailedJoinVoice").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IInterlinkResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessJoinVoice>("SuccessJoinVoice").write(writer, value as SuccessJoinVoice);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedJoinVoice>("FailedJoinVoice").write(writer, value as FailedJoinVoice);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessJoinVoice", {
  read(reader: CborReader): SuccessJoinVoice {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const rtc = IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').read(reader);
    const token = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SuccessJoinVoice(rtc, token);
  },
  write(writer: CborWriter, value: SuccessJoinVoice): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').write(writer, value.rtc);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedJoinVoice", {
  read(reader: CborReader): FailedJoinVoice {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<JoinToChannelError>('JoinToChannelError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedJoinVoice(error);
  },
  write(writer: CborWriter, value: FailedJoinVoice): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<JoinToChannelError>('JoinToChannelError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IInterlinkStreamResult implements IIonUnion<IInterlinkStreamResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessStartStream(): this is SuccessStartStream {
    return this.UnionKey === "SuccessStartStream";
  }
  public isFailedStartStream(): this is FailedStartStream {
    return this.UnionKey === "FailedStartStream";
  }

}


export class SuccessStartStream extends IInterlinkStreamResult
{
  constructor(public rtc: RtcEndpoint, public token: string, public whipEndpoint: string) { super(); }

  UnionKey: string = "SuccessStartStream";
  UnionIndex: number = 0;
}

export class FailedStartStream extends IInterlinkStreamResult
{
  constructor(public error: StartStreamError) { super(); }

  UnionKey: string = "FailedStartStream";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IInterlinkStreamResult", {
  read(reader: CborReader): IInterlinkStreamResult {
    reader.readStartArray();
    let value: IInterlinkStreamResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessStartStream>("SuccessStartStream").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedStartStream>("FailedStartStream").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IInterlinkStreamResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessStartStream>("SuccessStartStream").write(writer, value as SuccessStartStream);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedStartStream>("FailedStartStream").write(writer, value as FailedStartStream);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessStartStream", {
  read(reader: CborReader): SuccessStartStream {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const rtc = IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').read(reader);
    const token = IonFormatterStorage.get<string>('string').read(reader);
    const whipEndpoint = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new SuccessStartStream(rtc, token, whipEndpoint);
  },
  write(writer: CborWriter, value: SuccessStartStream): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').write(writer, value.rtc);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    IonFormatterStorage.get<string>('string').write(writer, value.whipEndpoint);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedStartStream", {
  read(reader: CborReader): FailedStartStream {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<StartStreamError>('StartStreamError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedStartStream(error);
  },
  write(writer: CborWriter, value: FailedStartStream): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<StartStreamError>('StartStreamError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IArgonEvent implements IIonUnion<IArgonEvent>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isArchetypeChanged(): this is ArchetypeChanged {
    return this.UnionKey === "ArchetypeChanged";
  }
  public isArchetypeCreated(): this is ArchetypeCreated {
    return this.UnionKey === "ArchetypeCreated";
  }
  public isChannelCreated(): this is ChannelCreated {
    return this.UnionKey === "ChannelCreated";
  }
  public isChannelModified(): this is ChannelModified {
    return this.UnionKey === "ChannelModified";
  }
  public isChannelRemoved(): this is ChannelRemoved {
    return this.UnionKey === "ChannelRemoved";
  }
  public isUserTypingEvent(): this is UserTypingEvent {
    return this.UnionKey === "UserTypingEvent";
  }
  public isUserStopTypingEvent(): this is UserStopTypingEvent {
    return this.UnionKey === "UserStopTypingEvent";
  }
  public isJoinedToChannelUser(): this is JoinedToChannelUser {
    return this.UnionKey === "JoinedToChannelUser";
  }
  public isJoinToServerUser(): this is JoinToServerUser {
    return this.UnionKey === "JoinToServerUser";
  }
  public isLeavedFromChannelUser(): this is LeavedFromChannelUser {
    return this.UnionKey === "LeavedFromChannelUser";
  }
  public isUserUpdated(): this is UserUpdated {
    return this.UnionKey === "UserUpdated";
  }
  public isOnUserPresenceActivityChanged(): this is OnUserPresenceActivityChanged {
    return this.UnionKey === "OnUserPresenceActivityChanged";
  }
  public isOnUserPresenceActivityRemoved(): this is OnUserPresenceActivityRemoved {
    return this.UnionKey === "OnUserPresenceActivityRemoved";
  }
  public isUserChangedStatus(): this is UserChangedStatus {
    return this.UnionKey === "UserChangedStatus";
  }
  public isMessageSent(): this is MessageSent {
    return this.UnionKey === "MessageSent";
  }
  public isServerModified(): this is ServerModified {
    return this.UnionKey === "ServerModified";
  }
  public isRecordStarted(): this is RecordStarted {
    return this.UnionKey === "RecordStarted";
  }
  public isRecordEnded(): this is RecordEnded {
    return this.UnionKey === "RecordEnded";
  }
  public isCallIncoming(): this is CallIncoming {
    return this.UnionKey === "CallIncoming";
  }
  public isCallFinished(): this is CallFinished {
    return this.UnionKey === "CallFinished";
  }
  public isCallAccepted(): this is CallAccepted {
    return this.UnionKey === "CallAccepted";
  }
  public isCallRejected(): this is CallRejected {
    return this.UnionKey === "CallRejected";
  }
  public isFriendRequestReceivedEvent(): this is FriendRequestReceivedEvent {
    return this.UnionKey === "FriendRequestReceivedEvent";
  }
  public isFriendRequestSentEvent(): this is FriendRequestSentEvent {
    return this.UnionKey === "FriendRequestSentEvent";
  }
  public isFriendRequestAcceptedEvent(): this is FriendRequestAcceptedEvent {
    return this.UnionKey === "FriendRequestAcceptedEvent";
  }
  public isFriendRequestDeclinedEvent(): this is FriendRequestDeclinedEvent {
    return this.UnionKey === "FriendRequestDeclinedEvent";
  }
  public isFriendRequestCanceledEvent(): this is FriendRequestCanceledEvent {
    return this.UnionKey === "FriendRequestCanceledEvent";
  }
  public isFriendshipRemovedEvent(): this is FriendshipRemovedEvent {
    return this.UnionKey === "FriendshipRemovedEvent";
  }
  public isUserBlockedEvent(): this is UserBlockedEvent {
    return this.UnionKey === "UserBlockedEvent";
  }
  public isUserUnblockedEvent(): this is UserUnblockedEvent {
    return this.UnionKey === "UserUnblockedEvent";
  }
  public isRecentChatUpdatedEvent(): this is RecentChatUpdatedEvent {
    return this.UnionKey === "RecentChatUpdatedEvent";
  }
  public isChatPinnedEvent(): this is ChatPinnedEvent {
    return this.UnionKey === "ChatPinnedEvent";
  }
  public isChatUnpinnedEvent(): this is ChatUnpinnedEvent {
    return this.UnionKey === "ChatUnpinnedEvent";
  }
  public isChatReadEvent(): this is ChatReadEvent {
    return this.UnionKey === "ChatReadEvent";
  }
  public isChannelGroupCreated(): this is ChannelGroupCreated {
    return this.UnionKey === "ChannelGroupCreated";
  }
  public isChannelGroupModified(): this is ChannelGroupModified {
    return this.UnionKey === "ChannelGroupModified";
  }
  public isChannelGroupRemoved(): this is ChannelGroupRemoved {
    return this.UnionKey === "ChannelGroupRemoved";
  }
  public isChannelGroupReordered(): this is ChannelGroupReordered {
    return this.UnionKey === "ChannelGroupReordered";
  }
  public isChannelReordered(): this is ChannelReordered {
    return this.UnionKey === "ChannelReordered";
  }
  public isDirectMessageSent(): this is DirectMessageSent {
    return this.UnionKey === "DirectMessageSent";
  }
  public isUpdatedNotificationCounters(): this is UpdatedNotificationCounters {
    return this.UnionKey === "UpdatedNotificationCounters";
  }
  public isUserSecurityDetailsUpdated(): this is UserSecurityDetailsUpdated {
    return this.UnionKey === "UserSecurityDetailsUpdated";
  }
  public isSpaceDetailsUpdated(): this is SpaceDetailsUpdated {
    return this.UnionKey === "SpaceDetailsUpdated";
  }
  public isMeetingCreatedFor(): this is MeetingCreatedFor {
    return this.UnionKey === "MeetingCreatedFor";
  }
  public isMeetingDeletedFor(): this is MeetingDeletedFor {
    return this.UnionKey === "MeetingDeletedFor";
  }

}


export class ArchetypeChanged extends IArgonEvent
{
  constructor(public spaceId: guid, public data: Archetype) { super(); }

  UnionKey: string = "ArchetypeChanged";
  UnionIndex: number = 0;
}

export class ArchetypeCreated extends IArgonEvent
{
  constructor(public spaceId: guid, public data: Archetype) { super(); }

  UnionKey: string = "ArchetypeCreated";
  UnionIndex: number = 1;
}

export class ChannelCreated extends IArgonEvent
{
  constructor(public spaceId: guid, public data: ArgonChannel) { super(); }

  UnionKey: string = "ChannelCreated";
  UnionIndex: number = 2;
}

export class ChannelModified extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public bag: IonArray<string>) { super(); }

  UnionKey: string = "ChannelModified";
  UnionIndex: number = 3;
}

export class ChannelRemoved extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid) { super(); }

  UnionKey: string = "ChannelRemoved";
  UnionIndex: number = 4;
}

export class UserTypingEvent extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "UserTypingEvent";
  UnionIndex: number = 5;
}

export class UserStopTypingEvent extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "UserStopTypingEvent";
  UnionIndex: number = 6;
}

export class JoinedToChannelUser extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "JoinedToChannelUser";
  UnionIndex: number = 7;
}

export class JoinToServerUser extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid) { super(); }

  UnionKey: string = "JoinToServerUser";
  UnionIndex: number = 8;
}

export class LeavedFromChannelUser extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "LeavedFromChannelUser";
  UnionIndex: number = 9;
}

export class UserUpdated extends IArgonEvent
{
  constructor(public spaceId: guid, public dto: ArgonUser) { super(); }

  UnionKey: string = "UserUpdated";
  UnionIndex: number = 10;
}

export class OnUserPresenceActivityChanged extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid, public presence: UserActivityPresence) { super(); }

  UnionKey: string = "OnUserPresenceActivityChanged";
  UnionIndex: number = 11;
}

export class OnUserPresenceActivityRemoved extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid) { super(); }

  UnionKey: string = "OnUserPresenceActivityRemoved";
  UnionIndex: number = 12;
}

export class UserChangedStatus extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid, public status: UserStatus, public bag: IonArray<string>) { super(); }

  UnionKey: string = "UserChangedStatus";
  UnionIndex: number = 13;
}

export class MessageSent extends IArgonEvent
{
  constructor(public spaceId: guid, public message: ArgonMessage) { super(); }

  UnionKey: string = "MessageSent";
  UnionIndex: number = 14;
}

export class ServerModified extends IArgonEvent
{
  constructor(public spaceId: guid, public bag: IonArray<string>) { super(); }

  UnionKey: string = "ServerModified";
  UnionIndex: number = 15;
}

export class RecordStarted extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public byUserId: guid) { super(); }

  UnionKey: string = "RecordStarted";
  UnionIndex: number = 16;
}

export class RecordEnded extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid) { super(); }

  UnionKey: string = "RecordEnded";
  UnionIndex: number = 17;
}

export class CallIncoming extends IArgonEvent
{
  constructor(public userId: guid, public callId: guid, public fromId: guid) { super(); }

  UnionKey: string = "CallIncoming";
  UnionIndex: number = 18;
}

export class CallFinished extends IArgonEvent
{
  constructor(public userId: guid, public callId: guid) { super(); }

  UnionKey: string = "CallFinished";
  UnionIndex: number = 19;
}

export class CallAccepted extends IArgonEvent
{
  constructor(public userId: guid, public callId: guid, public fromId: guid) { super(); }

  UnionKey: string = "CallAccepted";
  UnionIndex: number = 20;
}

export class CallRejected extends IArgonEvent
{
  constructor(public userId: guid, public callId: guid, public fromId: guid) { super(); }

  UnionKey: string = "CallRejected";
  UnionIndex: number = 21;
}

export class FriendRequestReceivedEvent extends IArgonEvent
{
  constructor(public requesterId: guid, public requestDate: datetime) { super(); }

  UnionKey: string = "FriendRequestReceivedEvent";
  UnionIndex: number = 22;
}

export class FriendRequestSentEvent extends IArgonEvent
{
  constructor(public targetId: guid, public requestDate: datetime) { super(); }

  UnionKey: string = "FriendRequestSentEvent";
  UnionIndex: number = 23;
}

export class FriendRequestAcceptedEvent extends IArgonEvent
{
  constructor(public userId: guid, public friendAt: datetime) { super(); }

  UnionKey: string = "FriendRequestAcceptedEvent";
  UnionIndex: number = 24;
}

export class FriendRequestDeclinedEvent extends IArgonEvent
{
  constructor(public targetId: guid) { super(); }

  UnionKey: string = "FriendRequestDeclinedEvent";
  UnionIndex: number = 25;
}

export class FriendRequestCanceledEvent extends IArgonEvent
{
  constructor(public requesterId: guid) { super(); }

  UnionKey: string = "FriendRequestCanceledEvent";
  UnionIndex: number = 26;
}

export class FriendshipRemovedEvent extends IArgonEvent
{
  constructor(public userId: guid) { super(); }

  UnionKey: string = "FriendshipRemovedEvent";
  UnionIndex: number = 27;
}

export class UserBlockedEvent extends IArgonEvent
{
  constructor(public blockId: guid) { super(); }

  UnionKey: string = "UserBlockedEvent";
  UnionIndex: number = 28;
}

export class UserUnblockedEvent extends IArgonEvent
{
  constructor(public blockId: guid) { super(); }

  UnionKey: string = "UserUnblockedEvent";
  UnionIndex: number = 29;
}

export class RecentChatUpdatedEvent extends IArgonEvent
{
  constructor(public peerId: guid, public userId: guid, public lastMessage: string | null, public lastMessageAt: datetime) { super(); }

  UnionKey: string = "RecentChatUpdatedEvent";
  UnionIndex: number = 30;
}

export class ChatPinnedEvent extends IArgonEvent
{
  constructor(public peerId: guid, public pinnedAt: datetime) { super(); }

  UnionKey: string = "ChatPinnedEvent";
  UnionIndex: number = 31;
}

export class ChatUnpinnedEvent extends IArgonEvent
{
  constructor(public peerId: guid) { super(); }

  UnionKey: string = "ChatUnpinnedEvent";
  UnionIndex: number = 32;
}

export class ChatReadEvent extends IArgonEvent
{
  constructor(public peerId: guid) { super(); }

  UnionKey: string = "ChatReadEvent";
  UnionIndex: number = 33;
}

export class ChannelGroupCreated extends IArgonEvent
{
  constructor(public spaceId: guid, public data: ChannelGroup) { super(); }

  UnionKey: string = "ChannelGroupCreated";
  UnionIndex: number = 34;
}

export class ChannelGroupModified extends IArgonEvent
{
  constructor(public spaceId: guid, public groupId: guid, public data: ChannelGroup) { super(); }

  UnionKey: string = "ChannelGroupModified";
  UnionIndex: number = 35;
}

export class ChannelGroupRemoved extends IArgonEvent
{
  constructor(public spaceId: guid, public groupId: guid) { super(); }

  UnionKey: string = "ChannelGroupRemoved";
  UnionIndex: number = 36;
}

export class ChannelGroupReordered extends IArgonEvent
{
  constructor(public spaceId: guid, public groupId: guid, public fractionalIndex: string) { super(); }

  UnionKey: string = "ChannelGroupReordered";
  UnionIndex: number = 37;
}

export class ChannelReordered extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public targetGroupId: guid | null, public fractionalIndex: string) { super(); }

  UnionKey: string = "ChannelReordered";
  UnionIndex: number = 38;
}

export class DirectMessageSent extends IArgonEvent
{
  constructor(public senderId: guid, public receiverId: guid, public message: DirectMessage) { super(); }

  UnionKey: string = "DirectMessageSent";
  UnionIndex: number = 39;
}

export class UpdatedNotificationCounters extends IArgonEvent
{
  constructor(public userId: guid, public counters: IonArray<NotificationCounterKv>) { super(); }

  UnionKey: string = "UpdatedNotificationCounters";
  UnionIndex: number = 40;
}

export class UserSecurityDetailsUpdated extends IArgonEvent
{
  constructor(public userId: guid, public details: SecurityDetails) { super(); }

  UnionKey: string = "UserSecurityDetailsUpdated";
  UnionIndex: number = 41;
}

export class SpaceDetailsUpdated extends IArgonEvent
{
  constructor(public spaceId: guid, public details: ArgonSpaceBase) { super(); }

  UnionKey: string = "SpaceDetailsUpdated";
  UnionIndex: number = 42;
}

export class MeetingCreatedFor extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public meetInfo: LinkedMeetingInfo) { super(); }

  UnionKey: string = "MeetingCreatedFor";
  UnionIndex: number = 43;
}

export class MeetingDeletedFor extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public meetInfo: LinkedMeetingInfo) { super(); }

  UnionKey: string = "MeetingDeletedFor";
  UnionIndex: number = 44;
}



IonFormatterStorage.register("IArgonEvent", {
  read(reader: CborReader): IArgonEvent {
    reader.readStartArray();
    let value: IArgonEvent = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<ArchetypeChanged>("ArchetypeChanged").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<ArchetypeCreated>("ArchetypeCreated").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<ChannelCreated>("ChannelCreated").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<ChannelModified>("ChannelModified").read(reader);
    else if (unionIndex == 4)
      value = IonFormatterStorage.get<ChannelRemoved>("ChannelRemoved").read(reader);
    else if (unionIndex == 5)
      value = IonFormatterStorage.get<UserTypingEvent>("UserTypingEvent").read(reader);
    else if (unionIndex == 6)
      value = IonFormatterStorage.get<UserStopTypingEvent>("UserStopTypingEvent").read(reader);
    else if (unionIndex == 7)
      value = IonFormatterStorage.get<JoinedToChannelUser>("JoinedToChannelUser").read(reader);
    else if (unionIndex == 8)
      value = IonFormatterStorage.get<JoinToServerUser>("JoinToServerUser").read(reader);
    else if (unionIndex == 9)
      value = IonFormatterStorage.get<LeavedFromChannelUser>("LeavedFromChannelUser").read(reader);
    else if (unionIndex == 10)
      value = IonFormatterStorage.get<UserUpdated>("UserUpdated").read(reader);
    else if (unionIndex == 11)
      value = IonFormatterStorage.get<OnUserPresenceActivityChanged>("OnUserPresenceActivityChanged").read(reader);
    else if (unionIndex == 12)
      value = IonFormatterStorage.get<OnUserPresenceActivityRemoved>("OnUserPresenceActivityRemoved").read(reader);
    else if (unionIndex == 13)
      value = IonFormatterStorage.get<UserChangedStatus>("UserChangedStatus").read(reader);
    else if (unionIndex == 14)
      value = IonFormatterStorage.get<MessageSent>("MessageSent").read(reader);
    else if (unionIndex == 15)
      value = IonFormatterStorage.get<ServerModified>("ServerModified").read(reader);
    else if (unionIndex == 16)
      value = IonFormatterStorage.get<RecordStarted>("RecordStarted").read(reader);
    else if (unionIndex == 17)
      value = IonFormatterStorage.get<RecordEnded>("RecordEnded").read(reader);
    else if (unionIndex == 18)
      value = IonFormatterStorage.get<CallIncoming>("CallIncoming").read(reader);
    else if (unionIndex == 19)
      value = IonFormatterStorage.get<CallFinished>("CallFinished").read(reader);
    else if (unionIndex == 20)
      value = IonFormatterStorage.get<CallAccepted>("CallAccepted").read(reader);
    else if (unionIndex == 21)
      value = IonFormatterStorage.get<CallRejected>("CallRejected").read(reader);
    else if (unionIndex == 22)
      value = IonFormatterStorage.get<FriendRequestReceivedEvent>("FriendRequestReceivedEvent").read(reader);
    else if (unionIndex == 23)
      value = IonFormatterStorage.get<FriendRequestSentEvent>("FriendRequestSentEvent").read(reader);
    else if (unionIndex == 24)
      value = IonFormatterStorage.get<FriendRequestAcceptedEvent>("FriendRequestAcceptedEvent").read(reader);
    else if (unionIndex == 25)
      value = IonFormatterStorage.get<FriendRequestDeclinedEvent>("FriendRequestDeclinedEvent").read(reader);
    else if (unionIndex == 26)
      value = IonFormatterStorage.get<FriendRequestCanceledEvent>("FriendRequestCanceledEvent").read(reader);
    else if (unionIndex == 27)
      value = IonFormatterStorage.get<FriendshipRemovedEvent>("FriendshipRemovedEvent").read(reader);
    else if (unionIndex == 28)
      value = IonFormatterStorage.get<UserBlockedEvent>("UserBlockedEvent").read(reader);
    else if (unionIndex == 29)
      value = IonFormatterStorage.get<UserUnblockedEvent>("UserUnblockedEvent").read(reader);
    else if (unionIndex == 30)
      value = IonFormatterStorage.get<RecentChatUpdatedEvent>("RecentChatUpdatedEvent").read(reader);
    else if (unionIndex == 31)
      value = IonFormatterStorage.get<ChatPinnedEvent>("ChatPinnedEvent").read(reader);
    else if (unionIndex == 32)
      value = IonFormatterStorage.get<ChatUnpinnedEvent>("ChatUnpinnedEvent").read(reader);
    else if (unionIndex == 33)
      value = IonFormatterStorage.get<ChatReadEvent>("ChatReadEvent").read(reader);
    else if (unionIndex == 34)
      value = IonFormatterStorage.get<ChannelGroupCreated>("ChannelGroupCreated").read(reader);
    else if (unionIndex == 35)
      value = IonFormatterStorage.get<ChannelGroupModified>("ChannelGroupModified").read(reader);
    else if (unionIndex == 36)
      value = IonFormatterStorage.get<ChannelGroupRemoved>("ChannelGroupRemoved").read(reader);
    else if (unionIndex == 37)
      value = IonFormatterStorage.get<ChannelGroupReordered>("ChannelGroupReordered").read(reader);
    else if (unionIndex == 38)
      value = IonFormatterStorage.get<ChannelReordered>("ChannelReordered").read(reader);
    else if (unionIndex == 39)
      value = IonFormatterStorage.get<DirectMessageSent>("DirectMessageSent").read(reader);
    else if (unionIndex == 40)
      value = IonFormatterStorage.get<UpdatedNotificationCounters>("UpdatedNotificationCounters").read(reader);
    else if (unionIndex == 41)
      value = IonFormatterStorage.get<UserSecurityDetailsUpdated>("UserSecurityDetailsUpdated").read(reader);
    else if (unionIndex == 42)
      value = IonFormatterStorage.get<SpaceDetailsUpdated>("SpaceDetailsUpdated").read(reader);
    else if (unionIndex == 43)
      value = IonFormatterStorage.get<MeetingCreatedFor>("MeetingCreatedFor").read(reader);
    else if (unionIndex == 44)
      value = IonFormatterStorage.get<MeetingDeletedFor>("MeetingDeletedFor").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IArgonEvent): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<ArchetypeChanged>("ArchetypeChanged").write(writer, value as ArchetypeChanged);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<ArchetypeCreated>("ArchetypeCreated").write(writer, value as ArchetypeCreated);
    }
    else if (value.UnionIndex == 2) {
        IonFormatterStorage.get<ChannelCreated>("ChannelCreated").write(writer, value as ChannelCreated);
    }
    else if (value.UnionIndex == 3) {
        IonFormatterStorage.get<ChannelModified>("ChannelModified").write(writer, value as ChannelModified);
    }
    else if (value.UnionIndex == 4) {
        IonFormatterStorage.get<ChannelRemoved>("ChannelRemoved").write(writer, value as ChannelRemoved);
    }
    else if (value.UnionIndex == 5) {
        IonFormatterStorage.get<UserTypingEvent>("UserTypingEvent").write(writer, value as UserTypingEvent);
    }
    else if (value.UnionIndex == 6) {
        IonFormatterStorage.get<UserStopTypingEvent>("UserStopTypingEvent").write(writer, value as UserStopTypingEvent);
    }
    else if (value.UnionIndex == 7) {
        IonFormatterStorage.get<JoinedToChannelUser>("JoinedToChannelUser").write(writer, value as JoinedToChannelUser);
    }
    else if (value.UnionIndex == 8) {
        IonFormatterStorage.get<JoinToServerUser>("JoinToServerUser").write(writer, value as JoinToServerUser);
    }
    else if (value.UnionIndex == 9) {
        IonFormatterStorage.get<LeavedFromChannelUser>("LeavedFromChannelUser").write(writer, value as LeavedFromChannelUser);
    }
    else if (value.UnionIndex == 10) {
        IonFormatterStorage.get<UserUpdated>("UserUpdated").write(writer, value as UserUpdated);
    }
    else if (value.UnionIndex == 11) {
        IonFormatterStorage.get<OnUserPresenceActivityChanged>("OnUserPresenceActivityChanged").write(writer, value as OnUserPresenceActivityChanged);
    }
    else if (value.UnionIndex == 12) {
        IonFormatterStorage.get<OnUserPresenceActivityRemoved>("OnUserPresenceActivityRemoved").write(writer, value as OnUserPresenceActivityRemoved);
    }
    else if (value.UnionIndex == 13) {
        IonFormatterStorage.get<UserChangedStatus>("UserChangedStatus").write(writer, value as UserChangedStatus);
    }
    else if (value.UnionIndex == 14) {
        IonFormatterStorage.get<MessageSent>("MessageSent").write(writer, value as MessageSent);
    }
    else if (value.UnionIndex == 15) {
        IonFormatterStorage.get<ServerModified>("ServerModified").write(writer, value as ServerModified);
    }
    else if (value.UnionIndex == 16) {
        IonFormatterStorage.get<RecordStarted>("RecordStarted").write(writer, value as RecordStarted);
    }
    else if (value.UnionIndex == 17) {
        IonFormatterStorage.get<RecordEnded>("RecordEnded").write(writer, value as RecordEnded);
    }
    else if (value.UnionIndex == 18) {
        IonFormatterStorage.get<CallIncoming>("CallIncoming").write(writer, value as CallIncoming);
    }
    else if (value.UnionIndex == 19) {
        IonFormatterStorage.get<CallFinished>("CallFinished").write(writer, value as CallFinished);
    }
    else if (value.UnionIndex == 20) {
        IonFormatterStorage.get<CallAccepted>("CallAccepted").write(writer, value as CallAccepted);
    }
    else if (value.UnionIndex == 21) {
        IonFormatterStorage.get<CallRejected>("CallRejected").write(writer, value as CallRejected);
    }
    else if (value.UnionIndex == 22) {
        IonFormatterStorage.get<FriendRequestReceivedEvent>("FriendRequestReceivedEvent").write(writer, value as FriendRequestReceivedEvent);
    }
    else if (value.UnionIndex == 23) {
        IonFormatterStorage.get<FriendRequestSentEvent>("FriendRequestSentEvent").write(writer, value as FriendRequestSentEvent);
    }
    else if (value.UnionIndex == 24) {
        IonFormatterStorage.get<FriendRequestAcceptedEvent>("FriendRequestAcceptedEvent").write(writer, value as FriendRequestAcceptedEvent);
    }
    else if (value.UnionIndex == 25) {
        IonFormatterStorage.get<FriendRequestDeclinedEvent>("FriendRequestDeclinedEvent").write(writer, value as FriendRequestDeclinedEvent);
    }
    else if (value.UnionIndex == 26) {
        IonFormatterStorage.get<FriendRequestCanceledEvent>("FriendRequestCanceledEvent").write(writer, value as FriendRequestCanceledEvent);
    }
    else if (value.UnionIndex == 27) {
        IonFormatterStorage.get<FriendshipRemovedEvent>("FriendshipRemovedEvent").write(writer, value as FriendshipRemovedEvent);
    }
    else if (value.UnionIndex == 28) {
        IonFormatterStorage.get<UserBlockedEvent>("UserBlockedEvent").write(writer, value as UserBlockedEvent);
    }
    else if (value.UnionIndex == 29) {
        IonFormatterStorage.get<UserUnblockedEvent>("UserUnblockedEvent").write(writer, value as UserUnblockedEvent);
    }
    else if (value.UnionIndex == 30) {
        IonFormatterStorage.get<RecentChatUpdatedEvent>("RecentChatUpdatedEvent").write(writer, value as RecentChatUpdatedEvent);
    }
    else if (value.UnionIndex == 31) {
        IonFormatterStorage.get<ChatPinnedEvent>("ChatPinnedEvent").write(writer, value as ChatPinnedEvent);
    }
    else if (value.UnionIndex == 32) {
        IonFormatterStorage.get<ChatUnpinnedEvent>("ChatUnpinnedEvent").write(writer, value as ChatUnpinnedEvent);
    }
    else if (value.UnionIndex == 33) {
        IonFormatterStorage.get<ChatReadEvent>("ChatReadEvent").write(writer, value as ChatReadEvent);
    }
    else if (value.UnionIndex == 34) {
        IonFormatterStorage.get<ChannelGroupCreated>("ChannelGroupCreated").write(writer, value as ChannelGroupCreated);
    }
    else if (value.UnionIndex == 35) {
        IonFormatterStorage.get<ChannelGroupModified>("ChannelGroupModified").write(writer, value as ChannelGroupModified);
    }
    else if (value.UnionIndex == 36) {
        IonFormatterStorage.get<ChannelGroupRemoved>("ChannelGroupRemoved").write(writer, value as ChannelGroupRemoved);
    }
    else if (value.UnionIndex == 37) {
        IonFormatterStorage.get<ChannelGroupReordered>("ChannelGroupReordered").write(writer, value as ChannelGroupReordered);
    }
    else if (value.UnionIndex == 38) {
        IonFormatterStorage.get<ChannelReordered>("ChannelReordered").write(writer, value as ChannelReordered);
    }
    else if (value.UnionIndex == 39) {
        IonFormatterStorage.get<DirectMessageSent>("DirectMessageSent").write(writer, value as DirectMessageSent);
    }
    else if (value.UnionIndex == 40) {
        IonFormatterStorage.get<UpdatedNotificationCounters>("UpdatedNotificationCounters").write(writer, value as UpdatedNotificationCounters);
    }
    else if (value.UnionIndex == 41) {
        IonFormatterStorage.get<UserSecurityDetailsUpdated>("UserSecurityDetailsUpdated").write(writer, value as UserSecurityDetailsUpdated);
    }
    else if (value.UnionIndex == 42) {
        IonFormatterStorage.get<SpaceDetailsUpdated>("SpaceDetailsUpdated").write(writer, value as SpaceDetailsUpdated);
    }
    else if (value.UnionIndex == 43) {
        IonFormatterStorage.get<MeetingCreatedFor>("MeetingCreatedFor").write(writer, value as MeetingCreatedFor);
    }
    else if (value.UnionIndex == 44) {
        IonFormatterStorage.get<MeetingDeletedFor>("MeetingDeletedFor").write(writer, value as MeetingDeletedFor);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("ArchetypeChanged", {
  read(reader: CborReader): ArchetypeChanged {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<Archetype>('Archetype').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ArchetypeChanged(spaceId, data);
  },
  write(writer: CborWriter, value: ArchetypeChanged): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArchetypeCreated", {
  read(reader: CborReader): ArchetypeCreated {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<Archetype>('Archetype').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ArchetypeCreated(spaceId, data);
  },
  write(writer: CborWriter, value: ArchetypeCreated): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelCreated", {
  read(reader: CborReader): ChannelCreated {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<ArgonChannel>('ArgonChannel').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ChannelCreated(spaceId, data);
  },
  write(writer: CborWriter, value: ChannelCreated): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonChannel>('ArgonChannel').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelModified", {
  read(reader: CborReader): ChannelModified {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const bag = IonFormatterStorage.readArray<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 3);
    return new ChannelModified(spaceId, channelId, bag);
  },
  write(writer: CborWriter, value: ChannelModified): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.writeArray<string>(writer, value.bag, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelRemoved", {
  read(reader: CborReader): ChannelRemoved {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ChannelRemoved(spaceId, channelId);
  },
  write(writer: CborWriter, value: ChannelRemoved): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserTypingEvent", {
  read(reader: CborReader): UserTypingEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new UserTypingEvent(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: UserTypingEvent): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserStopTypingEvent", {
  read(reader: CborReader): UserStopTypingEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new UserStopTypingEvent(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: UserStopTypingEvent): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("JoinedToChannelUser", {
  read(reader: CborReader): JoinedToChannelUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new JoinedToChannelUser(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: JoinedToChannelUser): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("JoinToServerUser", {
  read(reader: CborReader): JoinToServerUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new JoinToServerUser(spaceId, userId);
  },
  write(writer: CborWriter, value: JoinToServerUser): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("LeavedFromChannelUser", {
  read(reader: CborReader): LeavedFromChannelUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new LeavedFromChannelUser(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: LeavedFromChannelUser): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserUpdated", {
  read(reader: CborReader): UserUpdated {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const dto = IonFormatterStorage.get<ArgonUser>('ArgonUser').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new UserUpdated(spaceId, dto);
  },
  write(writer: CborWriter, value: UserUpdated): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonUser>('ArgonUser').write(writer, value.dto);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("OnUserPresenceActivityChanged", {
  read(reader: CborReader): OnUserPresenceActivityChanged {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const presence = IonFormatterStorage.get<UserActivityPresence>('UserActivityPresence').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new OnUserPresenceActivityChanged(spaceId, userId, presence);
  },
  write(writer: CborWriter, value: OnUserPresenceActivityChanged): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<UserActivityPresence>('UserActivityPresence').write(writer, value.presence);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("OnUserPresenceActivityRemoved", {
  read(reader: CborReader): OnUserPresenceActivityRemoved {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new OnUserPresenceActivityRemoved(spaceId, userId);
  },
  write(writer: CborWriter, value: OnUserPresenceActivityRemoved): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserChangedStatus", {
  read(reader: CborReader): UserChangedStatus {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const status = IonFormatterStorage.get<UserStatus>('UserStatus').read(reader);
    const bag = IonFormatterStorage.readArray<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 4);
    return new UserChangedStatus(spaceId, userId, status, bag);
  },
  write(writer: CborWriter, value: UserChangedStatus): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<UserStatus>('UserStatus').write(writer, value.status);
    IonFormatterStorage.writeArray<string>(writer, value.bag, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageSent", {
  read(reader: CborReader): MessageSent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const message = IonFormatterStorage.get<ArgonMessage>('ArgonMessage').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new MessageSent(spaceId, message);
  },
  write(writer: CborWriter, value: MessageSent): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonMessage>('ArgonMessage').write(writer, value.message);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ServerModified", {
  read(reader: CborReader): ServerModified {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const bag = IonFormatterStorage.readArray<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ServerModified(spaceId, bag);
  },
  write(writer: CborWriter, value: ServerModified): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.writeArray<string>(writer, value.bag, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("RecordStarted", {
  read(reader: CborReader): RecordStarted {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const byUserId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new RecordStarted(spaceId, channelId, byUserId);
  },
  write(writer: CborWriter, value: RecordStarted): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.byUserId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("RecordEnded", {
  read(reader: CborReader): RecordEnded {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new RecordEnded(spaceId, channelId);
  },
  write(writer: CborWriter, value: RecordEnded): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("CallIncoming", {
  read(reader: CborReader): CallIncoming {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const callId = IonFormatterStorage.get<guid>('guid').read(reader);
    const fromId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new CallIncoming(userId, callId, fromId);
  },
  write(writer: CborWriter, value: CallIncoming): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.fromId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("CallFinished", {
  read(reader: CborReader): CallFinished {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const callId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new CallFinished(userId, callId);
  },
  write(writer: CborWriter, value: CallFinished): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("CallAccepted", {
  read(reader: CborReader): CallAccepted {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const callId = IonFormatterStorage.get<guid>('guid').read(reader);
    const fromId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new CallAccepted(userId, callId, fromId);
  },
  write(writer: CborWriter, value: CallAccepted): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.fromId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("CallRejected", {
  read(reader: CborReader): CallRejected {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const callId = IonFormatterStorage.get<guid>('guid').read(reader);
    const fromId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new CallRejected(userId, callId, fromId);
  },
  write(writer: CborWriter, value: CallRejected): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.fromId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FriendRequestReceivedEvent", {
  read(reader: CborReader): FriendRequestReceivedEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const requesterId = IonFormatterStorage.get<guid>('guid').read(reader);
    const requestDate = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new FriendRequestReceivedEvent(requesterId, requestDate);
  },
  write(writer: CborWriter, value: FriendRequestReceivedEvent): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.requesterId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.requestDate);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FriendRequestSentEvent", {
  read(reader: CborReader): FriendRequestSentEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const targetId = IonFormatterStorage.get<guid>('guid').read(reader);
    const requestDate = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new FriendRequestSentEvent(targetId, requestDate);
  },
  write(writer: CborWriter, value: FriendRequestSentEvent): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.targetId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.requestDate);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FriendRequestAcceptedEvent", {
  read(reader: CborReader): FriendRequestAcceptedEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const friendAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new FriendRequestAcceptedEvent(userId, friendAt);
  },
  write(writer: CborWriter, value: FriendRequestAcceptedEvent): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.friendAt);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FriendRequestDeclinedEvent", {
  read(reader: CborReader): FriendRequestDeclinedEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const targetId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FriendRequestDeclinedEvent(targetId);
  },
  write(writer: CborWriter, value: FriendRequestDeclinedEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.targetId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FriendRequestCanceledEvent", {
  read(reader: CborReader): FriendRequestCanceledEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const requesterId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FriendRequestCanceledEvent(requesterId);
  },
  write(writer: CborWriter, value: FriendRequestCanceledEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.requesterId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FriendshipRemovedEvent", {
  read(reader: CborReader): FriendshipRemovedEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FriendshipRemovedEvent(userId);
  },
  write(writer: CborWriter, value: FriendshipRemovedEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserBlockedEvent", {
  read(reader: CborReader): UserBlockedEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const blockId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new UserBlockedEvent(blockId);
  },
  write(writer: CborWriter, value: UserBlockedEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.blockId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserUnblockedEvent", {
  read(reader: CborReader): UserUnblockedEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const blockId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new UserUnblockedEvent(blockId);
  },
  write(writer: CborWriter, value: UserUnblockedEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.blockId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("RecentChatUpdatedEvent", {
  read(reader: CborReader): RecentChatUpdatedEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const peerId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const lastMessage = IonFormatterStorage.readNullable<string>(reader, 'string');
    const lastMessageAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new RecentChatUpdatedEvent(peerId, userId, lastMessage, lastMessageAt);
  },
  write(writer: CborWriter, value: RecentChatUpdatedEvent): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.peerId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.writeNullable<string>(writer, value.lastMessage, 'string');
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.lastMessageAt);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChatPinnedEvent", {
  read(reader: CborReader): ChatPinnedEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const peerId = IonFormatterStorage.get<guid>('guid').read(reader);
    const pinnedAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ChatPinnedEvent(peerId, pinnedAt);
  },
  write(writer: CborWriter, value: ChatPinnedEvent): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.peerId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.pinnedAt);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChatUnpinnedEvent", {
  read(reader: CborReader): ChatUnpinnedEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const peerId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new ChatUnpinnedEvent(peerId);
  },
  write(writer: CborWriter, value: ChatUnpinnedEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.peerId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChatReadEvent", {
  read(reader: CborReader): ChatReadEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const peerId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new ChatReadEvent(peerId);
  },
  write(writer: CborWriter, value: ChatReadEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.peerId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelGroupCreated", {
  read(reader: CborReader): ChannelGroupCreated {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<ChannelGroup>('ChannelGroup').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ChannelGroupCreated(spaceId, data);
  },
  write(writer: CborWriter, value: ChannelGroupCreated): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ChannelGroup>('ChannelGroup').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelGroupModified", {
  read(reader: CborReader): ChannelGroupModified {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const groupId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<ChannelGroup>('ChannelGroup').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new ChannelGroupModified(spaceId, groupId, data);
  },
  write(writer: CborWriter, value: ChannelGroupModified): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.groupId);
    IonFormatterStorage.get<ChannelGroup>('ChannelGroup').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelGroupRemoved", {
  read(reader: CborReader): ChannelGroupRemoved {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const groupId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ChannelGroupRemoved(spaceId, groupId);
  },
  write(writer: CborWriter, value: ChannelGroupRemoved): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.groupId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelGroupReordered", {
  read(reader: CborReader): ChannelGroupReordered {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const groupId = IonFormatterStorage.get<guid>('guid').read(reader);
    const fractionalIndex = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new ChannelGroupReordered(spaceId, groupId, fractionalIndex);
  },
  write(writer: CborWriter, value: ChannelGroupReordered): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.groupId);
    IonFormatterStorage.get<string>('string').write(writer, value.fractionalIndex);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelReordered", {
  read(reader: CborReader): ChannelReordered {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const targetGroupId = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    const fractionalIndex = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new ChannelReordered(spaceId, channelId, targetGroupId, fractionalIndex);
  },
  write(writer: CborWriter, value: ChannelReordered): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.writeNullable<guid>(writer, value.targetGroupId, 'guid');
    IonFormatterStorage.get<string>('string').write(writer, value.fractionalIndex);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("DirectMessageSent", {
  read(reader: CborReader): DirectMessageSent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const senderId = IonFormatterStorage.get<guid>('guid').read(reader);
    const receiverId = IonFormatterStorage.get<guid>('guid').read(reader);
    const message = IonFormatterStorage.get<DirectMessage>('DirectMessage').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new DirectMessageSent(senderId, receiverId, message);
  },
  write(writer: CborWriter, value: DirectMessageSent): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.senderId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.receiverId);
    IonFormatterStorage.get<DirectMessage>('DirectMessage').write(writer, value.message);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UpdatedNotificationCounters", {
  read(reader: CborReader): UpdatedNotificationCounters {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const counters = IonFormatterStorage.readArray<NotificationCounterKv>(reader, 'NotificationCounterKv');
    reader.readEndArrayAndSkip(arraySize - 2);
    return new UpdatedNotificationCounters(userId, counters);
  },
  write(writer: CborWriter, value: UpdatedNotificationCounters): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.writeArray<NotificationCounterKv>(writer, value.counters, 'NotificationCounterKv');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserSecurityDetailsUpdated", {
  read(reader: CborReader): UserSecurityDetailsUpdated {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const details = IonFormatterStorage.get<SecurityDetails>('SecurityDetails').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new UserSecurityDetailsUpdated(userId, details);
  },
  write(writer: CborWriter, value: UserSecurityDetailsUpdated): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<SecurityDetails>('SecurityDetails').write(writer, value.details);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SpaceDetailsUpdated", {
  read(reader: CborReader): SpaceDetailsUpdated {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const details = IonFormatterStorage.get<ArgonSpaceBase>('ArgonSpaceBase').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SpaceDetailsUpdated(spaceId, details);
  },
  write(writer: CborWriter, value: SpaceDetailsUpdated): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonSpaceBase>('ArgonSpaceBase').write(writer, value.details);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MeetingCreatedFor", {
  read(reader: CborReader): MeetingCreatedFor {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const meetInfo = IonFormatterStorage.get<LinkedMeetingInfo>('LinkedMeetingInfo').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new MeetingCreatedFor(spaceId, channelId, meetInfo);
  },
  write(writer: CborWriter, value: MeetingCreatedFor): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<LinkedMeetingInfo>('LinkedMeetingInfo').write(writer, value.meetInfo);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MeetingDeletedFor", {
  read(reader: CborReader): MeetingDeletedFor {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const meetInfo = IonFormatterStorage.get<LinkedMeetingInfo>('LinkedMeetingInfo').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new MeetingDeletedFor(spaceId, channelId, meetInfo);
  },
  write(writer: CborWriter, value: MeetingDeletedFor): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<LinkedMeetingInfo>('LinkedMeetingInfo').write(writer, value.meetInfo);
    writer.writeEndArray();
  }
});



export abstract class IArgonClientEvent implements IIonUnion<IArgonClientEvent>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isIAmTypingEvent(): this is IAmTypingEvent {
    return this.UnionKey === "IAmTypingEvent";
  }
  public isIAmStopTypingEvent(): this is IAmStopTypingEvent {
    return this.UnionKey === "IAmStopTypingEvent";
  }
  public isHeartBeatEvent(): this is HeartBeatEvent {
    return this.UnionKey === "HeartBeatEvent";
  }
  public isSubscribeToMySpaces(): this is SubscribeToMySpaces {
    return this.UnionKey === "SubscribeToMySpaces";
  }

}


export class IAmTypingEvent extends IArgonClientEvent
{
  constructor(public channelId: guid) { super(); }

  UnionKey: string = "IAmTypingEvent";
  UnionIndex: number = 0;
}

export class IAmStopTypingEvent extends IArgonClientEvent
{
  constructor(public channelId: guid) { super(); }

  UnionKey: string = "IAmStopTypingEvent";
  UnionIndex: number = 1;
}

export class HeartBeatEvent extends IArgonClientEvent
{
  constructor(public status: UserStatus) { super(); }

  UnionKey: string = "HeartBeatEvent";
  UnionIndex: number = 2;
}

export class SubscribeToMySpaces extends IArgonClientEvent
{
  constructor() { super(); }

  UnionKey: string = "SubscribeToMySpaces";
  UnionIndex: number = 3;
}



IonFormatterStorage.register("IArgonClientEvent", {
  read(reader: CborReader): IArgonClientEvent {
    reader.readStartArray();
    let value: IArgonClientEvent = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<IAmTypingEvent>("IAmTypingEvent").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<IAmStopTypingEvent>("IAmStopTypingEvent").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<HeartBeatEvent>("HeartBeatEvent").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<SubscribeToMySpaces>("SubscribeToMySpaces").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IArgonClientEvent): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<IAmTypingEvent>("IAmTypingEvent").write(writer, value as IAmTypingEvent);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<IAmStopTypingEvent>("IAmStopTypingEvent").write(writer, value as IAmStopTypingEvent);
    }
    else if (value.UnionIndex == 2) {
        IonFormatterStorage.get<HeartBeatEvent>("HeartBeatEvent").write(writer, value as HeartBeatEvent);
    }
    else if (value.UnionIndex == 3) {
        IonFormatterStorage.get<SubscribeToMySpaces>("SubscribeToMySpaces").write(writer, value as SubscribeToMySpaces);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("IAmTypingEvent", {
  read(reader: CborReader): IAmTypingEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new IAmTypingEvent(channelId);
  },
  write(writer: CborWriter, value: IAmTypingEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("IAmStopTypingEvent", {
  read(reader: CborReader): IAmStopTypingEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new IAmStopTypingEvent(channelId);
  },
  write(writer: CborWriter, value: IAmStopTypingEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("HeartBeatEvent", {
  read(reader: CborReader): HeartBeatEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const status = IonFormatterStorage.get<UserStatus>('UserStatus').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new HeartBeatEvent(status);
  },
  write(writer: CborWriter, value: HeartBeatEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<UserStatus>('UserStatus').write(writer, value.status);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SubscribeToMySpaces", {
  read(reader: CborReader): SubscribeToMySpaces {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SubscribeToMySpaces();
  },
  write(writer: CborWriter, value: SubscribeToMySpaces): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});



export abstract class IMyAuthStatus implements IIonUnion<IMyAuthStatus>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isGoodAuthStatus(): this is GoodAuthStatus {
    return this.UnionKey === "GoodAuthStatus";
  }
  public isBadAuthStatus(): this is BadAuthStatus {
    return this.UnionKey === "BadAuthStatus";
  }
  public isLockedAuthStatus(): this is LockedAuthStatus {
    return this.UnionKey === "LockedAuthStatus";
  }
  public isCertificateErrorAuthStatus(): this is CertificateErrorAuthStatus {
    return this.UnionKey === "CertificateErrorAuthStatus";
  }

}


export class GoodAuthStatus extends IMyAuthStatus
{
  constructor(public token: string) { super(); }

  UnionKey: string = "GoodAuthStatus";
  UnionIndex: number = 0;
}

export class BadAuthStatus extends IMyAuthStatus
{
  constructor(public error: BadAuthKind) { super(); }

  UnionKey: string = "BadAuthStatus";
  UnionIndex: number = 1;
}

export class LockedAuthStatus extends IMyAuthStatus
{
  constructor(public lockdownReason: LockdownReason | null, public lockDownExpiration: datetime | null, public isAppealable: bool, public severity: LockdownSeverity) { super(); }

  UnionKey: string = "LockedAuthStatus";
  UnionIndex: number = 2;
}

export class CertificateErrorAuthStatus extends IMyAuthStatus
{
  constructor(public message: string) { super(); }

  UnionKey: string = "CertificateErrorAuthStatus";
  UnionIndex: number = 3;
}



IonFormatterStorage.register("IMyAuthStatus", {
  read(reader: CborReader): IMyAuthStatus {
    reader.readStartArray();
    let value: IMyAuthStatus = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<GoodAuthStatus>("GoodAuthStatus").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<BadAuthStatus>("BadAuthStatus").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<LockedAuthStatus>("LockedAuthStatus").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<CertificateErrorAuthStatus>("CertificateErrorAuthStatus").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IMyAuthStatus): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<GoodAuthStatus>("GoodAuthStatus").write(writer, value as GoodAuthStatus);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<BadAuthStatus>("BadAuthStatus").write(writer, value as BadAuthStatus);
    }
    else if (value.UnionIndex == 2) {
        IonFormatterStorage.get<LockedAuthStatus>("LockedAuthStatus").write(writer, value as LockedAuthStatus);
    }
    else if (value.UnionIndex == 3) {
        IonFormatterStorage.get<CertificateErrorAuthStatus>("CertificateErrorAuthStatus").write(writer, value as CertificateErrorAuthStatus);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("GoodAuthStatus", {
  read(reader: CborReader): GoodAuthStatus {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new GoodAuthStatus(token);
  },
  write(writer: CborWriter, value: GoodAuthStatus): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("BadAuthStatus", {
  read(reader: CborReader): BadAuthStatus {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<BadAuthKind>('BadAuthKind').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new BadAuthStatus(error);
  },
  write(writer: CborWriter, value: BadAuthStatus): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<BadAuthKind>('BadAuthKind').write(writer, value.error);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("LockedAuthStatus", {
  read(reader: CborReader): LockedAuthStatus {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const lockdownReason = IonFormatterStorage.readNullable<LockdownReason>(reader, 'LockdownReason');
    const lockDownExpiration = IonFormatterStorage.readNullable<datetime>(reader, 'datetime');
    const isAppealable = IonFormatterStorage.get<bool>('bool').read(reader);
    const severity = IonFormatterStorage.get<LockdownSeverity>('LockdownSeverity').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new LockedAuthStatus(lockdownReason, lockDownExpiration, isAppealable, severity);
  },
  write(writer: CborWriter, value: LockedAuthStatus): void {
    writer.writeStartArray(4);
    IonFormatterStorage.writeNullable<LockdownReason>(writer, value.lockdownReason, 'LockdownReason');
    IonFormatterStorage.writeNullable<datetime>(writer, value.lockDownExpiration, 'datetime');
    IonFormatterStorage.get<bool>('bool').write(writer, value.isAppealable);
    IonFormatterStorage.get<LockdownSeverity>('LockdownSeverity').write(writer, value.severity);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("CertificateErrorAuthStatus", {
  read(reader: CborReader): CertificateErrorAuthStatus {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const message = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new CertificateErrorAuthStatus(message);
  },
  write(writer: CborWriter, value: CertificateErrorAuthStatus): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.message);
    writer.writeEndArray();
  }
});



export abstract class IRedeemResult implements IIonUnion<IRedeemResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessRedeem(): this is SuccessRedeem {
    return this.UnionKey === "SuccessRedeem";
  }
  public isFailedRedeem(): this is FailedRedeem {
    return this.UnionKey === "FailedRedeem";
  }

}


export class SuccessRedeem extends IRedeemResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessRedeem";
  UnionIndex: number = 0;
}

export class FailedRedeem extends IRedeemResult
{
  constructor(public error: RedeemError) { super(); }

  UnionKey: string = "FailedRedeem";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IRedeemResult", {
  read(reader: CborReader): IRedeemResult {
    reader.readStartArray();
    let value: IRedeemResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessRedeem>("SuccessRedeem").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedRedeem>("FailedRedeem").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IRedeemResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessRedeem>("SuccessRedeem").write(writer, value as SuccessRedeem);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedRedeem>("FailedRedeem").write(writer, value as FailedRedeem);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessRedeem", {
  read(reader: CborReader): SuccessRedeem {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessRedeem();
  },
  write(writer: CborWriter, value: SuccessRedeem): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedRedeem", {
  read(reader: CborReader): FailedRedeem {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<RedeemError>('RedeemError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedRedeem(error);
  },
  write(writer: CborWriter, value: FailedRedeem): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<RedeemError>('RedeemError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IRequestEmailChangeResult implements IIonUnion<IRequestEmailChangeResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessRequestEmailChange(): this is SuccessRequestEmailChange {
    return this.UnionKey === "SuccessRequestEmailChange";
  }
  public isFailedRequestEmailChange(): this is FailedRequestEmailChange {
    return this.UnionKey === "FailedRequestEmailChange";
  }

}


export class SuccessRequestEmailChange extends IRequestEmailChangeResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessRequestEmailChange";
  UnionIndex: number = 0;
}

export class FailedRequestEmailChange extends IRequestEmailChangeResult
{
  constructor(public error: EmailChangeError) { super(); }

  UnionKey: string = "FailedRequestEmailChange";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IRequestEmailChangeResult", {
  read(reader: CborReader): IRequestEmailChangeResult {
    reader.readStartArray();
    let value: IRequestEmailChangeResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessRequestEmailChange>("SuccessRequestEmailChange").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedRequestEmailChange>("FailedRequestEmailChange").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IRequestEmailChangeResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessRequestEmailChange>("SuccessRequestEmailChange").write(writer, value as SuccessRequestEmailChange);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedRequestEmailChange>("FailedRequestEmailChange").write(writer, value as FailedRequestEmailChange);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessRequestEmailChange", {
  read(reader: CborReader): SuccessRequestEmailChange {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessRequestEmailChange();
  },
  write(writer: CborWriter, value: SuccessRequestEmailChange): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedRequestEmailChange", {
  read(reader: CborReader): FailedRequestEmailChange {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<EmailChangeError>('EmailChangeError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedRequestEmailChange(error);
  },
  write(writer: CborWriter, value: FailedRequestEmailChange): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<EmailChangeError>('EmailChangeError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IConfirmEmailChangeResult implements IIonUnion<IConfirmEmailChangeResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessConfirmEmailChange(): this is SuccessConfirmEmailChange {
    return this.UnionKey === "SuccessConfirmEmailChange";
  }
  public isFailedConfirmEmailChange(): this is FailedConfirmEmailChange {
    return this.UnionKey === "FailedConfirmEmailChange";
  }

}


export class SuccessConfirmEmailChange extends IConfirmEmailChangeResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessConfirmEmailChange";
  UnionIndex: number = 0;
}

export class FailedConfirmEmailChange extends IConfirmEmailChangeResult
{
  constructor(public error: EmailChangeError) { super(); }

  UnionKey: string = "FailedConfirmEmailChange";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IConfirmEmailChangeResult", {
  read(reader: CborReader): IConfirmEmailChangeResult {
    reader.readStartArray();
    let value: IConfirmEmailChangeResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessConfirmEmailChange>("SuccessConfirmEmailChange").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedConfirmEmailChange>("FailedConfirmEmailChange").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IConfirmEmailChangeResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessConfirmEmailChange>("SuccessConfirmEmailChange").write(writer, value as SuccessConfirmEmailChange);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedConfirmEmailChange>("FailedConfirmEmailChange").write(writer, value as FailedConfirmEmailChange);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessConfirmEmailChange", {
  read(reader: CborReader): SuccessConfirmEmailChange {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessConfirmEmailChange();
  },
  write(writer: CborWriter, value: SuccessConfirmEmailChange): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedConfirmEmailChange", {
  read(reader: CborReader): FailedConfirmEmailChange {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<EmailChangeError>('EmailChangeError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedConfirmEmailChange(error);
  },
  write(writer: CborWriter, value: FailedConfirmEmailChange): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<EmailChangeError>('EmailChangeError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IRequestPhoneChangeResult implements IIonUnion<IRequestPhoneChangeResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessRequestPhoneChange(): this is SuccessRequestPhoneChange {
    return this.UnionKey === "SuccessRequestPhoneChange";
  }
  public isFailedRequestPhoneChange(): this is FailedRequestPhoneChange {
    return this.UnionKey === "FailedRequestPhoneChange";
  }

}


export class SuccessRequestPhoneChange extends IRequestPhoneChangeResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessRequestPhoneChange";
  UnionIndex: number = 0;
}

export class FailedRequestPhoneChange extends IRequestPhoneChangeResult
{
  constructor(public error: PhoneChangeError) { super(); }

  UnionKey: string = "FailedRequestPhoneChange";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IRequestPhoneChangeResult", {
  read(reader: CborReader): IRequestPhoneChangeResult {
    reader.readStartArray();
    let value: IRequestPhoneChangeResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessRequestPhoneChange>("SuccessRequestPhoneChange").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedRequestPhoneChange>("FailedRequestPhoneChange").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IRequestPhoneChangeResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessRequestPhoneChange>("SuccessRequestPhoneChange").write(writer, value as SuccessRequestPhoneChange);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedRequestPhoneChange>("FailedRequestPhoneChange").write(writer, value as FailedRequestPhoneChange);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessRequestPhoneChange", {
  read(reader: CborReader): SuccessRequestPhoneChange {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessRequestPhoneChange();
  },
  write(writer: CborWriter, value: SuccessRequestPhoneChange): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedRequestPhoneChange", {
  read(reader: CborReader): FailedRequestPhoneChange {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<PhoneChangeError>('PhoneChangeError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedRequestPhoneChange(error);
  },
  write(writer: CborWriter, value: FailedRequestPhoneChange): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<PhoneChangeError>('PhoneChangeError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IConfirmPhoneChangeResult implements IIonUnion<IConfirmPhoneChangeResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessConfirmPhoneChange(): this is SuccessConfirmPhoneChange {
    return this.UnionKey === "SuccessConfirmPhoneChange";
  }
  public isFailedConfirmPhoneChange(): this is FailedConfirmPhoneChange {
    return this.UnionKey === "FailedConfirmPhoneChange";
  }

}


export class SuccessConfirmPhoneChange extends IConfirmPhoneChangeResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessConfirmPhoneChange";
  UnionIndex: number = 0;
}

export class FailedConfirmPhoneChange extends IConfirmPhoneChangeResult
{
  constructor(public error: PhoneChangeError) { super(); }

  UnionKey: string = "FailedConfirmPhoneChange";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IConfirmPhoneChangeResult", {
  read(reader: CborReader): IConfirmPhoneChangeResult {
    reader.readStartArray();
    let value: IConfirmPhoneChangeResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessConfirmPhoneChange>("SuccessConfirmPhoneChange").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedConfirmPhoneChange>("FailedConfirmPhoneChange").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IConfirmPhoneChangeResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessConfirmPhoneChange>("SuccessConfirmPhoneChange").write(writer, value as SuccessConfirmPhoneChange);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedConfirmPhoneChange>("FailedConfirmPhoneChange").write(writer, value as FailedConfirmPhoneChange);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessConfirmPhoneChange", {
  read(reader: CborReader): SuccessConfirmPhoneChange {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessConfirmPhoneChange();
  },
  write(writer: CborWriter, value: SuccessConfirmPhoneChange): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedConfirmPhoneChange", {
  read(reader: CborReader): FailedConfirmPhoneChange {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<PhoneChangeError>('PhoneChangeError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedConfirmPhoneChange(error);
  },
  write(writer: CborWriter, value: FailedConfirmPhoneChange): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<PhoneChangeError>('PhoneChangeError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IRemovePhoneResult implements IIonUnion<IRemovePhoneResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessRemovePhone(): this is SuccessRemovePhone {
    return this.UnionKey === "SuccessRemovePhone";
  }
  public isFailedRemovePhone(): this is FailedRemovePhone {
    return this.UnionKey === "FailedRemovePhone";
  }

}


export class SuccessRemovePhone extends IRemovePhoneResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessRemovePhone";
  UnionIndex: number = 0;
}

export class FailedRemovePhone extends IRemovePhoneResult
{
  constructor(public error: PhoneChangeError) { super(); }

  UnionKey: string = "FailedRemovePhone";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IRemovePhoneResult", {
  read(reader: CborReader): IRemovePhoneResult {
    reader.readStartArray();
    let value: IRemovePhoneResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessRemovePhone>("SuccessRemovePhone").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedRemovePhone>("FailedRemovePhone").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IRemovePhoneResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessRemovePhone>("SuccessRemovePhone").write(writer, value as SuccessRemovePhone);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedRemovePhone>("FailedRemovePhone").write(writer, value as FailedRemovePhone);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessRemovePhone", {
  read(reader: CborReader): SuccessRemovePhone {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessRemovePhone();
  },
  write(writer: CborWriter, value: SuccessRemovePhone): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedRemovePhone", {
  read(reader: CborReader): FailedRemovePhone {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<PhoneChangeError>('PhoneChangeError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedRemovePhone(error);
  },
  write(writer: CborWriter, value: FailedRemovePhone): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<PhoneChangeError>('PhoneChangeError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IChangePasswordResult implements IIonUnion<IChangePasswordResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessChangePassword(): this is SuccessChangePassword {
    return this.UnionKey === "SuccessChangePassword";
  }
  public isFailedChangePassword(): this is FailedChangePassword {
    return this.UnionKey === "FailedChangePassword";
  }

}


export class SuccessChangePassword extends IChangePasswordResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessChangePassword";
  UnionIndex: number = 0;
}

export class FailedChangePassword extends IChangePasswordResult
{
  constructor(public error: PasswordChangeError) { super(); }

  UnionKey: string = "FailedChangePassword";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IChangePasswordResult", {
  read(reader: CborReader): IChangePasswordResult {
    reader.readStartArray();
    let value: IChangePasswordResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessChangePassword>("SuccessChangePassword").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedChangePassword>("FailedChangePassword").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IChangePasswordResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessChangePassword>("SuccessChangePassword").write(writer, value as SuccessChangePassword);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedChangePassword>("FailedChangePassword").write(writer, value as FailedChangePassword);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessChangePassword", {
  read(reader: CborReader): SuccessChangePassword {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessChangePassword();
  },
  write(writer: CborWriter, value: SuccessChangePassword): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedChangePassword", {
  read(reader: CborReader): FailedChangePassword {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<PasswordChangeError>('PasswordChangeError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedChangePassword(error);
  },
  write(writer: CborWriter, value: FailedChangePassword): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<PasswordChangeError>('PasswordChangeError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IEnableOTPResult implements IIonUnion<IEnableOTPResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessEnableOTP(): this is SuccessEnableOTP {
    return this.UnionKey === "SuccessEnableOTP";
  }
  public isFailedEnableOTP(): this is FailedEnableOTP {
    return this.UnionKey === "FailedEnableOTP";
  }

}


export class SuccessEnableOTP extends IEnableOTPResult
{
  constructor(public secret: string, public qrCodeUrl: string) { super(); }

  UnionKey: string = "SuccessEnableOTP";
  UnionIndex: number = 0;
}

export class FailedEnableOTP extends IEnableOTPResult
{
  constructor(public error: OTPError) { super(); }

  UnionKey: string = "FailedEnableOTP";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IEnableOTPResult", {
  read(reader: CborReader): IEnableOTPResult {
    reader.readStartArray();
    let value: IEnableOTPResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessEnableOTP>("SuccessEnableOTP").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedEnableOTP>("FailedEnableOTP").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IEnableOTPResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessEnableOTP>("SuccessEnableOTP").write(writer, value as SuccessEnableOTP);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedEnableOTP>("FailedEnableOTP").write(writer, value as FailedEnableOTP);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessEnableOTP", {
  read(reader: CborReader): SuccessEnableOTP {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const secret = IonFormatterStorage.get<string>('string').read(reader);
    const qrCodeUrl = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SuccessEnableOTP(secret, qrCodeUrl);
  },
  write(writer: CborWriter, value: SuccessEnableOTP): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.secret);
    IonFormatterStorage.get<string>('string').write(writer, value.qrCodeUrl);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedEnableOTP", {
  read(reader: CborReader): FailedEnableOTP {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<OTPError>('OTPError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedEnableOTP(error);
  },
  write(writer: CborWriter, value: FailedEnableOTP): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<OTPError>('OTPError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IVerifyOTPResult implements IIonUnion<IVerifyOTPResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessVerifyOTP(): this is SuccessVerifyOTP {
    return this.UnionKey === "SuccessVerifyOTP";
  }
  public isFailedVerifyOTP(): this is FailedVerifyOTP {
    return this.UnionKey === "FailedVerifyOTP";
  }

}


export class SuccessVerifyOTP extends IVerifyOTPResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessVerifyOTP";
  UnionIndex: number = 0;
}

export class FailedVerifyOTP extends IVerifyOTPResult
{
  constructor(public error: OTPError) { super(); }

  UnionKey: string = "FailedVerifyOTP";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IVerifyOTPResult", {
  read(reader: CborReader): IVerifyOTPResult {
    reader.readStartArray();
    let value: IVerifyOTPResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessVerifyOTP>("SuccessVerifyOTP").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedVerifyOTP>("FailedVerifyOTP").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IVerifyOTPResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessVerifyOTP>("SuccessVerifyOTP").write(writer, value as SuccessVerifyOTP);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedVerifyOTP>("FailedVerifyOTP").write(writer, value as FailedVerifyOTP);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessVerifyOTP", {
  read(reader: CborReader): SuccessVerifyOTP {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessVerifyOTP();
  },
  write(writer: CborWriter, value: SuccessVerifyOTP): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedVerifyOTP", {
  read(reader: CborReader): FailedVerifyOTP {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<OTPError>('OTPError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedVerifyOTP(error);
  },
  write(writer: CborWriter, value: FailedVerifyOTP): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<OTPError>('OTPError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IDisableOTPResult implements IIonUnion<IDisableOTPResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessDisableOTP(): this is SuccessDisableOTP {
    return this.UnionKey === "SuccessDisableOTP";
  }
  public isFailedDisableOTP(): this is FailedDisableOTP {
    return this.UnionKey === "FailedDisableOTP";
  }

}


export class SuccessDisableOTP extends IDisableOTPResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessDisableOTP";
  UnionIndex: number = 0;
}

export class FailedDisableOTP extends IDisableOTPResult
{
  constructor(public error: OTPError) { super(); }

  UnionKey: string = "FailedDisableOTP";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IDisableOTPResult", {
  read(reader: CborReader): IDisableOTPResult {
    reader.readStartArray();
    let value: IDisableOTPResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessDisableOTP>("SuccessDisableOTP").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedDisableOTP>("FailedDisableOTP").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IDisableOTPResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessDisableOTP>("SuccessDisableOTP").write(writer, value as SuccessDisableOTP);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedDisableOTP>("FailedDisableOTP").write(writer, value as FailedDisableOTP);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessDisableOTP", {
  read(reader: CborReader): SuccessDisableOTP {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessDisableOTP();
  },
  write(writer: CborWriter, value: SuccessDisableOTP): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedDisableOTP", {
  read(reader: CborReader): FailedDisableOTP {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<OTPError>('OTPError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedDisableOTP(error);
  },
  write(writer: CborWriter, value: FailedDisableOTP): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<OTPError>('OTPError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IBeginPasskeyResult implements IIonUnion<IBeginPasskeyResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessBeginPasskey(): this is SuccessBeginPasskey {
    return this.UnionKey === "SuccessBeginPasskey";
  }
  public isFailedBeginPasskey(): this is FailedBeginPasskey {
    return this.UnionKey === "FailedBeginPasskey";
  }

}


export class SuccessBeginPasskey extends IBeginPasskeyResult
{
  constructor(public passkeyId: guid, public challenge: string) { super(); }

  UnionKey: string = "SuccessBeginPasskey";
  UnionIndex: number = 0;
}

export class FailedBeginPasskey extends IBeginPasskeyResult
{
  constructor(public error: PasskeyError) { super(); }

  UnionKey: string = "FailedBeginPasskey";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IBeginPasskeyResult", {
  read(reader: CborReader): IBeginPasskeyResult {
    reader.readStartArray();
    let value: IBeginPasskeyResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessBeginPasskey>("SuccessBeginPasskey").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedBeginPasskey>("FailedBeginPasskey").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IBeginPasskeyResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessBeginPasskey>("SuccessBeginPasskey").write(writer, value as SuccessBeginPasskey);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedBeginPasskey>("FailedBeginPasskey").write(writer, value as FailedBeginPasskey);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessBeginPasskey", {
  read(reader: CborReader): SuccessBeginPasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const passkeyId = IonFormatterStorage.get<guid>('guid').read(reader);
    const challenge = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SuccessBeginPasskey(passkeyId, challenge);
  },
  write(writer: CborWriter, value: SuccessBeginPasskey): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.passkeyId);
    IonFormatterStorage.get<string>('string').write(writer, value.challenge);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedBeginPasskey", {
  read(reader: CborReader): FailedBeginPasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<PasskeyError>('PasskeyError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedBeginPasskey(error);
  },
  write(writer: CborWriter, value: FailedBeginPasskey): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<PasskeyError>('PasskeyError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class ICompletePasskeyResult implements IIonUnion<ICompletePasskeyResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessCompletePasskey(): this is SuccessCompletePasskey {
    return this.UnionKey === "SuccessCompletePasskey";
  }
  public isFailedCompletePasskey(): this is FailedCompletePasskey {
    return this.UnionKey === "FailedCompletePasskey";
  }

}


export class SuccessCompletePasskey extends ICompletePasskeyResult
{
  constructor(public passkey: Passkey) { super(); }

  UnionKey: string = "SuccessCompletePasskey";
  UnionIndex: number = 0;
}

export class FailedCompletePasskey extends ICompletePasskeyResult
{
  constructor(public error: PasskeyError) { super(); }

  UnionKey: string = "FailedCompletePasskey";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("ICompletePasskeyResult", {
  read(reader: CborReader): ICompletePasskeyResult {
    reader.readStartArray();
    let value: ICompletePasskeyResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessCompletePasskey>("SuccessCompletePasskey").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedCompletePasskey>("FailedCompletePasskey").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: ICompletePasskeyResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessCompletePasskey>("SuccessCompletePasskey").write(writer, value as SuccessCompletePasskey);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedCompletePasskey>("FailedCompletePasskey").write(writer, value as FailedCompletePasskey);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessCompletePasskey", {
  read(reader: CborReader): SuccessCompletePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const passkey = IonFormatterStorage.get<Passkey>('Passkey').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new SuccessCompletePasskey(passkey);
  },
  write(writer: CborWriter, value: SuccessCompletePasskey): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<Passkey>('Passkey').write(writer, value.passkey);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedCompletePasskey", {
  read(reader: CborReader): FailedCompletePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<PasskeyError>('PasskeyError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedCompletePasskey(error);
  },
  write(writer: CborWriter, value: FailedCompletePasskey): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<PasskeyError>('PasskeyError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IRemovePasskeyResult implements IIonUnion<IRemovePasskeyResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessRemovePasskey(): this is SuccessRemovePasskey {
    return this.UnionKey === "SuccessRemovePasskey";
  }
  public isFailedRemovePasskey(): this is FailedRemovePasskey {
    return this.UnionKey === "FailedRemovePasskey";
  }

}


export class SuccessRemovePasskey extends IRemovePasskeyResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessRemovePasskey";
  UnionIndex: number = 0;
}

export class FailedRemovePasskey extends IRemovePasskeyResult
{
  constructor(public error: PasskeyError) { super(); }

  UnionKey: string = "FailedRemovePasskey";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IRemovePasskeyResult", {
  read(reader: CborReader): IRemovePasskeyResult {
    reader.readStartArray();
    let value: IRemovePasskeyResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessRemovePasskey>("SuccessRemovePasskey").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedRemovePasskey>("FailedRemovePasskey").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IRemovePasskeyResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessRemovePasskey>("SuccessRemovePasskey").write(writer, value as SuccessRemovePasskey);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedRemovePasskey>("FailedRemovePasskey").write(writer, value as FailedRemovePasskey);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessRemovePasskey", {
  read(reader: CborReader): SuccessRemovePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessRemovePasskey();
  },
  write(writer: CborWriter, value: SuccessRemovePasskey): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedRemovePasskey", {
  read(reader: CborReader): FailedRemovePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<PasskeyError>('PasskeyError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedRemovePasskey(error);
  },
  write(writer: CborWriter, value: FailedRemovePasskey): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<PasskeyError>('PasskeyError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IBeginPasskeyValidateResult implements IIonUnion<IBeginPasskeyValidateResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessBeginValidatePasskey(): this is SuccessBeginValidatePasskey {
    return this.UnionKey === "SuccessBeginValidatePasskey";
  }
  public isFailedBeginValidatePasskey(): this is FailedBeginValidatePasskey {
    return this.UnionKey === "FailedBeginValidatePasskey";
  }

}


export class SuccessBeginValidatePasskey extends IBeginPasskeyValidateResult
{
  constructor(public challenge: string, public allowedCredentials: IonArray<PasskeyCredentialDescriptor>) { super(); }

  UnionKey: string = "SuccessBeginValidatePasskey";
  UnionIndex: number = 0;
}

export class FailedBeginValidatePasskey extends IBeginPasskeyValidateResult
{
  constructor(public error: PasskeyError) { super(); }

  UnionKey: string = "FailedBeginValidatePasskey";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IBeginPasskeyValidateResult", {
  read(reader: CborReader): IBeginPasskeyValidateResult {
    reader.readStartArray();
    let value: IBeginPasskeyValidateResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessBeginValidatePasskey>("SuccessBeginValidatePasskey").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedBeginValidatePasskey>("FailedBeginValidatePasskey").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IBeginPasskeyValidateResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessBeginValidatePasskey>("SuccessBeginValidatePasskey").write(writer, value as SuccessBeginValidatePasskey);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedBeginValidatePasskey>("FailedBeginValidatePasskey").write(writer, value as FailedBeginValidatePasskey);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessBeginValidatePasskey", {
  read(reader: CborReader): SuccessBeginValidatePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const challenge = IonFormatterStorage.get<string>('string').read(reader);
    const allowedCredentials = IonFormatterStorage.readArray<PasskeyCredentialDescriptor>(reader, 'PasskeyCredentialDescriptor');
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SuccessBeginValidatePasskey(challenge, allowedCredentials);
  },
  write(writer: CborWriter, value: SuccessBeginValidatePasskey): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.challenge);
    IonFormatterStorage.writeArray<PasskeyCredentialDescriptor>(writer, value.allowedCredentials, 'PasskeyCredentialDescriptor');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedBeginValidatePasskey", {
  read(reader: CborReader): FailedBeginValidatePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<PasskeyError>('PasskeyError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedBeginValidatePasskey(error);
  },
  write(writer: CborWriter, value: FailedBeginValidatePasskey): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<PasskeyError>('PasskeyError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class ISetAutoDeleteResult implements IIonUnion<ISetAutoDeleteResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessSetAutoDelete(): this is SuccessSetAutoDelete {
    return this.UnionKey === "SuccessSetAutoDelete";
  }
  public isFailedSetAutoDelete(): this is FailedSetAutoDelete {
    return this.UnionKey === "FailedSetAutoDelete";
  }

}


export class SuccessSetAutoDelete extends ISetAutoDeleteResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessSetAutoDelete";
  UnionIndex: number = 0;
}

export class FailedSetAutoDelete extends ISetAutoDeleteResult
{
  constructor(public error: AutoDeleteError) { super(); }

  UnionKey: string = "FailedSetAutoDelete";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("ISetAutoDeleteResult", {
  read(reader: CborReader): ISetAutoDeleteResult {
    reader.readStartArray();
    let value: ISetAutoDeleteResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessSetAutoDelete>("SuccessSetAutoDelete").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedSetAutoDelete>("FailedSetAutoDelete").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: ISetAutoDeleteResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessSetAutoDelete>("SuccessSetAutoDelete").write(writer, value as SuccessSetAutoDelete);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedSetAutoDelete>("FailedSetAutoDelete").write(writer, value as FailedSetAutoDelete);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessSetAutoDelete", {
  read(reader: CborReader): SuccessSetAutoDelete {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessSetAutoDelete();
  },
  write(writer: CborWriter, value: SuccessSetAutoDelete): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedSetAutoDelete", {
  read(reader: CborReader): FailedSetAutoDelete {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<AutoDeleteError>('AutoDeleteError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedSetAutoDelete(error);
  },
  write(writer: CborWriter, value: FailedSetAutoDelete): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<AutoDeleteError>('AutoDeleteError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IUploadFileResult implements IIonUnion<IUploadFileResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessUploadFile(): this is SuccessUploadFile {
    return this.UnionKey === "SuccessUploadFile";
  }
  public isFailedUploadFile(): this is FailedUploadFile {
    return this.UnionKey === "FailedUploadFile";
  }

}


export class SuccessUploadFile extends IUploadFileResult
{
  constructor(public blobId: guid) { super(); }

  UnionKey: string = "SuccessUploadFile";
  UnionIndex: number = 0;
}

export class FailedUploadFile extends IUploadFileResult
{
  constructor(public error: UploadFileError) { super(); }

  UnionKey: string = "FailedUploadFile";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IUploadFileResult", {
  read(reader: CborReader): IUploadFileResult {
    reader.readStartArray();
    let value: IUploadFileResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessUploadFile>("SuccessUploadFile").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedUploadFile>("FailedUploadFile").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IUploadFileResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessUploadFile>("SuccessUploadFile").write(writer, value as SuccessUploadFile);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedUploadFile>("FailedUploadFile").write(writer, value as FailedUploadFile);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessUploadFile", {
  read(reader: CborReader): SuccessUploadFile {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const blobId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new SuccessUploadFile(blobId);
  },
  write(writer: CborWriter, value: SuccessUploadFile): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.blobId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedUploadFile", {
  read(reader: CborReader): FailedUploadFile {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<UploadFileError>('UploadFileError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedUploadFile(error);
  },
  write(writer: CborWriter, value: FailedUploadFile): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<UploadFileError>('UploadFileError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class ICreateSpaceResult implements IIonUnion<ICreateSpaceResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessCreateSpace(): this is SuccessCreateSpace {
    return this.UnionKey === "SuccessCreateSpace";
  }
  public isFailedCreateSpace(): this is FailedCreateSpace {
    return this.UnionKey === "FailedCreateSpace";
  }

}


export class SuccessCreateSpace extends ICreateSpaceResult
{
  constructor(public space: ArgonSpaceBase) { super(); }

  UnionKey: string = "SuccessCreateSpace";
  UnionIndex: number = 0;
}

export class FailedCreateSpace extends ICreateSpaceResult
{
  constructor(public error: CreateSpaceError) { super(); }

  UnionKey: string = "FailedCreateSpace";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("ICreateSpaceResult", {
  read(reader: CborReader): ICreateSpaceResult {
    reader.readStartArray();
    let value: ICreateSpaceResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessCreateSpace>("SuccessCreateSpace").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedCreateSpace>("FailedCreateSpace").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: ICreateSpaceResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessCreateSpace>("SuccessCreateSpace").write(writer, value as SuccessCreateSpace);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedCreateSpace>("FailedCreateSpace").write(writer, value as FailedCreateSpace);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessCreateSpace", {
  read(reader: CborReader): SuccessCreateSpace {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const space = IonFormatterStorage.get<ArgonSpaceBase>('ArgonSpaceBase').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new SuccessCreateSpace(space);
  },
  write(writer: CborWriter, value: SuccessCreateSpace): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<ArgonSpaceBase>('ArgonSpaceBase').write(writer, value.space);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedCreateSpace", {
  read(reader: CborReader): FailedCreateSpace {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<CreateSpaceError>('CreateSpaceError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedCreateSpace(error);
  },
  write(writer: CborWriter, value: FailedCreateSpace): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<CreateSpaceError>('CreateSpaceError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IAuthorizeResult implements IIonUnion<IAuthorizeResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessAuthorize(): this is SuccessAuthorize {
    return this.UnionKey === "SuccessAuthorize";
  }
  public isFailedAuthorize(): this is FailedAuthorize {
    return this.UnionKey === "FailedAuthorize";
  }

}


export class SuccessAuthorize extends IAuthorizeResult
{
  constructor(public token: string, public refreshToken: string | null) { super(); }

  UnionKey: string = "SuccessAuthorize";
  UnionIndex: number = 0;
}

export class FailedAuthorize extends IAuthorizeResult
{
  constructor(public error: AuthorizationError) { super(); }

  UnionKey: string = "FailedAuthorize";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IAuthorizeResult", {
  read(reader: CborReader): IAuthorizeResult {
    reader.readStartArray();
    let value: IAuthorizeResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessAuthorize>("SuccessAuthorize").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedAuthorize>("FailedAuthorize").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IAuthorizeResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessAuthorize>("SuccessAuthorize").write(writer, value as SuccessAuthorize);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedAuthorize>("FailedAuthorize").write(writer, value as FailedAuthorize);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessAuthorize", {
  read(reader: CborReader): SuccessAuthorize {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    const refreshToken = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SuccessAuthorize(token, refreshToken);
  },
  write(writer: CborWriter, value: SuccessAuthorize): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    IonFormatterStorage.writeNullable<string>(writer, value.refreshToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedAuthorize", {
  read(reader: CborReader): FailedAuthorize {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<AuthorizationError>('AuthorizationError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedAuthorize(error);
  },
  write(writer: CborWriter, value: FailedAuthorize): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<AuthorizationError>('AuthorizationError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IRegistrationResult implements IIonUnion<IRegistrationResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessRegistration(): this is SuccessRegistration {
    return this.UnionKey === "SuccessRegistration";
  }
  public isFailedRegistration(): this is FailedRegistration {
    return this.UnionKey === "FailedRegistration";
  }

}


export class SuccessRegistration extends IRegistrationResult
{
  constructor(public token: string, public refreshToken: string | null) { super(); }

  UnionKey: string = "SuccessRegistration";
  UnionIndex: number = 0;
}

export class FailedRegistration extends IRegistrationResult
{
  constructor(public error: RegistrationError, public field: string | null, public message: string | null) { super(); }

  UnionKey: string = "FailedRegistration";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IRegistrationResult", {
  read(reader: CborReader): IRegistrationResult {
    reader.readStartArray();
    let value: IRegistrationResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessRegistration>("SuccessRegistration").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedRegistration>("FailedRegistration").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IRegistrationResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessRegistration>("SuccessRegistration").write(writer, value as SuccessRegistration);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedRegistration>("FailedRegistration").write(writer, value as FailedRegistration);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessRegistration", {
  read(reader: CborReader): SuccessRegistration {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    const refreshToken = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SuccessRegistration(token, refreshToken);
  },
  write(writer: CborWriter, value: SuccessRegistration): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    IonFormatterStorage.writeNullable<string>(writer, value.refreshToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedRegistration", {
  read(reader: CborReader): FailedRegistration {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<RegistrationError>('RegistrationError').read(reader);
    const field = IonFormatterStorage.readNullable<string>(reader, 'string');
    const message = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 3);
    return new FailedRegistration(error, field, message);
  },
  write(writer: CborWriter, value: FailedRegistration): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<RegistrationError>('RegistrationError').write(writer, value.error);
    IonFormatterStorage.writeNullable<string>(writer, value.field, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.message, 'string');
    writer.writeEndArray();
  }
});



export abstract class IJoinToSpaceResult implements IIonUnion<IJoinToSpaceResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessJoin(): this is SuccessJoin {
    return this.UnionKey === "SuccessJoin";
  }
  public isFailedJoin(): this is FailedJoin {
    return this.UnionKey === "FailedJoin";
  }

}


export class SuccessJoin extends IJoinToSpaceResult
{
  constructor(public space: ArgonSpace) { super(); }

  UnionKey: string = "SuccessJoin";
  UnionIndex: number = 0;
}

export class FailedJoin extends IJoinToSpaceResult
{
  constructor(public error: AcceptInviteError) { super(); }

  UnionKey: string = "FailedJoin";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IJoinToSpaceResult", {
  read(reader: CborReader): IJoinToSpaceResult {
    reader.readStartArray();
    let value: IJoinToSpaceResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessJoin>("SuccessJoin").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedJoin>("FailedJoin").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IJoinToSpaceResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessJoin>("SuccessJoin").write(writer, value as SuccessJoin);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedJoin>("FailedJoin").write(writer, value as FailedJoin);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessJoin", {
  read(reader: CborReader): SuccessJoin {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const space = IonFormatterStorage.get<ArgonSpace>('ArgonSpace').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new SuccessJoin(space);
  },
  write(writer: CborWriter, value: SuccessJoin): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<ArgonSpace>('ArgonSpace').write(writer, value.space);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedJoin", {
  read(reader: CborReader): FailedJoin {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<AcceptInviteError>('AcceptInviteError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedJoin(error);
  },
  write(writer: CborWriter, value: FailedJoin): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<AcceptInviteError>('AcceptInviteError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IBeginCallResult implements IIonUnion<IBeginCallResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessDingDong(): this is SuccessDingDong {
    return this.UnionKey === "SuccessDingDong";
  }
  public isFailedDingDong(): this is FailedDingDong {
    return this.UnionKey === "FailedDingDong";
  }

}


export class SuccessDingDong extends IBeginCallResult
{
  constructor(public token: string, public callId: guid, public rtc: RtcEndpoint) { super(); }

  UnionKey: string = "SuccessDingDong";
  UnionIndex: number = 0;
}

export class FailedDingDong extends IBeginCallResult
{
  constructor(public error: CallFailedError) { super(); }

  UnionKey: string = "FailedDingDong";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IBeginCallResult", {
  read(reader: CborReader): IBeginCallResult {
    reader.readStartArray();
    let value: IBeginCallResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessDingDong>("SuccessDingDong").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedDingDong>("FailedDingDong").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IBeginCallResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessDingDong>("SuccessDingDong").write(writer, value as SuccessDingDong);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedDingDong>("FailedDingDong").write(writer, value as FailedDingDong);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessDingDong", {
  read(reader: CborReader): SuccessDingDong {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    const callId = IonFormatterStorage.get<guid>('guid').read(reader);
    const rtc = IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new SuccessDingDong(token, callId, rtc);
  },
  write(writer: CborWriter, value: SuccessDingDong): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callId);
    IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').write(writer, value.rtc);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedDingDong", {
  read(reader: CborReader): FailedDingDong {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<CallFailedError>('CallFailedError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedDingDong(error);
  },
  write(writer: CborWriter, value: FailedDingDong): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<CallFailedError>('CallFailedError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IPickUpCallResult implements IIonUnion<IPickUpCallResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessPickUp(): this is SuccessPickUp {
    return this.UnionKey === "SuccessPickUp";
  }
  public isFailedPickUp(): this is FailedPickUp {
    return this.UnionKey === "FailedPickUp";
  }

}


export class SuccessPickUp extends IPickUpCallResult
{
  constructor(public token: string, public callId: guid, public rtc: RtcEndpoint) { super(); }

  UnionKey: string = "SuccessPickUp";
  UnionIndex: number = 0;
}

export class FailedPickUp extends IPickUpCallResult
{
  constructor(public error: string) { super(); }

  UnionKey: string = "FailedPickUp";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IPickUpCallResult", {
  read(reader: CborReader): IPickUpCallResult {
    reader.readStartArray();
    let value: IPickUpCallResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessPickUp>("SuccessPickUp").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedPickUp>("FailedPickUp").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IPickUpCallResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessPickUp>("SuccessPickUp").write(writer, value as SuccessPickUp);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedPickUp>("FailedPickUp").write(writer, value as FailedPickUp);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessPickUp", {
  read(reader: CborReader): SuccessPickUp {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    const callId = IonFormatterStorage.get<guid>('guid').read(reader);
    const rtc = IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new SuccessPickUp(token, callId, rtc);
  },
  write(writer: CborWriter, value: SuccessPickUp): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    IonFormatterStorage.get<guid>('guid').write(writer, value.callId);
    IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').write(writer, value.rtc);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedPickUp", {
  read(reader: CborReader): FailedPickUp {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedPickUp(error);
  },
  write(writer: CborWriter, value: FailedPickUp): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IDialCheckResult implements IIonUnion<IDialCheckResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessDialCheck(): this is SuccessDialCheck {
    return this.UnionKey === "SuccessDialCheck";
  }
  public isFailedDialCheck(): this is FailedDialCheck {
    return this.UnionKey === "FailedDialCheck";
  }

}


export class SuccessDialCheck extends IDialCheckResult
{
  constructor(public priceMin: i4, public corelId: guid, public corlId: guid) { super(); }

  UnionKey: string = "SuccessDialCheck";
  UnionIndex: number = 0;
}

export class FailedDialCheck extends IDialCheckResult
{
  constructor(public reason: DialCheckFailReason, public priceMin: i4) { super(); }

  UnionKey: string = "FailedDialCheck";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IDialCheckResult", {
  read(reader: CborReader): IDialCheckResult {
    reader.readStartArray();
    let value: IDialCheckResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessDialCheck>("SuccessDialCheck").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedDialCheck>("FailedDialCheck").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IDialCheckResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessDialCheck>("SuccessDialCheck").write(writer, value as SuccessDialCheck);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedDialCheck>("FailedDialCheck").write(writer, value as FailedDialCheck);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessDialCheck", {
  read(reader: CborReader): SuccessDialCheck {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const priceMin = IonFormatterStorage.get<i4>('i4').read(reader);
    const corelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const corlId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new SuccessDialCheck(priceMin, corelId, corlId);
  },
  write(writer: CborWriter, value: SuccessDialCheck): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<i4>('i4').write(writer, value.priceMin);
    IonFormatterStorage.get<guid>('guid').write(writer, value.corelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.corlId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedDialCheck", {
  read(reader: CborReader): FailedDialCheck {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const reason = IonFormatterStorage.get<DialCheckFailReason>('DialCheckFailReason').read(reader);
    const priceMin = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new FailedDialCheck(reason, priceMin);
  },
  write(writer: CborWriter, value: FailedDialCheck): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<DialCheckFailReason>('DialCheckFailReason').write(writer, value.reason);
    IonFormatterStorage.get<i4>('i4').write(writer, value.priceMin);
    writer.writeEndArray();
  }
});



IonFormatterStorage.register("ArgonEntitlement", {
  read(reader: CborReader): ArgonEntitlement {
    const num = (IonFormatterStorage.get<u8>('u8').read(reader))
    return num as any;
  },
  write(writer: CborWriter, value: ArgonEntitlement): void {
    const casted: u8 = value as any;
    IonFormatterStorage.get<u8>('u8').write(writer, casted);
  }
});

IonFormatterStorage.register("ChannelEntitlementOverwrite", {
  read(reader: CborReader): ChannelEntitlementOverwrite {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const archetypeId = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    const serverMemberId = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    const allow = IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').read(reader);
    const deny = IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').read(reader);
    const creatorId = IonFormatterStorage.get<guid>('guid').read(reader);
    const id = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 7);
    return { channelId, archetypeId, serverMemberId, allow, deny, creatorId, id };
  },
  write(writer: CborWriter, value: ChannelEntitlementOverwrite): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.writeNullable<guid>(writer, value.archetypeId, 'guid');
    IonFormatterStorage.writeNullable<guid>(writer, value.serverMemberId, 'guid');
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, value.allow);
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, value.deny);
    IonFormatterStorage.get<guid>('guid').write(writer, value.creatorId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.id);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("Archetype", {
  read(reader: CborReader): Archetype {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<guid>('guid').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.get<string>('string').read(reader);
    const isMentionable = IonFormatterStorage.get<bool>('bool').read(reader);
    const colour = IonFormatterStorage.get<i4>('i4').read(reader);
    const isHidden = IonFormatterStorage.get<bool>('bool').read(reader);
    const isLocked = IonFormatterStorage.get<bool>('bool').read(reader);
    const isGroup = IonFormatterStorage.get<bool>('bool').read(reader);
    const isDefault = IonFormatterStorage.get<bool>('bool').read(reader);
    const iconFileId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const entitlement = IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').read(reader);
    reader.readEndArrayAndSkip(arraySize - 12);
    return { id, spaceId, name, description, isMentionable, colour, isHidden, isLocked, isGroup, isDefault, iconFileId, entitlement };
  },
  write(writer: CborWriter, value: Archetype): void {
    writer.writeStartArray(12);
    IonFormatterStorage.get<guid>('guid').write(writer, value.id);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<string>('string').write(writer, value.description);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isMentionable);
    IonFormatterStorage.get<i4>('i4').write(writer, value.colour);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isHidden);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isLocked);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isGroup);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isDefault);
    IonFormatterStorage.writeNullable<string>(writer, value.iconFileId, 'string');
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, value.entitlement);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelType", {
  read(reader: CborReader): ChannelType {
    const num = (IonFormatterStorage.get<u2>('u2').read(reader))
    return ChannelType[num] !== undefined ? num as ChannelType : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: ChannelType): void {
    const casted: u2 = value;
    IonFormatterStorage.get<u2>('u2').write(writer, casted);
  }
});

IonFormatterStorage.register("CreateChannelRequest", {
  read(reader: CborReader): CreateChannelRequest {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const kind = IonFormatterStorage.get<ChannelType>('ChannelType').read(reader);
    const desc = IonFormatterStorage.get<string>('string').read(reader);
    const groupId = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    reader.readEndArrayAndSkip(arraySize - 5);
    return { spaceId, name, kind, desc, groupId };
  },
  write(writer: CborWriter, value: CreateChannelRequest): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<ChannelType>('ChannelType').write(writer, value.kind);
    IonFormatterStorage.get<string>('string').write(writer, value.desc);
    IonFormatterStorage.writeNullable<guid>(writer, value.groupId, 'guid');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonChannel", {
  read(reader: CborReader): ArgonChannel {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<ChannelType>('ChannelType').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.readNullable<string>(reader, 'string');
    const groupId = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    const fractionalIndex = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 7);
    return { type, spaceId, channelId, name, description, groupId, fractionalIndex };
  },
  write(writer: CborWriter, value: ArgonChannel): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<ChannelType>('ChannelType').write(writer, value.type);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.writeNullable<string>(writer, value.description, 'string');
    IonFormatterStorage.writeNullable<guid>(writer, value.groupId, 'guid');
    IonFormatterStorage.writeNullable<string>(writer, value.fractionalIndex, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("RealtimeChannel", {
  read(reader: CborReader): RealtimeChannel {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const channel = IonFormatterStorage.get<ArgonChannel>('ArgonChannel').read(reader);
    const users = IonFormatterStorage.readArray<RealtimeChannelUser>(reader, 'RealtimeChannelUser');
    const meetInfo = IonFormatterStorage.readNullable<LinkedMeetingInfo>(reader, 'LinkedMeetingInfo');
    reader.readEndArrayAndSkip(arraySize - 3);
    return { channel, users, meetInfo };
  },
  write(writer: CborWriter, value: RealtimeChannel): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<ArgonChannel>('ArgonChannel').write(writer, value.channel);
    IonFormatterStorage.writeArray<RealtimeChannelUser>(writer, value.users, 'RealtimeChannelUser');
    IonFormatterStorage.writeNullable<LinkedMeetingInfo>(writer, value.meetInfo, 'LinkedMeetingInfo');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("LinkedMeetingInfo", {
  read(reader: CborReader): LinkedMeetingInfo {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const meetingId = IonFormatterStorage.get<guid>('guid').read(reader);
    const meetingUrl = IonFormatterStorage.get<string>('string').read(reader);
    const meetingCode = IonFormatterStorage.get<string>('string').read(reader);
    const startDate = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return { meetingId, meetingUrl, meetingCode, startDate };
  },
  write(writer: CborWriter, value: LinkedMeetingInfo): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.meetingId);
    IonFormatterStorage.get<string>('string').write(writer, value.meetingUrl);
    IonFormatterStorage.get<string>('string').write(writer, value.meetingCode);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.startDate);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonMessage", {
  read(reader: CborReader): ArgonMessage {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const messageId = IonFormatterStorage.get<i8>('i8').read(reader);
    const replyId = IonFormatterStorage.readNullable<i8>(reader, 'i8');
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const text = IonFormatterStorage.get<string>('string').read(reader);
    const entities = IonFormatterStorage.readArray<IMessageEntity>(reader, 'IMessageEntity');
    const timeSent = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const sender = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 8);
    return { messageId, replyId, channelId, spaceId, text, entities, timeSent, sender };
  },
  write(writer: CborWriter, value: ArgonMessage): void {
    writer.writeStartArray(8);
    IonFormatterStorage.get<i8>('i8').write(writer, value.messageId);
    IonFormatterStorage.writeNullable<i8>(writer, value.replyId, 'i8');
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.text);
    IonFormatterStorage.writeArray<IMessageEntity>(writer, value.entities, 'IMessageEntity');
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.timeSent);
    IonFormatterStorage.get<guid>('guid').write(writer, value.sender);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelMemberState", {
  read(reader: CborReader): ChannelMemberState {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return num as any;
  },
  write(writer: CborWriter, value: ChannelMemberState): void {
    const casted: u4 = value as any;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RealtimeChannelUser", {
  read(reader: CborReader): RealtimeChannelUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const state = IonFormatterStorage.get<ChannelMemberState>('ChannelMemberState').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { userId, state };
  },
  write(writer: CborWriter, value: RealtimeChannelUser): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<ChannelMemberState>('ChannelMemberState').write(writer, value.state);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("NotificationCounterKv", {
  read(reader: CborReader): NotificationCounterKv {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const counterType = IonFormatterStorage.get<string>('string').read(reader);
    const count = IonFormatterStorage.get<i8>('i8').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { counterType, count };
  },
  write(writer: CborWriter, value: NotificationCounterKv): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.counterType);
    IonFormatterStorage.get<i8>('i8').write(writer, value.count);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ActivityPresenceKind", {
  read(reader: CborReader): ActivityPresenceKind {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return ActivityPresenceKind[num] !== undefined ? num as ActivityPresenceKind : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: ActivityPresenceKind): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("UserActivityPresence", {
  read(reader: CborReader): UserActivityPresence {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const kind = IonFormatterStorage.get<ActivityPresenceKind>('ActivityPresenceKind').read(reader);
    const startTimestampSeconds = IonFormatterStorage.get<u8>('u8').read(reader);
    const titleName = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { kind, startTimestampSeconds, titleName };
  },
  write(writer: CborWriter, value: UserActivityPresence): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<ActivityPresenceKind>('ActivityPresenceKind').write(writer, value.kind);
    IonFormatterStorage.get<u8>('u8').write(writer, value.startTimestampSeconds);
    IonFormatterStorage.get<string>('string').write(writer, value.titleName);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelGroup", {
  read(reader: CborReader): ChannelGroup {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const groupId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const desc = IonFormatterStorage.readNullable<string>(reader, 'string');
    const isCollapsed = IonFormatterStorage.get<bool>('bool').read(reader);
    const fractionalIndex = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 6);
    return { spaceId, groupId, name, desc, isCollapsed, fractionalIndex };
  },
  write(writer: CborWriter, value: ChannelGroup): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.groupId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.writeNullable<string>(writer, value.desc, 'string');
    IonFormatterStorage.get<bool>('bool').write(writer, value.isCollapsed);
    IonFormatterStorage.writeNullable<string>(writer, value.fractionalIndex, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("JoinToChannelError", {
  read(reader: CborReader): JoinToChannelError {
    const num = (IonFormatterStorage.get<u2>('u2').read(reader))
    return JoinToChannelError[num] !== undefined ? num as JoinToChannelError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: JoinToChannelError): void {
    const casted: u2 = value;
    IonFormatterStorage.get<u2>('u2').write(writer, casted);
  }
});

IonFormatterStorage.register("EntityType", {
  read(reader: CborReader): EntityType {
    const num = (IonFormatterStorage.get<u2>('u2').read(reader))
    return EntityType[num] !== undefined ? num as EntityType : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: EntityType): void {
    const casted: u2 = value;
    IonFormatterStorage.get<u2>('u2').write(writer, casted);
  }
});

IonFormatterStorage.register("StartStreamError", {
  read(reader: CborReader): StartStreamError {
    const num = (IonFormatterStorage.get<u2>('u2').read(reader))
    return StartStreamError[num] !== undefined ? num as StartStreamError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: StartStreamError): void {
    const casted: u2 = value;
    IonFormatterStorage.get<u2>('u2').write(writer, casted);
  }
});

IonFormatterStorage.register("FeatureFlagData", {
  read(reader: CborReader): FeatureFlagData {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const flagId = IonFormatterStorage.get<string>('string').read(reader);
    const isEnabled = IonFormatterStorage.get<bool>('bool').read(reader);
    const variant = IonFormatterStorage.readNullable<string>(reader, 'string');
    const scope = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return { flagId, isEnabled, variant, scope };
  },
  write(writer: CborWriter, value: FeatureFlagData): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<string>('string').write(writer, value.flagId);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isEnabled);
    IonFormatterStorage.writeNullable<string>(writer, value.variant, 'string');
    IonFormatterStorage.get<i4>('i4').write(writer, value.scope);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserBlock", {
  read(reader: CborReader): UserBlock {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const blockedId = IonFormatterStorage.get<guid>('guid').read(reader);
    const blockedAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { userId, blockedId, blockedAt };
  },
  write(writer: CborWriter, value: UserBlock): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.blockedId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.blockedAt);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FriendRequest", {
  read(reader: CborReader): FriendRequest {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const requesterId = IonFormatterStorage.get<guid>('guid').read(reader);
    const targetId = IonFormatterStorage.get<guid>('guid').read(reader);
    const requestedAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { requesterId, targetId, requestedAt };
  },
  write(writer: CborWriter, value: FriendRequest): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.requesterId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.targetId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.requestedAt);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("Friendship", {
  read(reader: CborReader): Friendship {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const friendId = IonFormatterStorage.get<guid>('guid').read(reader);
    const friendAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { userId, friendId, friendAt };
  },
  write(writer: CborWriter, value: Friendship): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.friendId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.friendAt);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserChat", {
  read(reader: CborReader): UserChat {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const peerId = IonFormatterStorage.get<guid>('guid').read(reader);
    const isPinned = IonFormatterStorage.get<bool>('bool').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const lastMsg = IonFormatterStorage.readNullable<string>(reader, 'string');
    const lastMessageAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const pinnedAt = IonFormatterStorage.readNullable<datetime>(reader, 'datetime');
    const unreadCount = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 7);
    return { peerId, isPinned, userId, lastMsg, lastMessageAt, pinnedAt, unreadCount };
  },
  write(writer: CborWriter, value: UserChat): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<guid>('guid').write(writer, value.peerId);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isPinned);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.writeNullable<string>(writer, value.lastMsg, 'string');
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.lastMessageAt);
    IonFormatterStorage.writeNullable<datetime>(writer, value.pinnedAt, 'datetime');
    IonFormatterStorage.get<i4>('i4').write(writer, value.unreadCount);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("DirectMessage", {
  read(reader: CborReader): DirectMessage {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const messageId = IonFormatterStorage.get<i8>('i8').read(reader);
    const senderId = IonFormatterStorage.get<guid>('guid').read(reader);
    const receiverId = IonFormatterStorage.get<guid>('guid').read(reader);
    const text = IonFormatterStorage.get<string>('string').read(reader);
    const entities = IonFormatterStorage.readArray<IMessageEntity>(reader, 'IMessageEntity');
    const createdAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const replyTo = IonFormatterStorage.readNullable<i8>(reader, 'i8');
    reader.readEndArrayAndSkip(arraySize - 7);
    return { messageId, senderId, receiverId, text, entities, createdAt, replyTo };
  },
  write(writer: CborWriter, value: DirectMessage): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<i8>('i8').write(writer, value.messageId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.senderId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.receiverId);
    IonFormatterStorage.get<string>('string').write(writer, value.text);
    IonFormatterStorage.writeArray<IMessageEntity>(writer, value.entities, 'IMessageEntity');
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.createdAt);
    IonFormatterStorage.writeNullable<i8>(writer, value.replyTo, 'i8');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SendFriendStatus", {
  read(reader: CborReader): SendFriendStatus {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return SendFriendStatus[num] !== undefined ? num as SendFriendStatus : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: SendFriendStatus): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("BadAuthKind", {
  read(reader: CborReader): BadAuthKind {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return BadAuthKind[num] !== undefined ? num as BadAuthKind : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: BadAuthKind): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("InventoryItem", {
  read(reader: CborReader): InventoryItem {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<string>('string').read(reader);
    const instanceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const grantedDate = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const usable = IonFormatterStorage.get<bool>('bool').read(reader);
    const giftable = IonFormatterStorage.get<bool>('bool').read(reader);
    const usableVector = IonFormatterStorage.readNullable<ItemUseVector>(reader, 'ItemUseVector');
    const receivedFrom = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    const ttl = IonFormatterStorage.readNullable<duration>(reader, 'duration');
    reader.readEndArrayAndSkip(arraySize - 8);
    return { id, instanceId, grantedDate, usable, giftable, usableVector, receivedFrom, ttl };
  },
  write(writer: CborWriter, value: InventoryItem): void {
    writer.writeStartArray(8);
    IonFormatterStorage.get<string>('string').write(writer, value.id);
    IonFormatterStorage.get<guid>('guid').write(writer, value.instanceId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.grantedDate);
    IonFormatterStorage.get<bool>('bool').write(writer, value.usable);
    IonFormatterStorage.get<bool>('bool').write(writer, value.giftable);
    IonFormatterStorage.writeNullable<ItemUseVector>(writer, value.usableVector, 'ItemUseVector');
    IonFormatterStorage.writeNullable<guid>(writer, value.receivedFrom, 'guid');
    IonFormatterStorage.writeNullable<duration>(writer, value.ttl, 'duration');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("DetailedInventoryItem", {
  read(reader: CborReader): DetailedInventoryItem {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const item = IonFormatterStorage.get<InventoryItem>('InventoryItem').read(reader);
    const containedItems = IonFormatterStorage.readArray<InventoryItem>(reader, 'InventoryItem');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { item, containedItems };
  },
  write(writer: CborWriter, value: DetailedInventoryItem): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<InventoryItem>('InventoryItem').write(writer, value.item);
    IonFormatterStorage.writeArray<InventoryItem>(writer, value.containedItems, 'InventoryItem');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("InventoryNotification", {
  read(reader: CborReader): InventoryNotification {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const inventoryItemId = IonFormatterStorage.get<guid>('guid').read(reader);
    const id = IonFormatterStorage.get<string>('string').read(reader);
    const createdAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { inventoryItemId, id, createdAt };
  },
  write(writer: CborWriter, value: InventoryNotification): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.inventoryItemId);
    IonFormatterStorage.get<string>('string').write(writer, value.id);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.createdAt);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ItemUseVector", {
  read(reader: CborReader): ItemUseVector {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return ItemUseVector[num] !== undefined ? num as ItemUseVector : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: ItemUseVector): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RedeemError", {
  read(reader: CborReader): RedeemError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return RedeemError[num] !== undefined ? num as RedeemError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: RedeemError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("AutoDeletePeriod", {
  read(reader: CborReader): AutoDeletePeriod {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const months = IonFormatterStorage.readNullable<i4>(reader, 'i4');
    const enabled = IonFormatterStorage.get<bool>('bool').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { months, enabled };
  },
  write(writer: CborWriter, value: AutoDeletePeriod): void {
    writer.writeStartArray(2);
    IonFormatterStorage.writeNullable<i4>(writer, value.months, 'i4');
    IonFormatterStorage.get<bool>('bool').write(writer, value.enabled);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SecurityDetails", {
  read(reader: CborReader): SecurityDetails {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const otpEnabled = IonFormatterStorage.get<bool>('bool').read(reader);
    const passkeys = IonFormatterStorage.readArray<Passkey>(reader, 'Passkey');
    const email = IonFormatterStorage.readNullable<string>(reader, 'string');
    const phone = IonFormatterStorage.readNullable<string>(reader, 'string');
    const autoDeletePeriod = IonFormatterStorage.get<AutoDeletePeriod>('AutoDeletePeriod').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return { otpEnabled, passkeys, email, phone, autoDeletePeriod };
  },
  write(writer: CborWriter, value: SecurityDetails): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<bool>('bool').write(writer, value.otpEnabled);
    IonFormatterStorage.writeArray<Passkey>(writer, value.passkeys, 'Passkey');
    IonFormatterStorage.writeNullable<string>(writer, value.email, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.phone, 'string');
    IonFormatterStorage.get<AutoDeletePeriod>('AutoDeletePeriod').write(writer, value.autoDeletePeriod);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("Passkey", {
  read(reader: CborReader): Passkey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const createdAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const lastUsedAt = IonFormatterStorage.readNullable<datetime>(reader, 'datetime');
    reader.readEndArrayAndSkip(arraySize - 4);
    return { id, name, createdAt, lastUsedAt };
  },
  write(writer: CborWriter, value: Passkey): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.id);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.createdAt);
    IonFormatterStorage.writeNullable<datetime>(writer, value.lastUsedAt, 'datetime');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("PasskeyCredentialDescriptor", {
  read(reader: CborReader): PasskeyCredentialDescriptor {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<string>('string').read(reader);
    const type = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { id, type };
  },
  write(writer: CborWriter, value: PasskeyCredentialDescriptor): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.id);
    IonFormatterStorage.get<string>('string').write(writer, value.type);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("EmailChangeError", {
  read(reader: CborReader): EmailChangeError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return EmailChangeError[num] !== undefined ? num as EmailChangeError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: EmailChangeError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("PhoneChangeError", {
  read(reader: CborReader): PhoneChangeError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return PhoneChangeError[num] !== undefined ? num as PhoneChangeError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: PhoneChangeError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("PasswordChangeError", {
  read(reader: CborReader): PasswordChangeError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return PasswordChangeError[num] !== undefined ? num as PasswordChangeError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: PasswordChangeError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("OTPError", {
  read(reader: CborReader): OTPError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return OTPError[num] !== undefined ? num as OTPError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: OTPError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("PasskeyError", {
  read(reader: CborReader): PasskeyError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return PasskeyError[num] !== undefined ? num as PasskeyError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: PasskeyError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("AutoDeleteError", {
  read(reader: CborReader): AutoDeleteError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return AutoDeleteError[num] !== undefined ? num as AutoDeleteError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: AutoDeleteError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("ArgonSpaceBase", {
  read(reader: CborReader): ArgonSpaceBase {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.get<string>('string').read(reader);
    const avatarFieldId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const topBannerFileId = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 5);
    return { spaceId, name, description, avatarFieldId, topBannerFileId };
  },
  write(writer: CborWriter, value: ArgonSpaceBase): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<string>('string').write(writer, value.description);
    IonFormatterStorage.writeNullable<string>(writer, value.avatarFieldId, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.topBannerFileId, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonSpace", {
  read(reader: CborReader): ArgonSpace {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.get<string>('string').read(reader);
    const avatarFieldId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const topBannerFileId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const channels = IonFormatterStorage.readArray<ArgonChannel>(reader, 'ArgonChannel');
    const members = IonFormatterStorage.readArray<SpaceMember>(reader, 'SpaceMember');
    const archetypes = IonFormatterStorage.readArray<Archetype>(reader, 'Archetype');
    reader.readEndArrayAndSkip(arraySize - 8);
    return { spaceId, name, description, avatarFieldId, topBannerFileId, channels, members, archetypes };
  },
  write(writer: CborWriter, value: ArgonSpace): void {
    writer.writeStartArray(8);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<string>('string').write(writer, value.description);
    IonFormatterStorage.writeNullable<string>(writer, value.avatarFieldId, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.topBannerFileId, 'string');
    IonFormatterStorage.writeArray<ArgonChannel>(writer, value.channels, 'ArgonChannel');
    IonFormatterStorage.writeArray<SpaceMember>(writer, value.members, 'SpaceMember');
    IonFormatterStorage.writeArray<Archetype>(writer, value.archetypes, 'Archetype');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArchetypeGroup", {
  read(reader: CborReader): ArchetypeGroup {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const archetype = IonFormatterStorage.get<Archetype>('Archetype').read(reader);
    const members = IonFormatterStorage.readArray<guid>(reader, 'guid');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { archetype, members };
  },
  write(writer: CborWriter, value: ArchetypeGroup): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, value.archetype);
    IonFormatterStorage.writeArray<guid>(writer, value.members, 'guid');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SpaceMemberArchetype", {
  read(reader: CborReader): SpaceMemberArchetype {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const serverMemberId = IonFormatterStorage.get<guid>('guid').read(reader);
    const archetypeId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { serverMemberId, archetypeId };
  },
  write(writer: CborWriter, value: SpaceMemberArchetype): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.serverMemberId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.archetypeId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonUser", {
  read(reader: CborReader): ArgonUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const username = IonFormatterStorage.get<string>('string').read(reader);
    const displayName = IonFormatterStorage.get<string>('string').read(reader);
    const avatarFileId = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 4);
    return { userId, username, displayName, avatarFileId };
  },
  write(writer: CborWriter, value: ArgonUser): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<string>('string').write(writer, value.username);
    IonFormatterStorage.get<string>('string').write(writer, value.displayName);
    IonFormatterStorage.writeNullable<string>(writer, value.avatarFileId, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SpaceMember", {
  read(reader: CborReader): SpaceMember {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const joinedAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const memberId = IonFormatterStorage.get<guid>('guid').read(reader);
    const user = IonFormatterStorage.get<ArgonUser>('ArgonUser').read(reader);
    const archetypes = IonFormatterStorage.readArray<SpaceMemberArchetype>(reader, 'SpaceMemberArchetype');
    reader.readEndArrayAndSkip(arraySize - 6);
    return { userId, spaceId, joinedAt, memberId, user, archetypes };
  },
  write(writer: CborWriter, value: SpaceMember): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.joinedAt);
    IonFormatterStorage.get<guid>('guid').write(writer, value.memberId);
    IonFormatterStorage.get<ArgonUser>('ArgonUser').write(writer, value.user);
    IonFormatterStorage.writeArray<SpaceMemberArchetype>(writer, value.archetypes, 'SpaceMemberArchetype');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserStatus", {
  read(reader: CborReader): UserStatus {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return UserStatus[num] !== undefined ? num as UserStatus : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: UserStatus): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RealtimeServerMember", {
  read(reader: CborReader): RealtimeServerMember {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const member = IonFormatterStorage.get<SpaceMember>('SpaceMember').read(reader);
    const status = IonFormatterStorage.get<UserStatus>('UserStatus').read(reader);
    const presence = IonFormatterStorage.readNullable<UserActivityPresence>(reader, 'UserActivityPresence');
    reader.readEndArrayAndSkip(arraySize - 3);
    return { member, status, presence };
  },
  write(writer: CborWriter, value: RealtimeServerMember): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<SpaceMember>('SpaceMember').write(writer, value.member);
    IonFormatterStorage.get<UserStatus>('UserStatus').write(writer, value.status);
    IonFormatterStorage.writeNullable<UserActivityPresence>(writer, value.presence, 'UserActivityPresence');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("InviteCode", {
  read(reader: CborReader): InviteCode {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const inviteCode = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return { inviteCode };
  },
  write(writer: CborWriter, value: InviteCode): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.inviteCode);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("InviteCodeEntity", {
  read(reader: CborReader): InviteCodeEntity {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const code = IonFormatterStorage.get<InviteCode>('InviteCode').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const issuerId = IonFormatterStorage.get<guid>('guid').read(reader);
    const expireTime = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const used = IonFormatterStorage.get<u8>('u8').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return { code, spaceId, issuerId, expireTime, used };
  },
  write(writer: CborWriter, value: InviteCodeEntity): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<InviteCode>('InviteCode').write(writer, value.code);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.issuerId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.expireTime);
    IonFormatterStorage.get<u8>('u8').write(writer, value.used);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonUserProfile", {
  read(reader: CborReader): ArgonUserProfile {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const customStatus = IonFormatterStorage.readNullable<string>(reader, 'string');
    const customStatusIconId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const bannerFileID = IonFormatterStorage.readNullable<string>(reader, 'string');
    const dateOfBirth = IonFormatterStorage.readNullable<dateonly>(reader, 'dateonly');
    const bio = IonFormatterStorage.readNullable<string>(reader, 'string');
    const isPremium = IonFormatterStorage.get<bool>('bool').read(reader);
    const badges = IonFormatterStorage.readArray<string>(reader, 'string');
    const archetypes = IonFormatterStorage.readArray<SpaceMemberArchetype>(reader, 'SpaceMemberArchetype');
    reader.readEndArrayAndSkip(arraySize - 9);
    return { userId, customStatus, customStatusIconId, bannerFileID, dateOfBirth, bio, isPremium, badges, archetypes };
  },
  write(writer: CborWriter, value: ArgonUserProfile): void {
    writer.writeStartArray(9);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.writeNullable<string>(writer, value.customStatus, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.customStatusIconId, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.bannerFileID, 'string');
    IonFormatterStorage.writeNullable<dateonly>(writer, value.dateOfBirth, 'dateonly');
    IonFormatterStorage.writeNullable<string>(writer, value.bio, 'string');
    IonFormatterStorage.get<bool>('bool').write(writer, value.isPremium);
    IonFormatterStorage.writeArray<string>(writer, value.badges, 'string');
    IonFormatterStorage.writeArray<SpaceMemberArchetype>(writer, value.archetypes, 'SpaceMemberArchetype');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonIonTicket", {
  read(reader: CborReader): ArgonIonTicket {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const ip = IonFormatterStorage.get<string>('string').read(reader);
    const ray = IonFormatterStorage.get<string>('string').read(reader);
    const clientName = IonFormatterStorage.get<string>('string').read(reader);
    const hostName = IonFormatterStorage.get<string>('string').read(reader);
    const appId = IonFormatterStorage.get<string>('string').read(reader);
    const sessionId = IonFormatterStorage.get<guid>('guid').read(reader);
    const machineId = IonFormatterStorage.get<string>('string').read(reader);
    const region = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 9);
    return { userId, ip, ray, clientName, hostName, appId, sessionId, machineId, region };
  },
  write(writer: CborWriter, value: ArgonIonTicket): void {
    writer.writeStartArray(9);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<string>('string').write(writer, value.ip);
    IonFormatterStorage.get<string>('string').write(writer, value.ray);
    IonFormatterStorage.get<string>('string').write(writer, value.clientName);
    IonFormatterStorage.get<string>('string').write(writer, value.hostName);
    IonFormatterStorage.get<string>('string').write(writer, value.appId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.sessionId);
    IonFormatterStorage.get<string>('string').write(writer, value.machineId);
    IonFormatterStorage.get<string>('string').write(writer, value.region);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("TodayStats", {
  read(reader: CborReader): TodayStats {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const timeInVoice = IonFormatterStorage.get<i4>('i4').read(reader);
    const callsMade = IonFormatterStorage.get<i4>('i4').read(reader);
    const messagesSent = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { timeInVoice, callsMade, messagesSent };
  },
  write(writer: CborWriter, value: TodayStats): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<i4>('i4').write(writer, value.timeInVoice);
    IonFormatterStorage.get<i4>('i4').write(writer, value.callsMade);
    IonFormatterStorage.get<i4>('i4').write(writer, value.messagesSent);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MyLevelDetails", {
  read(reader: CborReader): MyLevelDetails {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const totalXp = IonFormatterStorage.get<i4>('i4').read(reader);
    const currentLevel = IonFormatterStorage.get<i4>('i4').read(reader);
    const xpForNextLevel = IonFormatterStorage.get<i4>('i4').read(reader);
    const xpForCurrentLevel = IonFormatterStorage.get<i4>('i4').read(reader);
    const readyToClaimCoin = IonFormatterStorage.get<bool>('bool').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return { totalXp, currentLevel, xpForNextLevel, xpForCurrentLevel, readyToClaimCoin };
  },
  write(writer: CborWriter, value: MyLevelDetails): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<i4>('i4').write(writer, value.totalXp);
    IonFormatterStorage.get<i4>('i4').write(writer, value.currentLevel);
    IonFormatterStorage.get<i4>('i4').write(writer, value.xpForNextLevel);
    IonFormatterStorage.get<i4>('i4').write(writer, value.xpForCurrentLevel);
    IonFormatterStorage.get<bool>('bool').write(writer, value.readyToClaimCoin);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserEditInput", {
  read(reader: CborReader): UserEditInput {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const displayName = IonFormatterStorage.readNullable<string>(reader, 'string');
    const avatarId = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { displayName, avatarId };
  },
  write(writer: CborWriter, value: UserEditInput): void {
    writer.writeStartArray(2);
    IonFormatterStorage.writeNullable<string>(writer, value.displayName, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.avatarId, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FeatureFlag", {
  read(reader: CborReader): FeatureFlag {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const key = IonFormatterStorage.get<string>('string').read(reader);
    const enabled = IonFormatterStorage.get<bool>('bool').read(reader);
    const variant = IonFormatterStorage.readNullable<string>(reader, 'string');
    const parameters = IonFormatterStorage.readArray<FeatureFlagParameter>(reader, 'FeatureFlagParameter');
    reader.readEndArrayAndSkip(arraySize - 4);
    return { key, enabled, variant, parameters };
  },
  write(writer: CborWriter, value: FeatureFlag): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<string>('string').write(writer, value.key);
    IonFormatterStorage.get<bool>('bool').write(writer, value.enabled);
    IonFormatterStorage.writeNullable<string>(writer, value.variant, 'string');
    IonFormatterStorage.writeArray<FeatureFlagParameter>(writer, value.parameters, 'FeatureFlagParameter');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FeatureFlagParameter", {
  read(reader: CborReader): FeatureFlagParameter {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const key = IonFormatterStorage.get<string>('string').read(reader);
    const value = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { key, value };
  },
  write(writer: CborWriter, value: FeatureFlagParameter): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.key);
    IonFormatterStorage.get<string>('string').write(writer, value.value);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("CreateServerRequest", {
  read(reader: CborReader): CreateServerRequest {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.get<string>('string').read(reader);
    const avatarFieldId = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { name, description, avatarFieldId };
  },
  write(writer: CborWriter, value: CreateServerRequest): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<string>('string').write(writer, value.description);
    IonFormatterStorage.get<string>('string').write(writer, value.avatarFieldId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserCredentialsInput", {
  read(reader: CborReader): UserCredentialsInput {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const email = IonFormatterStorage.readNullable<string>(reader, 'string');
    const phone = IonFormatterStorage.readNullable<string>(reader, 'string');
    const username = IonFormatterStorage.readNullable<string>(reader, 'string');
    const password = IonFormatterStorage.readNullable<string>(reader, 'string');
    const otpCode = IonFormatterStorage.readNullable<string>(reader, 'string');
    const captchaToken = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 6);
    return { email, phone, username, password, otpCode, captchaToken };
  },
  write(writer: CborWriter, value: UserCredentialsInput): void {
    writer.writeStartArray(6);
    IonFormatterStorage.writeNullable<string>(writer, value.email, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.phone, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.username, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.password, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.otpCode, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.captchaToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserLoginInput", {
  read(reader: CborReader): UserLoginInput {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const email = IonFormatterStorage.readNullable<string>(reader, 'string');
    const phone = IonFormatterStorage.readNullable<string>(reader, 'string');
    const username = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 3);
    return { email, phone, username };
  },
  write(writer: CborWriter, value: UserLoginInput): void {
    writer.writeStartArray(3);
    IonFormatterStorage.writeNullable<string>(writer, value.email, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.phone, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.username, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("NewUserCredentialsInput", {
  read(reader: CborReader): NewUserCredentialsInput {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const email = IonFormatterStorage.get<string>('string').read(reader);
    const username = IonFormatterStorage.get<string>('string').read(reader);
    const password = IonFormatterStorage.get<string>('string').read(reader);
    const displayName = IonFormatterStorage.get<string>('string').read(reader);
    const argreeTos = IonFormatterStorage.get<bool>('bool').read(reader);
    const birthDate = IonFormatterStorage.get<dateonly>('dateonly').read(reader);
    const argreeOptionalEmails = IonFormatterStorage.get<bool>('bool').read(reader);
    const captchaToken = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 8);
    return { email, username, password, displayName, argreeTos, birthDate, argreeOptionalEmails, captchaToken };
  },
  write(writer: CborWriter, value: NewUserCredentialsInput): void {
    writer.writeStartArray(8);
    IonFormatterStorage.get<string>('string').write(writer, value.email);
    IonFormatterStorage.get<string>('string').write(writer, value.username);
    IonFormatterStorage.get<string>('string').write(writer, value.password);
    IonFormatterStorage.get<string>('string').write(writer, value.displayName);
    IonFormatterStorage.get<bool>('bool').write(writer, value.argreeTos);
    IonFormatterStorage.get<dateonly>('dateonly').write(writer, value.birthDate);
    IonFormatterStorage.get<bool>('bool').write(writer, value.argreeOptionalEmails);
    IonFormatterStorage.writeNullable<string>(writer, value.captchaToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UploadFileError", {
  read(reader: CborReader): UploadFileError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return UploadFileError[num] !== undefined ? num as UploadFileError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: UploadFileError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("CreateSpaceError", {
  read(reader: CborReader): CreateSpaceError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return CreateSpaceError[num] !== undefined ? num as CreateSpaceError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: CreateSpaceError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("AcceptInviteError", {
  read(reader: CborReader): AcceptInviteError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return AcceptInviteError[num] !== undefined ? num as AcceptInviteError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: AcceptInviteError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("AuthorizationError", {
  read(reader: CborReader): AuthorizationError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return AuthorizationError[num] !== undefined ? num as AuthorizationError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: AuthorizationError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RegistrationError", {
  read(reader: CborReader): RegistrationError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return RegistrationError[num] !== undefined ? num as RegistrationError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: RegistrationError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("LockdownReason", {
  read(reader: CborReader): LockdownReason {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return LockdownReason[num] !== undefined ? num as LockdownReason : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: LockdownReason): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("LockdownSeverity", {
  read(reader: CborReader): LockdownSeverity {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return LockdownSeverity[num] !== undefined ? num as LockdownSeverity : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: LockdownSeverity): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RtcEndpoint", {
  read(reader: CborReader): RtcEndpoint {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const endpoint = IonFormatterStorage.get<string>('string').read(reader);
    const ices = IonFormatterStorage.readArray<IceEndpoint>(reader, 'IceEndpoint');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { endpoint, ices };
  },
  write(writer: CborWriter, value: RtcEndpoint): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.endpoint);
    IonFormatterStorage.writeArray<IceEndpoint>(writer, value.ices, 'IceEndpoint');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("IceEndpoint", {
  read(reader: CborReader): IceEndpoint {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const endpoint = IonFormatterStorage.get<string>('string').read(reader);
    const username = IonFormatterStorage.get<string>('string').read(reader);
    const password = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { endpoint, username, password };
  },
  write(writer: CborWriter, value: IceEndpoint): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.endpoint);
    IonFormatterStorage.get<string>('string').write(writer, value.username);
    IonFormatterStorage.get<string>('string').write(writer, value.password);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ServiceUssdResult", {
  read(reader: CborReader): ServiceUssdResult {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const success = IonFormatterStorage.get<bool>('bool').read(reader);
    const message = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { success, message };
  },
  write(writer: CborWriter, value: ServiceUssdResult): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<bool>('bool').write(writer, value.success);
    IonFormatterStorage.get<string>('string').write(writer, value.message);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("CallFailedError", {
  read(reader: CborReader): CallFailedError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return CallFailedError[num] !== undefined ? num as CallFailedError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: CallFailedError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("DialCheckFailReason", {
  read(reader: CborReader): DialCheckFailReason {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return DialCheckFailReason[num] !== undefined ? num as DialCheckFailReason : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: DialCheckFailReason): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});



export interface IArchetypeInteraction extends IIonService
{
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  CreateArchetype(spaceId: guid, name: string): Promise<Archetype>;
  UpdateArchetype(spaceId: guid, data: Archetype): Promise<Archetype>;
  SetArchetypeToMember(spaceId: guid, memberId: guid, archetypeId: guid, isGrant: bool): Promise<bool>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  UpsertArchetypeEntitlementForChannel(spaceId: guid, channelId: guid, archetypeId: guid, deny: ArgonEntitlement, allow: ArgonEntitlement): Promise<ChannelEntitlementOverwrite | null>;
}




export interface IChannelInteraction extends IIonService
{
  CreateChannel(spaceId: guid, channelId: guid, request: CreateChannelRequest): Promise<void>;
  MoveChannel(spaceId: guid, channelId: guid, targetGroupId: guid | null, afterChannelId: guid | null, beforeChannelId: guid | null): Promise<void>;
  DeleteChannelGroup(spaceId: guid, channelId: guid, groupId: guid, deleteChannels: bool): Promise<void>;
  CreateChannelGroup(spaceId: guid, channelId: guid, name: string, desk: string | null): Promise<void>;
  MoveChannelGroup(spaceId: guid, channelId: guid, afterGroupId: guid | null, beforeGroupId: guid | null): Promise<void>;
  DeleteChannel(spaceId: guid, channelId: guid): Promise<void>;
  GetChannels(spaceId: guid, channelId: guid): Promise<IonArray<RealtimeChannel>>;
  UpdateChannelGroup(spaceId: guid, channelId: guid, groupId: guid, name: string | null, description: string | null): Promise<void>;
  QueryMessages(spaceId: guid, channelId: guid, from: i8 | null, limit: i4): Promise<IonArray<ArgonMessage>>;
  SendMessage(spaceId: guid, channelId: guid, text: string, entities: IonArray<IMessageEntity>, randomId: i8, replyTo: i8 | null): Promise<i8>;
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<void>;
  Interlink(spaceId: guid, channelId: guid): Promise<IInterlinkResult>;
  InterlinkStream(spaceId: guid, channelId: guid, density: i4): Promise<IInterlinkStreamResult>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<bool>;
  BeginRecord(spaceId: guid, channelId: guid): Promise<bool>;
  StopRecord(spaceId: guid, channelId: guid): Promise<bool>;
  CreateLinkedMeeting(spaceId: guid, channelId: guid): Promise<LinkedMeetingInfo>;
  EndLinkedMeeting(spaceId: guid, channelId: guid): Promise<void>;
}


export interface IEventBus extends IIonService
{
  ForServer(spaceId: guid): AsyncIterable<IArgonEvent>;
  Dispatch(ev: IArgonClientEvent): Promise<void>;
  Pipe(ev: AsyncIterable<IArgonClientEvent>): AsyncIterable<IArgonEvent>;
  PickTicket(): Promise<string>;
}




export interface IFeatureFlagInteractions extends IIonService
{
  GetMyFeatureFlags(): Promise<IonArray<FeatureFlagData>>;
}




export interface IFriendsInteraction extends IIonService
{
  GetBlockList(limit: i4, offset: i4): Promise<IonArray<UserBlock>>;
  GetMyFriendPendingList(limit: i4, offset: i4): Promise<IonArray<FriendRequest>>;
  GetMyFriendOutgoingList(limit: i4, offset: i4): Promise<IonArray<FriendRequest>>;
  GetMyFriendships(limit: i4, offset: i4): Promise<IonArray<Friendship>>;
  SendFriendRequest(username: string): Promise<SendFriendStatus>;
  RemoveFriend(userId: guid): Promise<void>;
  AcceptFriendRequest(fromUserId: guid): Promise<void>;
  DeclineFriendRequest(fromUserId: guid): Promise<void>;
  CancelFriendRequest(toUserId: guid): Promise<void>;
  BlockUser(userId: guid): Promise<void>;
  UnblockUser(userId: guid): Promise<void>;
}


export interface IUserChatInteractions extends IIonService
{
  GetRecentChats(limit: i4, offset: i4): Promise<IonArray<UserChat>>;
  PinChat(peerId: guid): Promise<void>;
  UnpinChat(peerId: guid): Promise<void>;
  MarkChatRead(peerId: guid): Promise<void>;
  SendDirectMessage(receiverId: guid, text: string, entities: IonArray<IMessageEntity>, randomId: i8, replyTo: i8 | null): Promise<i8>;
  QueryDirectMessages(peerId: guid, from: i8 | null, limit: i4): Promise<IonArray<DirectMessage>>;
}




export interface IIdentityInteraction extends IIonService
{
  Authorize(data: UserCredentialsInput): Promise<IAuthorizeResult>;
  Registration(data: NewUserCredentialsInput): Promise<IRegistrationResult>;
  BeginResetPassword(email: string): Promise<bool>;
  ResetPassword(email: string, otpCode: string, newPassword: string): Promise<IAuthorizeResult>;
  GetAuthorizationScenario(): Promise<string>;
  GetAuthorizationScenarioFor(data: UserLoginInput): Promise<string>;
  GetMyAuthorization(token: string, refreshToken: string | null): Promise<IMyAuthStatus>;
}




export interface IInventoryInteraction extends IIonService
{
  GetMyInventoryItems(): Promise<IonArray<InventoryItem>>;
  MarkSeen(itemIds: IonArray<guid>): Promise<void>;
  GetNotifications(): Promise<IonArray<InventoryNotification>>;
  RedeemCode(code: string): Promise<IRedeemResult>;
  UseItem(itemId: guid): Promise<bool>;
}




export interface ISecurityInteraction extends IIonService
{
  RequestEmailChange(newEmail: string, password: string): Promise<IRequestEmailChangeResult>;
  ConfirmEmailChange(verificationCode: string): Promise<IConfirmEmailChangeResult>;
  RequestPhoneChange(newPhone: string, password: string): Promise<IRequestPhoneChangeResult>;
  ConfirmPhoneChange(verificationCode: string): Promise<IConfirmPhoneChangeResult>;
  RemovePhone(password: string): Promise<IRemovePhoneResult>;
  ChangePassword(currentPassword: string, newPassword: string): Promise<IChangePasswordResult>;
  EnableOTP(): Promise<IEnableOTPResult>;
  VerifyAndEnableOTP(code: string): Promise<IVerifyOTPResult>;
  DisableOTP(code: string): Promise<IDisableOTPResult>;
  GetPasskeys(): Promise<IonArray<Passkey>>;
  BeginAddPasskey(name: string): Promise<IBeginPasskeyResult>;
  CompleteAddPasskey(passkeyId: guid, publicKey: string): Promise<ICompletePasskeyResult>;
  RemovePasskey(passkeyId: guid): Promise<IRemovePasskeyResult>;
  SetAutoDeletePeriod(months: i4 | null): Promise<ISetAutoDeleteResult>;
  GetAutoDeletePeriod(): Promise<AutoDeletePeriod>;
  GetSecurityDetails(): Promise<SecurityDetails>;
  BeginValidatePasskey(): Promise<IBeginPasskeyValidateResult>;
  CompleteValidatePasskey(credentialId: string, signature: string, authenticatorData: string, clientDataJSON: string): Promise<ICompletePasskeyResult>;
}




export interface IServerInteraction extends IIonService
{
  GetMembers(spaceId: guid): Promise<IonArray<RealtimeServerMember>>;
  GetMember(spaceId: guid, userId: guid): Promise<RealtimeServerMember>;
  GetInviteCodes(spaceId: guid): Promise<IonArray<InviteCodeEntity>>;
  CreateInviteCode(spaceId: guid): Promise<InviteCode>;
  PrefetchUser(spaceId: guid, userId: guid): Promise<ArgonUser>;
  PrefetchProfile(spaceId: guid, userId: guid): Promise<ArgonUserProfile>;
  GetChannels(spaceId: guid): Promise<IonArray<RealtimeChannel>>;
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  BeginUploadSpaceProfileHeader(spaceId: guid): Promise<guid>;
  CompleteUploadSpaceProfileHeader(spaceId: guid, blobId: guid): Promise<void>;
  BeginUploadSpaceAvatar(spaceId: guid): Promise<guid>;
  CompleteUploadSpaceAvatar(spaceId: guid, blobId: guid): Promise<void>;
  GetChannelGroups(spaceId: guid): Promise<IonArray<ChannelGroup>>;
}






export interface IUserInteraction extends IIonService
{
  GetMe(): Promise<ArgonUser>;
  CreateSpace(request: CreateServerRequest): Promise<ICreateSpaceResult>;
  GetSpaces(): Promise<IonArray<ArgonSpaceBase>>;
  UpdateMe(request: UserEditInput): Promise<ArgonUser>;
  JoinToSpace(inviteCode: InviteCode): Promise<IJoinToSpaceResult>;
  BroadcastPresence(presence: UserActivityPresence): Promise<void>;
  RemoveBroadcastPresence(): Promise<void>;
  GetMyFeatures(): Promise<IonArray<FeatureFlag>>;
  GetMyProfile(): Promise<ArgonUserProfile>;
  BeginUploadAvatar(): Promise<IUploadFileResult>;
  CompleteUploadAvatar(blobId: guid): Promise<void>;
  BeginUploadProfileHeader(): Promise<IUploadFileResult>;
  CompleteUploadProfileHeader(blobId: guid): Promise<void>;
  GetTodayStats(): Promise<TodayStats>;
  GetMyLevel(): Promise<MyLevelDetails>;
  ClaimLevelCoin(): Promise<bool>;
  GetNotificationCounters(): Promise<IonArray<NotificationCounterKv>>;
}




export interface IPreferenceInteraction extends IIonService
{
  SetPreference(scope: string, value: string): Promise<void>;
  GetPreference(scope: string, value: string): Promise<void>;
}




export interface IVoiceInteraction extends IIonService
{
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<bool>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<void>;
}


export interface ICallInteraction extends IIonService
{
  DingDongCreep(creepId: guid): Promise<IBeginCallResult>;
  PickUpCall(callId: guid): Promise<IPickUpCallResult>;
  RejectCall(callId: guid): Promise<void>;
  HangupCall(callId: guid): Promise<void>;
  UssdExecute(ussd: string, corlId: guid): Promise<ServiceUssdResult>;
  BeginDialCheck(phoneId: guid): Promise<IDialCheckResult>;
  DialUp(phoneId: guid, corlId: guid): Promise<IBeginCallResult>;
}




export interface IArchetypeInteraction extends IIonService
{
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  CreateArchetype(spaceId: guid, name: string): Promise<Archetype>;
  UpdateArchetype(spaceId: guid, data: Archetype): Promise<Archetype>;
  SetArchetypeToMember(spaceId: guid, memberId: guid, archetypeId: guid, isGrant: bool): Promise<bool>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  UpsertArchetypeEntitlementForChannel(spaceId: guid, channelId: guid, archetypeId: guid, deny: ArgonEntitlement, allow: ArgonEntitlement): Promise<ChannelEntitlementOverwrite | null>;
}




export interface IChannelInteraction extends IIonService
{
  CreateChannel(spaceId: guid, channelId: guid, request: CreateChannelRequest): Promise<void>;
  MoveChannel(spaceId: guid, channelId: guid, targetGroupId: guid | null, afterChannelId: guid | null, beforeChannelId: guid | null): Promise<void>;
  DeleteChannelGroup(spaceId: guid, channelId: guid, groupId: guid, deleteChannels: bool): Promise<void>;
  CreateChannelGroup(spaceId: guid, channelId: guid, name: string, desk: string | null): Promise<void>;
  MoveChannelGroup(spaceId: guid, channelId: guid, afterGroupId: guid | null, beforeGroupId: guid | null): Promise<void>;
  DeleteChannel(spaceId: guid, channelId: guid): Promise<void>;
  GetChannels(spaceId: guid, channelId: guid): Promise<IonArray<RealtimeChannel>>;
  UpdateChannelGroup(spaceId: guid, channelId: guid, groupId: guid, name: string | null, description: string | null): Promise<void>;
  QueryMessages(spaceId: guid, channelId: guid, from: i8 | null, limit: i4): Promise<IonArray<ArgonMessage>>;
  SendMessage(spaceId: guid, channelId: guid, text: string, entities: IonArray<IMessageEntity>, randomId: i8, replyTo: i8 | null): Promise<i8>;
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<void>;
  Interlink(spaceId: guid, channelId: guid): Promise<IInterlinkResult>;
  InterlinkStream(spaceId: guid, channelId: guid, density: i4): Promise<IInterlinkStreamResult>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<bool>;
  BeginRecord(spaceId: guid, channelId: guid): Promise<bool>;
  StopRecord(spaceId: guid, channelId: guid): Promise<bool>;
  CreateLinkedMeeting(spaceId: guid, channelId: guid): Promise<LinkedMeetingInfo>;
  EndLinkedMeeting(spaceId: guid, channelId: guid): Promise<void>;
}


export interface IEventBus extends IIonService
{
  ForServer(spaceId: guid): AsyncIterable<IArgonEvent>;
  Dispatch(ev: IArgonClientEvent): Promise<void>;
  Pipe(ev: AsyncIterable<IArgonClientEvent>): AsyncIterable<IArgonEvent>;
  PickTicket(): Promise<string>;
}




export interface IFeatureFlagInteractions extends IIonService
{
  GetMyFeatureFlags(): Promise<IonArray<FeatureFlagData>>;
}




export interface IFriendsInteraction extends IIonService
{
  GetBlockList(limit: i4, offset: i4): Promise<IonArray<UserBlock>>;
  GetMyFriendPendingList(limit: i4, offset: i4): Promise<IonArray<FriendRequest>>;
  GetMyFriendOutgoingList(limit: i4, offset: i4): Promise<IonArray<FriendRequest>>;
  GetMyFriendships(limit: i4, offset: i4): Promise<IonArray<Friendship>>;
  SendFriendRequest(username: string): Promise<SendFriendStatus>;
  RemoveFriend(userId: guid): Promise<void>;
  AcceptFriendRequest(fromUserId: guid): Promise<void>;
  DeclineFriendRequest(fromUserId: guid): Promise<void>;
  CancelFriendRequest(toUserId: guid): Promise<void>;
  BlockUser(userId: guid): Promise<void>;
  UnblockUser(userId: guid): Promise<void>;
}


export interface IUserChatInteractions extends IIonService
{
  GetRecentChats(limit: i4, offset: i4): Promise<IonArray<UserChat>>;
  PinChat(peerId: guid): Promise<void>;
  UnpinChat(peerId: guid): Promise<void>;
  MarkChatRead(peerId: guid): Promise<void>;
  SendDirectMessage(receiverId: guid, text: string, entities: IonArray<IMessageEntity>, randomId: i8, replyTo: i8 | null): Promise<i8>;
  QueryDirectMessages(peerId: guid, from: i8 | null, limit: i4): Promise<IonArray<DirectMessage>>;
}




export interface IIdentityInteraction extends IIonService
{
  Authorize(data: UserCredentialsInput): Promise<IAuthorizeResult>;
  Registration(data: NewUserCredentialsInput): Promise<IRegistrationResult>;
  BeginResetPassword(email: string): Promise<bool>;
  ResetPassword(email: string, otpCode: string, newPassword: string): Promise<IAuthorizeResult>;
  GetAuthorizationScenario(): Promise<string>;
  GetAuthorizationScenarioFor(data: UserLoginInput): Promise<string>;
  GetMyAuthorization(token: string, refreshToken: string | null): Promise<IMyAuthStatus>;
}




export interface IInventoryInteraction extends IIonService
{
  GetMyInventoryItems(): Promise<IonArray<InventoryItem>>;
  MarkSeen(itemIds: IonArray<guid>): Promise<void>;
  GetNotifications(): Promise<IonArray<InventoryNotification>>;
  RedeemCode(code: string): Promise<IRedeemResult>;
  UseItem(itemId: guid): Promise<bool>;
}




export interface ISecurityInteraction extends IIonService
{
  RequestEmailChange(newEmail: string, password: string): Promise<IRequestEmailChangeResult>;
  ConfirmEmailChange(verificationCode: string): Promise<IConfirmEmailChangeResult>;
  RequestPhoneChange(newPhone: string, password: string): Promise<IRequestPhoneChangeResult>;
  ConfirmPhoneChange(verificationCode: string): Promise<IConfirmPhoneChangeResult>;
  RemovePhone(password: string): Promise<IRemovePhoneResult>;
  ChangePassword(currentPassword: string, newPassword: string): Promise<IChangePasswordResult>;
  EnableOTP(): Promise<IEnableOTPResult>;
  VerifyAndEnableOTP(code: string): Promise<IVerifyOTPResult>;
  DisableOTP(code: string): Promise<IDisableOTPResult>;
  GetPasskeys(): Promise<IonArray<Passkey>>;
  BeginAddPasskey(name: string): Promise<IBeginPasskeyResult>;
  CompleteAddPasskey(passkeyId: guid, publicKey: string): Promise<ICompletePasskeyResult>;
  RemovePasskey(passkeyId: guid): Promise<IRemovePasskeyResult>;
  SetAutoDeletePeriod(months: i4 | null): Promise<ISetAutoDeleteResult>;
  GetAutoDeletePeriod(): Promise<AutoDeletePeriod>;
  GetSecurityDetails(): Promise<SecurityDetails>;
  BeginValidatePasskey(): Promise<IBeginPasskeyValidateResult>;
  CompleteValidatePasskey(credentialId: string, signature: string, authenticatorData: string, clientDataJSON: string): Promise<ICompletePasskeyResult>;
}




export interface IServerInteraction extends IIonService
{
  GetMembers(spaceId: guid): Promise<IonArray<RealtimeServerMember>>;
  GetMember(spaceId: guid, userId: guid): Promise<RealtimeServerMember>;
  GetInviteCodes(spaceId: guid): Promise<IonArray<InviteCodeEntity>>;
  CreateInviteCode(spaceId: guid): Promise<InviteCode>;
  PrefetchUser(spaceId: guid, userId: guid): Promise<ArgonUser>;
  PrefetchProfile(spaceId: guid, userId: guid): Promise<ArgonUserProfile>;
  GetChannels(spaceId: guid): Promise<IonArray<RealtimeChannel>>;
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  BeginUploadSpaceProfileHeader(spaceId: guid): Promise<guid>;
  CompleteUploadSpaceProfileHeader(spaceId: guid, blobId: guid): Promise<void>;
  BeginUploadSpaceAvatar(spaceId: guid): Promise<guid>;
  CompleteUploadSpaceAvatar(spaceId: guid, blobId: guid): Promise<void>;
  GetChannelGroups(spaceId: guid): Promise<IonArray<ChannelGroup>>;
}






export interface IUserInteraction extends IIonService
{
  GetMe(): Promise<ArgonUser>;
  CreateSpace(request: CreateServerRequest): Promise<ICreateSpaceResult>;
  GetSpaces(): Promise<IonArray<ArgonSpaceBase>>;
  UpdateMe(request: UserEditInput): Promise<ArgonUser>;
  JoinToSpace(inviteCode: InviteCode): Promise<IJoinToSpaceResult>;
  BroadcastPresence(presence: UserActivityPresence): Promise<void>;
  RemoveBroadcastPresence(): Promise<void>;
  GetMyFeatures(): Promise<IonArray<FeatureFlag>>;
  GetMyProfile(): Promise<ArgonUserProfile>;
  BeginUploadAvatar(): Promise<IUploadFileResult>;
  CompleteUploadAvatar(blobId: guid): Promise<void>;
  BeginUploadProfileHeader(): Promise<IUploadFileResult>;
  CompleteUploadProfileHeader(blobId: guid): Promise<void>;
  GetTodayStats(): Promise<TodayStats>;
  GetMyLevel(): Promise<MyLevelDetails>;
  ClaimLevelCoin(): Promise<bool>;
  GetNotificationCounters(): Promise<IonArray<NotificationCounterKv>>;
}




export interface IPreferenceInteraction extends IIonService
{
  SetPreference(scope: string, value: string): Promise<void>;
  GetPreference(scope: string, value: string): Promise<void>;
}




export interface IVoiceInteraction extends IIonService
{
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<bool>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<void>;
}


export interface ICallInteraction extends IIonService
{
  DingDongCreep(creepId: guid): Promise<IBeginCallResult>;
  PickUpCall(callId: guid): Promise<IPickUpCallResult>;
  RejectCall(callId: guid): Promise<void>;
  HangupCall(callId: guid): Promise<void>;
  UssdExecute(ussd: string, corlId: guid): Promise<ServiceUssdResult>;
  BeginDialCheck(phoneId: guid): Promise<IDialCheckResult>;
  DialUp(phoneId: guid, corlId: guid): Promise<IBeginCallResult>;
}



//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------

export class ArchetypeInteraction_Executor extends ServiceExecutor<IArchetypeInteraction> implements IArchetypeInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "GetServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Archetype>>("IonArray<Archetype>", writer.data, this.signal);
  }
  async CreateArchetype(spaceId: guid, name: string): Promise<Archetype> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "CreateArchetype");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<string>('string').write(writer, name);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<Archetype>("Archetype", writer.data, this.signal);
  }
  async UpdateArchetype(spaceId: guid, data: Archetype): Promise<Archetype> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "UpdateArchetype");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<Archetype>("Archetype", writer.data, this.signal);
  }
  async SetArchetypeToMember(spaceId: guid, memberId: guid, archetypeId: guid, isGrant: bool): Promise<bool> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "SetArchetypeToMember");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, memberId);
    IonFormatterStorage.get<guid>('guid').write(writer, archetypeId);
    IonFormatterStorage.get<bool>('bool').write(writer, isGrant);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "GetDetailedServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArchetypeGroup>>("IonArray<ArchetypeGroup>", writer.data, this.signal);
  }
  async UpsertArchetypeEntitlementForChannel(spaceId: guid, channelId: guid, archetypeId: guid, deny: ArgonEntitlement, allow: ArgonEntitlement): Promise<ChannelEntitlementOverwrite | null> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "UpsertArchetypeEntitlementForChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(5);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, archetypeId);
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, deny);
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, allow);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ChannelEntitlementOverwrite | null>("ChannelEntitlementOverwrite | null", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IArchetypeInteraction>('ArchetypeInteraction', ArchetypeInteraction_Executor);

export class ChannelInteraction_Executor extends ServiceExecutor<IChannelInteraction> implements IChannelInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async CreateChannel(spaceId: guid, channelId: guid, request: CreateChannelRequest): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "CreateChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<CreateChannelRequest>('CreateChannelRequest').write(writer, request);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async MoveChannel(spaceId: guid, channelId: guid, targetGroupId: guid | null, afterChannelId: guid | null, beforeChannelId: guid | null): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "MoveChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(5);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.writeNullable<guid>(writer, targetGroupId, 'guid');
    IonFormatterStorage.writeNullable<guid>(writer, afterChannelId, 'guid');
    IonFormatterStorage.writeNullable<guid>(writer, beforeChannelId, 'guid');
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async DeleteChannelGroup(spaceId: guid, channelId: guid, groupId: guid, deleteChannels: bool): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "DeleteChannelGroup");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, groupId);
    IonFormatterStorage.get<bool>('bool').write(writer, deleteChannels);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async CreateChannelGroup(spaceId: guid, channelId: guid, name: string, desk: string | null): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "CreateChannelGroup");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<string>('string').write(writer, name);
    IonFormatterStorage.writeNullable<string>(writer, desk, 'string');
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async MoveChannelGroup(spaceId: guid, channelId: guid, afterGroupId: guid | null, beforeGroupId: guid | null): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "MoveChannelGroup");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.writeNullable<guid>(writer, afterGroupId, 'guid');
    IonFormatterStorage.writeNullable<guid>(writer, beforeGroupId, 'guid');
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async DeleteChannel(spaceId: guid, channelId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "DeleteChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetChannels(spaceId: guid, channelId: guid): Promise<IonArray<RealtimeChannel>> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "GetChannels");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<RealtimeChannel>>("IonArray<RealtimeChannel>", writer.data, this.signal);
  }
  async UpdateChannelGroup(spaceId: guid, channelId: guid, groupId: guid, name: string | null, description: string | null): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "UpdateChannelGroup");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(5);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, groupId);
    IonFormatterStorage.writeNullable<string>(writer, name, 'string');
    IonFormatterStorage.writeNullable<string>(writer, description, 'string');
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async QueryMessages(spaceId: guid, channelId: guid, from: i8 | null, limit: i4): Promise<IonArray<ArgonMessage>> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "QueryMessages");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.writeNullable<i8>(writer, from, 'i8');
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArgonMessage>>("IonArray<ArgonMessage>", writer.data, this.signal);
  }
  async SendMessage(spaceId: guid, channelId: guid, text: string, entities: IonArray<IMessageEntity>, randomId: i8, replyTo: i8 | null): Promise<i8> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "SendMessage");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(6);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<string>('string').write(writer, text);
    IonFormatterStorage.writeArray<IMessageEntity>(writer, entities, 'IMessageEntity');
    IonFormatterStorage.get<i8>('i8').write(writer, randomId);
    IonFormatterStorage.writeNullable<i8>(writer, replyTo, 'i8');
      
    writer.writeEndArray();
          
    return await req.callAsyncT<i8>("i8", writer.data, this.signal);
  }
  async DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "DisconnectFromVoiceChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async Interlink(spaceId: guid, channelId: guid): Promise<IInterlinkResult> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "Interlink");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IInterlinkResult>("IInterlinkResult", writer.data, this.signal);
  }
  async InterlinkStream(spaceId: guid, channelId: guid, density: i4): Promise<IInterlinkStreamResult> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "InterlinkStream");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<i4>('i4').write(writer, density);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IInterlinkStreamResult>("IInterlinkStreamResult", writer.data, this.signal);
  }
  async KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "KickMemberFromChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, memberId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async BeginRecord(spaceId: guid, channelId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "BeginRecord");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async StopRecord(spaceId: guid, channelId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "StopRecord");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async CreateLinkedMeeting(spaceId: guid, channelId: guid): Promise<LinkedMeetingInfo> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "CreateLinkedMeeting");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<LinkedMeetingInfo>("LinkedMeetingInfo", writer.data, this.signal);
  }
  async EndLinkedMeeting(spaceId: guid, channelId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "EndLinkedMeeting");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IChannelInteraction>('ChannelInteraction', ChannelInteraction_Executor);

export class EventBus_Executor extends ServiceExecutor<IEventBus> implements IEventBus {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  ForServer(spaceId: guid): AsyncIterable<IArgonEvent> {
    const ws = new IonWsClient(this.ctx, "IEventBus", "ForServer");
    
    const writer = new CborWriter();
    
    writer.writeStartArray(1);
    
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    
    writer.writeEndArray();
    
    return ws.callServerStreaming<IArgonEvent>("IArgonEvent", writer.data, this.signal);
  }
  async Dispatch(ev: IArgonClientEvent): Promise<void> {
    const req = new IonRequest(this.ctx, "IEventBus", "Dispatch");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<IArgonClientEvent>('IArgonClientEvent').write(writer, ev);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  Pipe(inputStream: AsyncIterable<IArgonClientEvent>): AsyncIterable<IArgonEvent> {
    const ws = new IonWsClient(this.ctx, "IEventBus", "Pipe");
    
    const writer = new CborWriter();
    
    writer.writeStartArray(0);
    
    
    
    writer.writeEndArray();
    
    return ws.callServerStreamingFullDuplex<IArgonEvent, IArgonClientEvent>("IArgonEvent", writer.data, inputStream, "IArgonClientEvent", this.signal);
  }
  async PickTicket(): Promise<string> {
    const req = new IonRequest(this.ctx, "IEventBus", "PickTicket");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IEventBus>('EventBus', EventBus_Executor);

export class FeatureFlagInteractions_Executor extends ServiceExecutor<IFeatureFlagInteractions> implements IFeatureFlagInteractions {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetMyFeatureFlags(): Promise<IonArray<FeatureFlagData>> {
    const req = new IonRequest(this.ctx, "IFeatureFlagInteractions", "GetMyFeatureFlags");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<FeatureFlagData>>("IonArray<FeatureFlagData>", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IFeatureFlagInteractions>('FeatureFlagInteractions', FeatureFlagInteractions_Executor);

export class FriendsInteraction_Executor extends ServiceExecutor<IFriendsInteraction> implements IFriendsInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetBlockList(limit: i4, offset: i4): Promise<IonArray<UserBlock>> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "GetBlockList");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
    IonFormatterStorage.get<i4>('i4').write(writer, offset);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<UserBlock>>("IonArray<UserBlock>", writer.data, this.signal);
  }
  async GetMyFriendPendingList(limit: i4, offset: i4): Promise<IonArray<FriendRequest>> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "GetMyFriendPendingList");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
    IonFormatterStorage.get<i4>('i4').write(writer, offset);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<FriendRequest>>("IonArray<FriendRequest>", writer.data, this.signal);
  }
  async GetMyFriendOutgoingList(limit: i4, offset: i4): Promise<IonArray<FriendRequest>> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "GetMyFriendOutgoingList");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
    IonFormatterStorage.get<i4>('i4').write(writer, offset);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<FriendRequest>>("IonArray<FriendRequest>", writer.data, this.signal);
  }
  async GetMyFriendships(limit: i4, offset: i4): Promise<IonArray<Friendship>> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "GetMyFriendships");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
    IonFormatterStorage.get<i4>('i4').write(writer, offset);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Friendship>>("IonArray<Friendship>", writer.data, this.signal);
  }
  async SendFriendRequest(username: string): Promise<SendFriendStatus> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "SendFriendRequest");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, username);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<SendFriendStatus>("SendFriendStatus", writer.data, this.signal);
  }
  async RemoveFriend(userId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "RemoveFriend");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async AcceptFriendRequest(fromUserId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "AcceptFriendRequest");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, fromUserId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async DeclineFriendRequest(fromUserId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "DeclineFriendRequest");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, fromUserId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async CancelFriendRequest(toUserId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "CancelFriendRequest");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, toUserId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async BlockUser(userId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "BlockUser");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async UnblockUser(userId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IFriendsInteraction", "UnblockUser");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IFriendsInteraction>('FriendsInteraction', FriendsInteraction_Executor);

export class UserChatInteractions_Executor extends ServiceExecutor<IUserChatInteractions> implements IUserChatInteractions {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetRecentChats(limit: i4, offset: i4): Promise<IonArray<UserChat>> {
    const req = new IonRequest(this.ctx, "IUserChatInteractions", "GetRecentChats");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
    IonFormatterStorage.get<i4>('i4').write(writer, offset);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<UserChat>>("IonArray<UserChat>", writer.data, this.signal);
  }
  async PinChat(peerId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserChatInteractions", "PinChat");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, peerId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async UnpinChat(peerId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserChatInteractions", "UnpinChat");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, peerId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async MarkChatRead(peerId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserChatInteractions", "MarkChatRead");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, peerId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async SendDirectMessage(receiverId: guid, text: string, entities: IonArray<IMessageEntity>, randomId: i8, replyTo: i8 | null): Promise<i8> {
    const req = new IonRequest(this.ctx, "IUserChatInteractions", "SendDirectMessage");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(5);
          
    IonFormatterStorage.get<guid>('guid').write(writer, receiverId);
    IonFormatterStorage.get<string>('string').write(writer, text);
    IonFormatterStorage.writeArray<IMessageEntity>(writer, entities, 'IMessageEntity');
    IonFormatterStorage.get<i8>('i8').write(writer, randomId);
    IonFormatterStorage.writeNullable<i8>(writer, replyTo, 'i8');
      
    writer.writeEndArray();
          
    return await req.callAsyncT<i8>("i8", writer.data, this.signal);
  }
  async QueryDirectMessages(peerId: guid, from: i8 | null, limit: i4): Promise<IonArray<DirectMessage>> {
    const req = new IonRequest(this.ctx, "IUserChatInteractions", "QueryDirectMessages");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, peerId);
    IonFormatterStorage.writeNullable<i8>(writer, from, 'i8');
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<DirectMessage>>("IonArray<DirectMessage>", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IUserChatInteractions>('UserChatInteractions', UserChatInteractions_Executor);

export class IdentityInteraction_Executor extends ServiceExecutor<IIdentityInteraction> implements IIdentityInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async Authorize(data: UserCredentialsInput): Promise<IAuthorizeResult> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "Authorize");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserCredentialsInput>('UserCredentialsInput').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IAuthorizeResult>("IAuthorizeResult", writer.data, this.signal);
  }
  async Registration(data: NewUserCredentialsInput): Promise<IRegistrationResult> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "Registration");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<NewUserCredentialsInput>('NewUserCredentialsInput').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IRegistrationResult>("IRegistrationResult", writer.data, this.signal);
  }
  async BeginResetPassword(email: string): Promise<bool> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "BeginResetPassword");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, email);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async ResetPassword(email: string, otpCode: string, newPassword: string): Promise<IAuthorizeResult> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "ResetPassword");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<string>('string').write(writer, email);
    IonFormatterStorage.get<string>('string').write(writer, otpCode);
    IonFormatterStorage.get<string>('string').write(writer, newPassword);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IAuthorizeResult>("IAuthorizeResult", writer.data, this.signal);
  }
  async GetAuthorizationScenario(): Promise<string> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "GetAuthorizationScenario");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async GetAuthorizationScenarioFor(data: UserLoginInput): Promise<string> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "GetAuthorizationScenarioFor");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserLoginInput>('UserLoginInput').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async GetMyAuthorization(token: string, refreshToken: string | null): Promise<IMyAuthStatus> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "GetMyAuthorization");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, token);
    IonFormatterStorage.writeNullable<string>(writer, refreshToken, 'string');
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IMyAuthStatus>("IMyAuthStatus", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IIdentityInteraction>('IdentityInteraction', IdentityInteraction_Executor);

export class InventoryInteraction_Executor extends ServiceExecutor<IInventoryInteraction> implements IInventoryInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetMyInventoryItems(): Promise<IonArray<InventoryItem>> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "GetMyInventoryItems");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<InventoryItem>>("IonArray<InventoryItem>", writer.data, this.signal);
  }
  async MarkSeen(itemIds: IonArray<guid>): Promise<void> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "MarkSeen");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.writeArray<guid>(writer, itemIds, 'guid');
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetNotifications(): Promise<IonArray<InventoryNotification>> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "GetNotifications");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<InventoryNotification>>("IonArray<InventoryNotification>", writer.data, this.signal);
  }
  async RedeemCode(code: string): Promise<IRedeemResult> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "RedeemCode");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, code);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IRedeemResult>("IRedeemResult", writer.data, this.signal);
  }
  async UseItem(itemId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "UseItem");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, itemId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IInventoryInteraction>('InventoryInteraction', InventoryInteraction_Executor);

export class SecurityInteraction_Executor extends ServiceExecutor<ISecurityInteraction> implements ISecurityInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async RequestEmailChange(newEmail: string, password: string): Promise<IRequestEmailChangeResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "RequestEmailChange");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, newEmail);
    IonFormatterStorage.get<string>('string').write(writer, password);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IRequestEmailChangeResult>("IRequestEmailChangeResult", writer.data, this.signal);
  }
  async ConfirmEmailChange(verificationCode: string): Promise<IConfirmEmailChangeResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "ConfirmEmailChange");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, verificationCode);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IConfirmEmailChangeResult>("IConfirmEmailChangeResult", writer.data, this.signal);
  }
  async RequestPhoneChange(newPhone: string, password: string): Promise<IRequestPhoneChangeResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "RequestPhoneChange");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, newPhone);
    IonFormatterStorage.get<string>('string').write(writer, password);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IRequestPhoneChangeResult>("IRequestPhoneChangeResult", writer.data, this.signal);
  }
  async ConfirmPhoneChange(verificationCode: string): Promise<IConfirmPhoneChangeResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "ConfirmPhoneChange");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, verificationCode);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IConfirmPhoneChangeResult>("IConfirmPhoneChangeResult", writer.data, this.signal);
  }
  async RemovePhone(password: string): Promise<IRemovePhoneResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "RemovePhone");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, password);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IRemovePhoneResult>("IRemovePhoneResult", writer.data, this.signal);
  }
  async ChangePassword(currentPassword: string, newPassword: string): Promise<IChangePasswordResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "ChangePassword");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, currentPassword);
    IonFormatterStorage.get<string>('string').write(writer, newPassword);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IChangePasswordResult>("IChangePasswordResult", writer.data, this.signal);
  }
  async EnableOTP(): Promise<IEnableOTPResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "EnableOTP");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IEnableOTPResult>("IEnableOTPResult", writer.data, this.signal);
  }
  async VerifyAndEnableOTP(code: string): Promise<IVerifyOTPResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "VerifyAndEnableOTP");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, code);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IVerifyOTPResult>("IVerifyOTPResult", writer.data, this.signal);
  }
  async DisableOTP(code: string): Promise<IDisableOTPResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "DisableOTP");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, code);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IDisableOTPResult>("IDisableOTPResult", writer.data, this.signal);
  }
  async GetPasskeys(): Promise<IonArray<Passkey>> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "GetPasskeys");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Passkey>>("IonArray<Passkey>", writer.data, this.signal);
  }
  async BeginAddPasskey(name: string): Promise<IBeginPasskeyResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "BeginAddPasskey");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, name);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IBeginPasskeyResult>("IBeginPasskeyResult", writer.data, this.signal);
  }
  async CompleteAddPasskey(passkeyId: guid, publicKey: string): Promise<ICompletePasskeyResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "CompleteAddPasskey");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, passkeyId);
    IonFormatterStorage.get<string>('string').write(writer, publicKey);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ICompletePasskeyResult>("ICompletePasskeyResult", writer.data, this.signal);
  }
  async RemovePasskey(passkeyId: guid): Promise<IRemovePasskeyResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "RemovePasskey");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, passkeyId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IRemovePasskeyResult>("IRemovePasskeyResult", writer.data, this.signal);
  }
  async SetAutoDeletePeriod(months: i4 | null): Promise<ISetAutoDeleteResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "SetAutoDeletePeriod");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.writeNullable<i4>(writer, months, 'i4');
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ISetAutoDeleteResult>("ISetAutoDeleteResult", writer.data, this.signal);
  }
  async GetAutoDeletePeriod(): Promise<AutoDeletePeriod> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "GetAutoDeletePeriod");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<AutoDeletePeriod>("AutoDeletePeriod", writer.data, this.signal);
  }
  async GetSecurityDetails(): Promise<SecurityDetails> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "GetSecurityDetails");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<SecurityDetails>("SecurityDetails", writer.data, this.signal);
  }
  async BeginValidatePasskey(): Promise<IBeginPasskeyValidateResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "BeginValidatePasskey");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IBeginPasskeyValidateResult>("IBeginPasskeyValidateResult", writer.data, this.signal);
  }
  async CompleteValidatePasskey(credentialId: string, signature: string, authenticatorData: string, clientDataJSON: string): Promise<ICompletePasskeyResult> {
    const req = new IonRequest(this.ctx, "ISecurityInteraction", "CompleteValidatePasskey");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<string>('string').write(writer, credentialId);
    IonFormatterStorage.get<string>('string').write(writer, signature);
    IonFormatterStorage.get<string>('string').write(writer, authenticatorData);
    IonFormatterStorage.get<string>('string').write(writer, clientDataJSON);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ICompletePasskeyResult>("ICompletePasskeyResult", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<ISecurityInteraction>('SecurityInteraction', SecurityInteraction_Executor);

export class ServerInteraction_Executor extends ServiceExecutor<IServerInteraction> implements IServerInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetMembers(spaceId: guid): Promise<IonArray<RealtimeServerMember>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetMembers");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<RealtimeServerMember>>("IonArray<RealtimeServerMember>", writer.data, this.signal);
  }
  async GetMember(spaceId: guid, userId: guid): Promise<RealtimeServerMember> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetMember");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<RealtimeServerMember>("RealtimeServerMember", writer.data, this.signal);
  }
  async GetInviteCodes(spaceId: guid): Promise<IonArray<InviteCodeEntity>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetInviteCodes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<InviteCodeEntity>>("IonArray<InviteCodeEntity>", writer.data, this.signal);
  }
  async CreateInviteCode(spaceId: guid): Promise<InviteCode> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "CreateInviteCode");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<InviteCode>("InviteCode", writer.data, this.signal);
  }
  async PrefetchUser(spaceId: guid, userId: guid): Promise<ArgonUser> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "PrefetchUser");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUser>("ArgonUser", writer.data, this.signal);
  }
  async PrefetchProfile(spaceId: guid, userId: guid): Promise<ArgonUserProfile> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "PrefetchProfile");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUserProfile>("ArgonUserProfile", writer.data, this.signal);
  }
  async GetChannels(spaceId: guid): Promise<IonArray<RealtimeChannel>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetChannels");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<RealtimeChannel>>("IonArray<RealtimeChannel>", writer.data, this.signal);
  }
  async GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Archetype>>("IonArray<Archetype>", writer.data, this.signal);
  }
  async GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetDetailedServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArchetypeGroup>>("IonArray<ArchetypeGroup>", writer.data, this.signal);
  }
  async BeginUploadSpaceProfileHeader(spaceId: guid): Promise<guid> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "BeginUploadSpaceProfileHeader");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<guid>("guid", writer.data, this.signal);
  }
  async CompleteUploadSpaceProfileHeader(spaceId: guid, blobId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "CompleteUploadSpaceProfileHeader");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, blobId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async BeginUploadSpaceAvatar(spaceId: guid): Promise<guid> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "BeginUploadSpaceAvatar");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<guid>("guid", writer.data, this.signal);
  }
  async CompleteUploadSpaceAvatar(spaceId: guid, blobId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "CompleteUploadSpaceAvatar");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, blobId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetChannelGroups(spaceId: guid): Promise<IonArray<ChannelGroup>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetChannelGroups");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ChannelGroup>>("IonArray<ChannelGroup>", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IServerInteraction>('ServerInteraction', ServerInteraction_Executor);

export class UserInteraction_Executor extends ServiceExecutor<IUserInteraction> implements IUserInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetMe(): Promise<ArgonUser> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetMe");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUser>("ArgonUser", writer.data, this.signal);
  }
  async CreateSpace(request: CreateServerRequest): Promise<ICreateSpaceResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "CreateSpace");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<CreateServerRequest>('CreateServerRequest').write(writer, request);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ICreateSpaceResult>("ICreateSpaceResult", writer.data, this.signal);
  }
  async GetSpaces(): Promise<IonArray<ArgonSpaceBase>> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetSpaces");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArgonSpaceBase>>("IonArray<ArgonSpaceBase>", writer.data, this.signal);
  }
  async UpdateMe(request: UserEditInput): Promise<ArgonUser> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "UpdateMe");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserEditInput>('UserEditInput').write(writer, request);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUser>("ArgonUser", writer.data, this.signal);
  }
  async JoinToSpace(inviteCode: InviteCode): Promise<IJoinToSpaceResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "JoinToSpace");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<InviteCode>('InviteCode').write(writer, inviteCode);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IJoinToSpaceResult>("IJoinToSpaceResult", writer.data, this.signal);
  }
  async BroadcastPresence(presence: UserActivityPresence): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "BroadcastPresence");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserActivityPresence>('UserActivityPresence').write(writer, presence);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async RemoveBroadcastPresence(): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "RemoveBroadcastPresence");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetMyFeatures(): Promise<IonArray<FeatureFlag>> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetMyFeatures");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<FeatureFlag>>("IonArray<FeatureFlag>", writer.data, this.signal);
  }
  async GetMyProfile(): Promise<ArgonUserProfile> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetMyProfile");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUserProfile>("ArgonUserProfile", writer.data, this.signal);
  }
  async BeginUploadAvatar(): Promise<IUploadFileResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "BeginUploadAvatar");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IUploadFileResult>("IUploadFileResult", writer.data, this.signal);
  }
  async CompleteUploadAvatar(blobId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "CompleteUploadAvatar");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, blobId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async BeginUploadProfileHeader(): Promise<IUploadFileResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "BeginUploadProfileHeader");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IUploadFileResult>("IUploadFileResult", writer.data, this.signal);
  }
  async CompleteUploadProfileHeader(blobId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "CompleteUploadProfileHeader");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, blobId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetTodayStats(): Promise<TodayStats> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetTodayStats");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<TodayStats>("TodayStats", writer.data, this.signal);
  }
  async GetMyLevel(): Promise<MyLevelDetails> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetMyLevel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<MyLevelDetails>("MyLevelDetails", writer.data, this.signal);
  }
  async ClaimLevelCoin(): Promise<bool> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "ClaimLevelCoin");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async GetNotificationCounters(): Promise<IonArray<NotificationCounterKv>> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetNotificationCounters");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<NotificationCounterKv>>("IonArray<NotificationCounterKv>", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IUserInteraction>('UserInteraction', UserInteraction_Executor);

export class PreferenceInteraction_Executor extends ServiceExecutor<IPreferenceInteraction> implements IPreferenceInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async SetPreference(scope: string, value: string): Promise<void> {
    const req = new IonRequest(this.ctx, "IPreferenceInteraction", "SetPreference");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, scope);
    IonFormatterStorage.get<string>('string').write(writer, value);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetPreference(scope: string, value: string): Promise<void> {
    const req = new IonRequest(this.ctx, "IPreferenceInteraction", "GetPreference");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, scope);
    IonFormatterStorage.get<string>('string').write(writer, value);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IPreferenceInteraction>('PreferenceInteraction', PreferenceInteraction_Executor);

export class VoiceInteraction_Executor extends ServiceExecutor<IVoiceInteraction> implements IVoiceInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IVoiceInteraction", "DisconnectFromVoiceChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IVoiceInteraction", "KickMemberFromChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, memberId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IVoiceInteraction>('VoiceInteraction', VoiceInteraction_Executor);

export class CallInteraction_Executor extends ServiceExecutor<ICallInteraction> implements ICallInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async DingDongCreep(creepId: guid): Promise<IBeginCallResult> {
    const req = new IonRequest(this.ctx, "ICallInteraction", "DingDongCreep");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, creepId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IBeginCallResult>("IBeginCallResult", writer.data, this.signal);
  }
  async PickUpCall(callId: guid): Promise<IPickUpCallResult> {
    const req = new IonRequest(this.ctx, "ICallInteraction", "PickUpCall");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, callId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IPickUpCallResult>("IPickUpCallResult", writer.data, this.signal);
  }
  async RejectCall(callId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "ICallInteraction", "RejectCall");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, callId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async HangupCall(callId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "ICallInteraction", "HangupCall");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, callId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async UssdExecute(ussd: string, corlId: guid): Promise<ServiceUssdResult> {
    const req = new IonRequest(this.ctx, "ICallInteraction", "UssdExecute");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, ussd);
    IonFormatterStorage.get<guid>('guid').write(writer, corlId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ServiceUssdResult>("ServiceUssdResult", writer.data, this.signal);
  }
  async BeginDialCheck(phoneId: guid): Promise<IDialCheckResult> {
    const req = new IonRequest(this.ctx, "ICallInteraction", "BeginDialCheck");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, phoneId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IDialCheckResult>("IDialCheckResult", writer.data, this.signal);
  }
  async DialUp(phoneId: guid, corlId: guid): Promise<IBeginCallResult> {
    const req = new IonRequest(this.ctx, "ICallInteraction", "DialUp");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, phoneId);
    IonFormatterStorage.get<guid>('guid').write(writer, corlId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IBeginCallResult>("IBeginCallResult", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<ICallInteraction>('CallInteraction', CallInteraction_Executor);


export function createClient(endpoint: string, interceptors: IonInterceptor[]) {
  const ctx = {
    baseUrl: endpoint,
    interceptors: interceptors
  } as IonClientContext;
  const controller = new AbortController();

  return new Proxy(
    {},
    {
      get(_target, propKey) {
        if (typeof propKey !== "string") return undefined;
        if (propKey === "ArchetypeInteraction") return IonFormatterStorage.createExecutor("ArchetypeInteraction", ctx, controller.signal);
        if (propKey === "ChannelInteraction") return IonFormatterStorage.createExecutor("ChannelInteraction", ctx, controller.signal);
        if (propKey === "EventBus") return IonFormatterStorage.createExecutor("EventBus", ctx, controller.signal);
        if (propKey === "FeatureFlagInteractions") return IonFormatterStorage.createExecutor("FeatureFlagInteractions", ctx, controller.signal);
        if (propKey === "FriendsInteraction") return IonFormatterStorage.createExecutor("FriendsInteraction", ctx, controller.signal);
        if (propKey === "UserChatInteractions") return IonFormatterStorage.createExecutor("UserChatInteractions", ctx, controller.signal);
        if (propKey === "IdentityInteraction") return IonFormatterStorage.createExecutor("IdentityInteraction", ctx, controller.signal);
        if (propKey === "InventoryInteraction") return IonFormatterStorage.createExecutor("InventoryInteraction", ctx, controller.signal);
        if (propKey === "SecurityInteraction") return IonFormatterStorage.createExecutor("SecurityInteraction", ctx, controller.signal);
        if (propKey === "ServerInteraction") return IonFormatterStorage.createExecutor("ServerInteraction", ctx, controller.signal);
        if (propKey === "UserInteraction") return IonFormatterStorage.createExecutor("UserInteraction", ctx, controller.signal);
        if (propKey === "PreferenceInteraction") return IonFormatterStorage.createExecutor("PreferenceInteraction", ctx, controller.signal);
        if (propKey === "VoiceInteraction") return IonFormatterStorage.createExecutor("VoiceInteraction", ctx, controller.signal);
        if (propKey === "CallInteraction") return IonFormatterStorage.createExecutor("CallInteraction", ctx, controller.signal);


        throw new Error(`${propKey} service is not defined`);
      },
    }
  ) as {
    ArchetypeInteraction: IArchetypeInteraction;
    ChannelInteraction: IChannelInteraction;
    EventBus: IEventBus;
    FeatureFlagInteractions: IFeatureFlagInteractions;
    FriendsInteraction: IFriendsInteraction;
    UserChatInteractions: IUserChatInteractions;
    IdentityInteraction: IIdentityInteraction;
    InventoryInteraction: IInventoryInteraction;
    SecurityInteraction: ISecurityInteraction;
    ServerInteraction: IServerInteraction;
    UserInteraction: IUserInteraction;
    PreferenceInteraction: IPreferenceInteraction;
    VoiceInteraction: IVoiceInteraction;
    CallInteraction: ICallInteraction;

  };
}

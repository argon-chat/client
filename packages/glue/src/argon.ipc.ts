//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------
import { 
  CborReader, 
  CborWriter, 
  
  DateOnly, 
  DateTimeOffset, 
  Duration, 
  TimeOnly, 
  Guid, 
  
  IonFormatterStorage,

  IonArray, 
  IonMaybe,

  IIonService,
  IIonUnion,
  
  ServiceExecutor,
  IonClientContext,
  IonRequest,
  IonWsClient,
  IonInterceptor,
  bytes
} from "@argon-chat/ion.webcore";

type guid = Guid;
type timeonly = TimeOnly;
type duration = Duration;
type datetime = DateTimeOffset;
type dateonly = DateOnly;

declare type bool = boolean;

declare type i1 = number;
declare type i2 = number;
declare type i4 = number;
declare type i8 = bigint;
declare type i16 = bigint;


declare type u1 = number;
declare type u2 = number;
declare type u4 = number;
declare type u8 = bigint;
declare type u16 = bigint;


declare type f2 = number;
declare type f4 = number;
declare type f8 = number;

export interface PasskeyUser {
  id: string;
  name: string;
  displayName: string;
};


export interface PasskeyCredential {
  id: string;
  publicKey: string;
};


export interface IceServerCred {
  url: string;
  pass: string;
  user: string;
};


export interface StreamBegin {
  whipUrl: string;
  iceServers: IonArray<IceServerCred>;
  outputIndex: i4;
  fps: i4;
  targetWidth: i4;
  targetHeight: i4;
};


export interface SetResult {
  value: ConfigKeyMetadata_Value | null;
};


export interface ActivityLogEntity {
  logLevel: ActivityLogLevel;
  template: string;
  args: IonArray<string>;
  time: datetime;
};


export interface StorageInfo {
  totalSize: string;
  availableFreeSpace: string;
};


export interface Screen {
  displayIndex: i4;
  width: i4;
  height: i4;
  left: i4;
  top: i4;
  isPrimary: bool;
  freq: i4;
};


export interface WindowInfo {
  deviceId: string;
  title: string;
};


export interface PinnedFn {
  id: i4;
};


export interface ConfigKeyMetadata {
  key: string;
  type: ConfigPrimitiveType;
  requiredToRestartApp: bool;
  onlyForDevMode: bool;
};


export interface ConfigSectionMetadata {
  section: string;
  keys: IonArray<ConfigKeyMetadata>;
};


export interface SetRequest {
  key: string;
  section: string;
  valueB: bool | null;
  valueStr: string | null;
  valueNum: i8 | null;
  valueEnum: string | null;
  valueF: f8 | null;
};


export interface ConfigSectionMetadata_Value {
  section: string;
  keys: IonArray<ConfigKeyMetadata_Value>;
};


export interface ConfigKeyMetadata_Value {
  key: string;
  type: ConfigPrimitiveType;
  requiredToRestartApp: bool;
  onlyForDevMode: bool;
  valueB: bool | null;
  valueStr: string | null;
  valueNum: i8 | null;
  valueEnum: string | null;
  valueEnumVariants: IonArray<string>;
  valueF: f8 | null;
};


export interface HotkeyButton {
  device: HotkeyDevice;
  code: i4;
};


export interface HotkeyChord {
  buttons: IonArray<HotkeyButton>;
};


export interface HotkeyDescriptor {
  id: string;
  chord: HotkeyChord;
  action: HotkeyActionType;
  suppress: bool;
  triggerCooldownMs: i4;
};


export interface HotkeyEvent {
  hotkeyId: string;
  phase: HotkeyPhase;
  timestamp: datetime;
};


export enum ActivityKind
{
  GameActivity = 0,
  MusicActivity = 1,
  HotKeysActivity = 2,
  SystemActivity = 3,
  NetworkActivity = 4,
}


export enum ActivityLogLevel
{
  Info = 0,
  Warn = 1,
  Error = 2,
}


export enum Channel
{
  live = 0,
  beta = 1,
  canary = 2,
}


export enum HostKind
{
  WindowsDesktop = 0,
  MacOs = 1,
}


export enum OverlayKind
{
  GameOverlay = 0,
  VrOverlay = 1,
}


export enum ConfigPrimitiveType
{
  Boolean = 0,
  Number = 1,
  String = 2,
  Enum = 3,
  Double = 4,
}


export enum HotkeyDevice
{
  Keyboard = 0,
  Mouse = 1,
}


export enum HotkeyActionType
{
  Trigger = 0,
  Hold = 1,
  Toggle = 2,
}


export enum HotkeyPhase
{
  Started = 0,
  Triggered = 1,
  Ended = 2,
}


export interface InitCfg {
  width: i4;
  height: i4;
  tileSize: i4;
  tilesX: i4;
  tilesY: i4;
};


export interface FrameData {
  timestamp: i4;
  width: i4;
  height: i4;
  tiles: IonArray<BridgeDirtyTile>;
};


export interface FrameDataDelta {
  timestamp: i4;
  tiles: IonArray<BridgeDirtyTile>;
  skippedTransparent: i4;
};


export interface OverlayStats {
  fps: i4;
  captureTimeMs: i4;
  bytesThisFrame: i4;
  tileCount: i4;
  transparentSkipped: i4;
};


export interface BridgeDirtyTile {
  tx: i4;
  ty: i4;
  x: i4;
  y: i4;
  w: i4;
  h: i4;
  data: bytes;
};



export abstract class ICreatePasskeyResult implements IIonUnion<ICreatePasskeyResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessCreatePasskey(): this is SuccessCreatePasskey {
    return this.UnionKey === "SuccessCreatePasskey";
  }
  public isErrorCreatePasskey(): this is ErrorCreatePasskey {
    return this.UnionKey === "ErrorCreatePasskey";
  }

}


export class SuccessCreatePasskey extends ICreatePasskeyResult
{
  constructor(public cert: string) { super(); }

  UnionKey: string = "SuccessCreatePasskey";
  UnionIndex: number = 0;
}

export class ErrorCreatePasskey extends ICreatePasskeyResult
{
  constructor(public errorMessage: string) { super(); }

  UnionKey: string = "ErrorCreatePasskey";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("ICreatePasskeyResult", {
  read(reader: CborReader): ICreatePasskeyResult {
    reader.readStartArray();
    let value: ICreatePasskeyResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessCreatePasskey>("SuccessCreatePasskey").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<ErrorCreatePasskey>("ErrorCreatePasskey").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: ICreatePasskeyResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessCreatePasskey>("SuccessCreatePasskey").write(writer, value as SuccessCreatePasskey);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<ErrorCreatePasskey>("ErrorCreatePasskey").write(writer, value as ErrorCreatePasskey);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessCreatePasskey", {
  read(reader: CborReader): SuccessCreatePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const cert = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new SuccessCreatePasskey(cert);
  },
  write(writer: CborWriter, value: SuccessCreatePasskey): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.cert);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ErrorCreatePasskey", {
  read(reader: CborReader): ErrorCreatePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const errorMessage = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new ErrorCreatePasskey(errorMessage);
  },
  write(writer: CborWriter, value: ErrorCreatePasskey): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.errorMessage);
    writer.writeEndArray();
  }
});



export abstract class IValidatePasskeyResult implements IIonUnion<IValidatePasskeyResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessValidatePasskey(): this is SuccessValidatePasskey {
    return this.UnionKey === "SuccessValidatePasskey";
  }
  public isErrorValidatePasskey(): this is ErrorValidatePasskey {
    return this.UnionKey === "ErrorValidatePasskey";
  }

}


export class SuccessValidatePasskey extends IValidatePasskeyResult
{
  constructor(public credentialId: string, public signature: string, public authenticatorData: string, public clientDataJSON: string) { super(); }

  UnionKey: string = "SuccessValidatePasskey";
  UnionIndex: number = 0;
}

export class ErrorValidatePasskey extends IValidatePasskeyResult
{
  constructor(public errorMessage: string) { super(); }

  UnionKey: string = "ErrorValidatePasskey";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IValidatePasskeyResult", {
  read(reader: CborReader): IValidatePasskeyResult {
    reader.readStartArray();
    let value: IValidatePasskeyResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessValidatePasskey>("SuccessValidatePasskey").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<ErrorValidatePasskey>("ErrorValidatePasskey").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IValidatePasskeyResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessValidatePasskey>("SuccessValidatePasskey").write(writer, value as SuccessValidatePasskey);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<ErrorValidatePasskey>("ErrorValidatePasskey").write(writer, value as ErrorValidatePasskey);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessValidatePasskey", {
  read(reader: CborReader): SuccessValidatePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const credentialId = IonFormatterStorage.get<string>('string').read(reader);
    const signature = IonFormatterStorage.get<string>('string').read(reader);
    const authenticatorData = IonFormatterStorage.get<string>('string').read(reader);
    const clientDataJSON = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new SuccessValidatePasskey(credentialId, signature, authenticatorData, clientDataJSON);
  },
  write(writer: CborWriter, value: SuccessValidatePasskey): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<string>('string').write(writer, value.credentialId);
    IonFormatterStorage.get<string>('string').write(writer, value.signature);
    IonFormatterStorage.get<string>('string').write(writer, value.authenticatorData);
    IonFormatterStorage.get<string>('string').write(writer, value.clientDataJSON);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ErrorValidatePasskey", {
  read(reader: CborReader): ErrorValidatePasskey {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const errorMessage = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new ErrorValidatePasskey(errorMessage);
  },
  write(writer: CborWriter, value: ErrorValidatePasskey): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.errorMessage);
    writer.writeEndArray();
  }
});



export abstract class INativeEvent implements IIonUnion<INativeEvent>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isAudioPlaying(): this is AudioPlaying {
    return this.UnionKey === "AudioPlaying";
  }
  public isAudioPlayingEnd(): this is AudioPlayingEnd {
    return this.UnionKey === "AudioPlayingEnd";
  }
  public isProcessPlaying(): this is ProcessPlaying {
    return this.UnionKey === "ProcessPlaying";
  }
  public isProcessEnd(): this is ProcessEnd {
    return this.UnionKey === "ProcessEnd";
  }
  public isActivityLog(): this is ActivityLog {
    return this.UnionKey === "ActivityLog";
  }
  public isHotKeyTriggered(): this is HotKeyTriggered {
    return this.UnionKey === "HotKeyTriggered";
  }
  public isOverlayStarted(): this is OverlayStarted {
    return this.UnionKey === "OverlayStarted";
  }
  public isOverlayEnded(): this is OverlayEnded {
    return this.UnionKey === "OverlayEnded";
  }

}


export class AudioPlaying extends INativeEvent
{
  constructor(public sessionId: string, public titleName: string, public author: string) { super(); }

  UnionKey: string = "AudioPlaying";
  UnionIndex: number = 0;
}

export class AudioPlayingEnd extends INativeEvent
{
  constructor(public sessionId: string) { super(); }

  UnionKey: string = "AudioPlayingEnd";
  UnionIndex: number = 1;
}

export class ProcessPlaying extends INativeEvent
{
  constructor(public appIcon: string, public name: string, public pid: i4, public hash: string, public kind: i4) { super(); }

  UnionKey: string = "ProcessPlaying";
  UnionIndex: number = 2;
}

export class ProcessEnd extends INativeEvent
{
  constructor(public pid: i4) { super(); }

  UnionKey: string = "ProcessEnd";
  UnionIndex: number = 3;
}

export class ActivityLog extends INativeEvent
{
  constructor(public logLevel: i4, public text: string, public args: IonArray<string>, public time: datetime) { super(); }

  UnionKey: string = "ActivityLog";
  UnionIndex: number = 4;
}

export class HotKeyTriggered extends INativeEvent
{
  constructor(public hotkeyId: string, public phase: HotkeyPhase) { super(); }

  UnionKey: string = "HotKeyTriggered";
  UnionIndex: number = 5;
}

export class OverlayStarted extends INativeEvent
{
  constructor(public sessionId: string, public pid: i4, public kind: OverlayKind) { super(); }

  UnionKey: string = "OverlayStarted";
  UnionIndex: number = 6;
}

export class OverlayEnded extends INativeEvent
{
  constructor(public sessionId: string, public pid: i4, public kind: OverlayKind) { super(); }

  UnionKey: string = "OverlayEnded";
  UnionIndex: number = 7;
}



IonFormatterStorage.register("INativeEvent", {
  read(reader: CborReader): INativeEvent {
    reader.readStartArray();
    let value: INativeEvent = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<AudioPlaying>("AudioPlaying").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<AudioPlayingEnd>("AudioPlayingEnd").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<ProcessPlaying>("ProcessPlaying").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<ProcessEnd>("ProcessEnd").read(reader);
    else if (unionIndex == 4)
      value = IonFormatterStorage.get<ActivityLog>("ActivityLog").read(reader);
    else if (unionIndex == 5)
      value = IonFormatterStorage.get<HotKeyTriggered>("HotKeyTriggered").read(reader);
    else if (unionIndex == 6)
      value = IonFormatterStorage.get<OverlayStarted>("OverlayStarted").read(reader);
    else if (unionIndex == 7)
      value = IonFormatterStorage.get<OverlayEnded>("OverlayEnded").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: INativeEvent): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<AudioPlaying>("AudioPlaying").write(writer, value as AudioPlaying);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<AudioPlayingEnd>("AudioPlayingEnd").write(writer, value as AudioPlayingEnd);
    }
    else if (value.UnionIndex == 2) {
        IonFormatterStorage.get<ProcessPlaying>("ProcessPlaying").write(writer, value as ProcessPlaying);
    }
    else if (value.UnionIndex == 3) {
        IonFormatterStorage.get<ProcessEnd>("ProcessEnd").write(writer, value as ProcessEnd);
    }
    else if (value.UnionIndex == 4) {
        IonFormatterStorage.get<ActivityLog>("ActivityLog").write(writer, value as ActivityLog);
    }
    else if (value.UnionIndex == 5) {
        IonFormatterStorage.get<HotKeyTriggered>("HotKeyTriggered").write(writer, value as HotKeyTriggered);
    }
    else if (value.UnionIndex == 6) {
        IonFormatterStorage.get<OverlayStarted>("OverlayStarted").write(writer, value as OverlayStarted);
    }
    else if (value.UnionIndex == 7) {
        IonFormatterStorage.get<OverlayEnded>("OverlayEnded").write(writer, value as OverlayEnded);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("AudioPlaying", {
  read(reader: CborReader): AudioPlaying {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const sessionId = IonFormatterStorage.get<string>('string').read(reader);
    const titleName = IonFormatterStorage.get<string>('string').read(reader);
    const author = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new AudioPlaying(sessionId, titleName, author);
  },
  write(writer: CborWriter, value: AudioPlaying): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.sessionId);
    IonFormatterStorage.get<string>('string').write(writer, value.titleName);
    IonFormatterStorage.get<string>('string').write(writer, value.author);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("AudioPlayingEnd", {
  read(reader: CborReader): AudioPlayingEnd {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const sessionId = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new AudioPlayingEnd(sessionId);
  },
  write(writer: CborWriter, value: AudioPlayingEnd): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.sessionId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ProcessPlaying", {
  read(reader: CborReader): ProcessPlaying {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const appIcon = IonFormatterStorage.get<string>('string').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const pid = IonFormatterStorage.get<i4>('i4').read(reader);
    const hash = IonFormatterStorage.get<string>('string').read(reader);
    const kind = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new ProcessPlaying(appIcon, name, pid, hash, kind);
  },
  write(writer: CborWriter, value: ProcessPlaying): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<string>('string').write(writer, value.appIcon);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<i4>('i4').write(writer, value.pid);
    IonFormatterStorage.get<string>('string').write(writer, value.hash);
    IonFormatterStorage.get<i4>('i4').write(writer, value.kind);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ProcessEnd", {
  read(reader: CborReader): ProcessEnd {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const pid = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new ProcessEnd(pid);
  },
  write(writer: CborWriter, value: ProcessEnd): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<i4>('i4').write(writer, value.pid);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ActivityLog", {
  read(reader: CborReader): ActivityLog {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const logLevel = IonFormatterStorage.get<i4>('i4').read(reader);
    const text = IonFormatterStorage.get<string>('string').read(reader);
    const args = IonFormatterStorage.readArray<string>(reader, 'string');
    const time = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new ActivityLog(logLevel, text, args, time);
  },
  write(writer: CborWriter, value: ActivityLog): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<i4>('i4').write(writer, value.logLevel);
    IonFormatterStorage.get<string>('string').write(writer, value.text);
    IonFormatterStorage.writeArray<string>(writer, value.args, 'string');
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.time);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("HotKeyTriggered", {
  read(reader: CborReader): HotKeyTriggered {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const hotkeyId = IonFormatterStorage.get<string>('string').read(reader);
    const phase = IonFormatterStorage.get<HotkeyPhase>('HotkeyPhase').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new HotKeyTriggered(hotkeyId, phase);
  },
  write(writer: CborWriter, value: HotKeyTriggered): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.hotkeyId);
    IonFormatterStorage.get<HotkeyPhase>('HotkeyPhase').write(writer, value.phase);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("OverlayStarted", {
  read(reader: CborReader): OverlayStarted {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const sessionId = IonFormatterStorage.get<string>('string').read(reader);
    const pid = IonFormatterStorage.get<i4>('i4').read(reader);
    const kind = IonFormatterStorage.get<OverlayKind>('OverlayKind').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new OverlayStarted(sessionId, pid, kind);
  },
  write(writer: CborWriter, value: OverlayStarted): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.sessionId);
    IonFormatterStorage.get<i4>('i4').write(writer, value.pid);
    IonFormatterStorage.get<OverlayKind>('OverlayKind').write(writer, value.kind);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("OverlayEnded", {
  read(reader: CborReader): OverlayEnded {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const sessionId = IonFormatterStorage.get<string>('string').read(reader);
    const pid = IonFormatterStorage.get<i4>('i4').read(reader);
    const kind = IonFormatterStorage.get<OverlayKind>('OverlayKind').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new OverlayEnded(sessionId, pid, kind);
  },
  write(writer: CborWriter, value: OverlayEnded): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.sessionId);
    IonFormatterStorage.get<i4>('i4').write(writer, value.pid);
    IonFormatterStorage.get<OverlayKind>('OverlayKind').write(writer, value.kind);
    writer.writeEndArray();
  }
});



IonFormatterStorage.register("PasskeyUser", {
  read(reader: CborReader): PasskeyUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<string>('string').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const displayName = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { id, name, displayName };
  },
  write(writer: CborWriter, value: PasskeyUser): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.id);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<string>('string').write(writer, value.displayName);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("PasskeyCredential", {
  read(reader: CborReader): PasskeyCredential {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<string>('string').read(reader);
    const publicKey = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { id, publicKey };
  },
  write(writer: CborWriter, value: PasskeyCredential): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.id);
    IonFormatterStorage.get<string>('string').write(writer, value.publicKey);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("IceServerCred", {
  read(reader: CborReader): IceServerCred {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const url = IonFormatterStorage.get<string>('string').read(reader);
    const pass = IonFormatterStorage.get<string>('string').read(reader);
    const user = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { url, pass, user };
  },
  write(writer: CborWriter, value: IceServerCred): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.url);
    IonFormatterStorage.get<string>('string').write(writer, value.pass);
    IonFormatterStorage.get<string>('string').write(writer, value.user);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("StreamBegin", {
  read(reader: CborReader): StreamBegin {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const whipUrl = IonFormatterStorage.get<string>('string').read(reader);
    const iceServers = IonFormatterStorage.readArray<IceServerCred>(reader, 'IceServerCred');
    const outputIndex = IonFormatterStorage.get<i4>('i4').read(reader);
    const fps = IonFormatterStorage.get<i4>('i4').read(reader);
    const targetWidth = IonFormatterStorage.get<i4>('i4').read(reader);
    const targetHeight = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 6);
    return { whipUrl, iceServers, outputIndex, fps, targetWidth, targetHeight };
  },
  write(writer: CborWriter, value: StreamBegin): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<string>('string').write(writer, value.whipUrl);
    IonFormatterStorage.writeArray<IceServerCred>(writer, value.iceServers, 'IceServerCred');
    IonFormatterStorage.get<i4>('i4').write(writer, value.outputIndex);
    IonFormatterStorage.get<i4>('i4').write(writer, value.fps);
    IonFormatterStorage.get<i4>('i4').write(writer, value.targetWidth);
    IonFormatterStorage.get<i4>('i4').write(writer, value.targetHeight);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SetResult", {
  read(reader: CborReader): SetResult {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const value = IonFormatterStorage.readNullable<ConfigKeyMetadata_Value>(reader, 'ConfigKeyMetadata_Value');
    reader.readEndArrayAndSkip(arraySize - 1);
    return { value };
  },
  write(writer: CborWriter, value: SetResult): void {
    writer.writeStartArray(1);
    IonFormatterStorage.writeNullable<ConfigKeyMetadata_Value>(writer, value.value, 'ConfigKeyMetadata_Value');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ActivityLogLevel", {
  read(reader: CborReader): ActivityLogLevel {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return ActivityLogLevel[num] !== undefined ? num as ActivityLogLevel : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: ActivityLogLevel): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("ActivityLogEntity", {
  read(reader: CborReader): ActivityLogEntity {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const logLevel = IonFormatterStorage.get<ActivityLogLevel>('ActivityLogLevel').read(reader);
    const template = IonFormatterStorage.get<string>('string').read(reader);
    const args = IonFormatterStorage.readArray<string>(reader, 'string');
    const time = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return { logLevel, template, args, time };
  },
  write(writer: CborWriter, value: ActivityLogEntity): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<ActivityLogLevel>('ActivityLogLevel').write(writer, value.logLevel);
    IonFormatterStorage.get<string>('string').write(writer, value.template);
    IonFormatterStorage.writeArray<string>(writer, value.args, 'string');
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.time);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("StorageInfo", {
  read(reader: CborReader): StorageInfo {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const totalSize = IonFormatterStorage.get<string>('string').read(reader);
    const availableFreeSpace = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { totalSize, availableFreeSpace };
  },
  write(writer: CborWriter, value: StorageInfo): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.totalSize);
    IonFormatterStorage.get<string>('string').write(writer, value.availableFreeSpace);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("Screen", {
  read(reader: CborReader): Screen {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const displayIndex = IonFormatterStorage.get<i4>('i4').read(reader);
    const width = IonFormatterStorage.get<i4>('i4').read(reader);
    const height = IonFormatterStorage.get<i4>('i4').read(reader);
    const left = IonFormatterStorage.get<i4>('i4').read(reader);
    const top = IonFormatterStorage.get<i4>('i4').read(reader);
    const isPrimary = IonFormatterStorage.get<bool>('bool').read(reader);
    const freq = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 7);
    return { displayIndex, width, height, left, top, isPrimary, freq };
  },
  write(writer: CborWriter, value: Screen): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<i4>('i4').write(writer, value.displayIndex);
    IonFormatterStorage.get<i4>('i4').write(writer, value.width);
    IonFormatterStorage.get<i4>('i4').write(writer, value.height);
    IonFormatterStorage.get<i4>('i4').write(writer, value.left);
    IonFormatterStorage.get<i4>('i4').write(writer, value.top);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isPrimary);
    IonFormatterStorage.get<i4>('i4').write(writer, value.freq);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("WindowInfo", {
  read(reader: CborReader): WindowInfo {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const deviceId = IonFormatterStorage.get<string>('string').read(reader);
    const title = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { deviceId, title };
  },
  write(writer: CborWriter, value: WindowInfo): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.deviceId);
    IonFormatterStorage.get<string>('string').write(writer, value.title);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("PinnedFn", {
  read(reader: CborReader): PinnedFn {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return { id };
  },
  write(writer: CborWriter, value: PinnedFn): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<i4>('i4').write(writer, value.id);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ConfigPrimitiveType", {
  read(reader: CborReader): ConfigPrimitiveType {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return ConfigPrimitiveType[num] !== undefined ? num as ConfigPrimitiveType : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: ConfigPrimitiveType): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("ConfigKeyMetadata", {
  read(reader: CborReader): ConfigKeyMetadata {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const key = IonFormatterStorage.get<string>('string').read(reader);
    const type = IonFormatterStorage.get<ConfigPrimitiveType>('ConfigPrimitiveType').read(reader);
    const requiredToRestartApp = IonFormatterStorage.get<bool>('bool').read(reader);
    const onlyForDevMode = IonFormatterStorage.get<bool>('bool').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return { key, type, requiredToRestartApp, onlyForDevMode };
  },
  write(writer: CborWriter, value: ConfigKeyMetadata): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<string>('string').write(writer, value.key);
    IonFormatterStorage.get<ConfigPrimitiveType>('ConfigPrimitiveType').write(writer, value.type);
    IonFormatterStorage.get<bool>('bool').write(writer, value.requiredToRestartApp);
    IonFormatterStorage.get<bool>('bool').write(writer, value.onlyForDevMode);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ConfigSectionMetadata", {
  read(reader: CborReader): ConfigSectionMetadata {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const section = IonFormatterStorage.get<string>('string').read(reader);
    const keys = IonFormatterStorage.readArray<ConfigKeyMetadata>(reader, 'ConfigKeyMetadata');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { section, keys };
  },
  write(writer: CborWriter, value: ConfigSectionMetadata): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.section);
    IonFormatterStorage.writeArray<ConfigKeyMetadata>(writer, value.keys, 'ConfigKeyMetadata');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SetRequest", {
  read(reader: CborReader): SetRequest {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const key = IonFormatterStorage.get<string>('string').read(reader);
    const section = IonFormatterStorage.get<string>('string').read(reader);
    const valueB = IonFormatterStorage.readNullable<bool>(reader, 'bool');
    const valueStr = IonFormatterStorage.readNullable<string>(reader, 'string');
    const valueNum = IonFormatterStorage.readNullable<i8>(reader, 'i8');
    const valueEnum = IonFormatterStorage.readNullable<string>(reader, 'string');
    const valueF = IonFormatterStorage.readNullable<f8>(reader, 'f8');
    reader.readEndArrayAndSkip(arraySize - 7);
    return { key, section, valueB, valueStr, valueNum, valueEnum, valueF };
  },
  write(writer: CborWriter, value: SetRequest): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<string>('string').write(writer, value.key);
    IonFormatterStorage.get<string>('string').write(writer, value.section);
    IonFormatterStorage.writeNullable<bool>(writer, value.valueB, 'bool');
    IonFormatterStorage.writeNullable<string>(writer, value.valueStr, 'string');
    IonFormatterStorage.writeNullable<i8>(writer, value.valueNum, 'i8');
    IonFormatterStorage.writeNullable<string>(writer, value.valueEnum, 'string');
    IonFormatterStorage.writeNullable<f8>(writer, value.valueF, 'f8');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ConfigSectionMetadata_Value", {
  read(reader: CborReader): ConfigSectionMetadata_Value {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const section = IonFormatterStorage.get<string>('string').read(reader);
    const keys = IonFormatterStorage.readArray<ConfigKeyMetadata_Value>(reader, 'ConfigKeyMetadata_Value');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { section, keys };
  },
  write(writer: CborWriter, value: ConfigSectionMetadata_Value): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.section);
    IonFormatterStorage.writeArray<ConfigKeyMetadata_Value>(writer, value.keys, 'ConfigKeyMetadata_Value');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ConfigKeyMetadata_Value", {
  read(reader: CborReader): ConfigKeyMetadata_Value {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const key = IonFormatterStorage.get<string>('string').read(reader);
    const type = IonFormatterStorage.get<ConfigPrimitiveType>('ConfigPrimitiveType').read(reader);
    const requiredToRestartApp = IonFormatterStorage.get<bool>('bool').read(reader);
    const onlyForDevMode = IonFormatterStorage.get<bool>('bool').read(reader);
    const valueB = IonFormatterStorage.readNullable<bool>(reader, 'bool');
    const valueStr = IonFormatterStorage.readNullable<string>(reader, 'string');
    const valueNum = IonFormatterStorage.readNullable<i8>(reader, 'i8');
    const valueEnum = IonFormatterStorage.readNullable<string>(reader, 'string');
    const valueEnumVariants = IonFormatterStorage.readArray<string>(reader, 'string');
    const valueF = IonFormatterStorage.readNullable<f8>(reader, 'f8');
    reader.readEndArrayAndSkip(arraySize - 10);
    return { key, type, requiredToRestartApp, onlyForDevMode, valueB, valueStr, valueNum, valueEnum, valueEnumVariants, valueF };
  },
  write(writer: CborWriter, value: ConfigKeyMetadata_Value): void {
    writer.writeStartArray(10);
    IonFormatterStorage.get<string>('string').write(writer, value.key);
    IonFormatterStorage.get<ConfigPrimitiveType>('ConfigPrimitiveType').write(writer, value.type);
    IonFormatterStorage.get<bool>('bool').write(writer, value.requiredToRestartApp);
    IonFormatterStorage.get<bool>('bool').write(writer, value.onlyForDevMode);
    IonFormatterStorage.writeNullable<bool>(writer, value.valueB, 'bool');
    IonFormatterStorage.writeNullable<string>(writer, value.valueStr, 'string');
    IonFormatterStorage.writeNullable<i8>(writer, value.valueNum, 'i8');
    IonFormatterStorage.writeNullable<string>(writer, value.valueEnum, 'string');
    IonFormatterStorage.writeArray<string>(writer, value.valueEnumVariants, 'string');
    IonFormatterStorage.writeNullable<f8>(writer, value.valueF, 'f8');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("HotkeyDevice", {
  read(reader: CborReader): HotkeyDevice {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return HotkeyDevice[num] !== undefined ? num as HotkeyDevice : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: HotkeyDevice): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("HotkeyButton", {
  read(reader: CborReader): HotkeyButton {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const device = IonFormatterStorage.get<HotkeyDevice>('HotkeyDevice').read(reader);
    const code = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { device, code };
  },
  write(writer: CborWriter, value: HotkeyButton): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<HotkeyDevice>('HotkeyDevice').write(writer, value.device);
    IonFormatterStorage.get<i4>('i4').write(writer, value.code);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("HotkeyChord", {
  read(reader: CborReader): HotkeyChord {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const buttons = IonFormatterStorage.readArray<HotkeyButton>(reader, 'HotkeyButton');
    reader.readEndArrayAndSkip(arraySize - 1);
    return { buttons };
  },
  write(writer: CborWriter, value: HotkeyChord): void {
    writer.writeStartArray(1);
    IonFormatterStorage.writeArray<HotkeyButton>(writer, value.buttons, 'HotkeyButton');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("HotkeyActionType", {
  read(reader: CborReader): HotkeyActionType {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return HotkeyActionType[num] !== undefined ? num as HotkeyActionType : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: HotkeyActionType): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("HotkeyDescriptor", {
  read(reader: CborReader): HotkeyDescriptor {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<string>('string').read(reader);
    const chord = IonFormatterStorage.get<HotkeyChord>('HotkeyChord').read(reader);
    const action = IonFormatterStorage.get<HotkeyActionType>('HotkeyActionType').read(reader);
    const suppress = IonFormatterStorage.get<bool>('bool').read(reader);
    const triggerCooldownMs = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return { id, chord, action, suppress, triggerCooldownMs };
  },
  write(writer: CborWriter, value: HotkeyDescriptor): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<string>('string').write(writer, value.id);
    IonFormatterStorage.get<HotkeyChord>('HotkeyChord').write(writer, value.chord);
    IonFormatterStorage.get<HotkeyActionType>('HotkeyActionType').write(writer, value.action);
    IonFormatterStorage.get<bool>('bool').write(writer, value.suppress);
    IonFormatterStorage.get<i4>('i4').write(writer, value.triggerCooldownMs);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("HotkeyPhase", {
  read(reader: CborReader): HotkeyPhase {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return HotkeyPhase[num] !== undefined ? num as HotkeyPhase : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: HotkeyPhase): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("HotkeyEvent", {
  read(reader: CborReader): HotkeyEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const hotkeyId = IonFormatterStorage.get<string>('string').read(reader);
    const phase = IonFormatterStorage.get<HotkeyPhase>('HotkeyPhase').read(reader);
    const timestamp = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { hotkeyId, phase, timestamp };
  },
  write(writer: CborWriter, value: HotkeyEvent): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.hotkeyId);
    IonFormatterStorage.get<HotkeyPhase>('HotkeyPhase').write(writer, value.phase);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.timestamp);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ActivityKind", {
  read(reader: CborReader): ActivityKind {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return ActivityKind[num] !== undefined ? num as ActivityKind : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: ActivityKind): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("Channel", {
  read(reader: CborReader): Channel {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return Channel[num] !== undefined ? num as Channel : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: Channel): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("HostKind", {
  read(reader: CborReader): HostKind {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return HostKind[num] !== undefined ? num as HostKind : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: HostKind): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("OverlayKind", {
  read(reader: CborReader): OverlayKind {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return OverlayKind[num] !== undefined ? num as OverlayKind : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: OverlayKind): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("InitCfg", {
  read(reader: CborReader): InitCfg {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const width = IonFormatterStorage.get<i4>('i4').read(reader);
    const height = IonFormatterStorage.get<i4>('i4').read(reader);
    const tileSize = IonFormatterStorage.get<i4>('i4').read(reader);
    const tilesX = IonFormatterStorage.get<i4>('i4').read(reader);
    const tilesY = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return { width, height, tileSize, tilesX, tilesY };
  },
  write(writer: CborWriter, value: InitCfg): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<i4>('i4').write(writer, value.width);
    IonFormatterStorage.get<i4>('i4').write(writer, value.height);
    IonFormatterStorage.get<i4>('i4').write(writer, value.tileSize);
    IonFormatterStorage.get<i4>('i4').write(writer, value.tilesX);
    IonFormatterStorage.get<i4>('i4').write(writer, value.tilesY);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FrameData", {
  read(reader: CborReader): FrameData {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const timestamp = IonFormatterStorage.get<i4>('i4').read(reader);
    const width = IonFormatterStorage.get<i4>('i4').read(reader);
    const height = IonFormatterStorage.get<i4>('i4').read(reader);
    const tiles = IonFormatterStorage.readArray<BridgeDirtyTile>(reader, 'BridgeDirtyTile');
    reader.readEndArrayAndSkip(arraySize - 4);
    return { timestamp, width, height, tiles };
  },
  write(writer: CborWriter, value: FrameData): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<i4>('i4').write(writer, value.timestamp);
    IonFormatterStorage.get<i4>('i4').write(writer, value.width);
    IonFormatterStorage.get<i4>('i4').write(writer, value.height);
    IonFormatterStorage.writeArray<BridgeDirtyTile>(writer, value.tiles, 'BridgeDirtyTile');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FrameDataDelta", {
  read(reader: CborReader): FrameDataDelta {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const timestamp = IonFormatterStorage.get<i4>('i4').read(reader);
    const tiles = IonFormatterStorage.readArray<BridgeDirtyTile>(reader, 'BridgeDirtyTile');
    const skippedTransparent = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { timestamp, tiles, skippedTransparent };
  },
  write(writer: CborWriter, value: FrameDataDelta): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<i4>('i4').write(writer, value.timestamp);
    IonFormatterStorage.writeArray<BridgeDirtyTile>(writer, value.tiles, 'BridgeDirtyTile');
    IonFormatterStorage.get<i4>('i4').write(writer, value.skippedTransparent);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("OverlayStats", {
  read(reader: CborReader): OverlayStats {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const fps = IonFormatterStorage.get<i4>('i4').read(reader);
    const captureTimeMs = IonFormatterStorage.get<i4>('i4').read(reader);
    const bytesThisFrame = IonFormatterStorage.get<i4>('i4').read(reader);
    const tileCount = IonFormatterStorage.get<i4>('i4').read(reader);
    const transparentSkipped = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return { fps, captureTimeMs, bytesThisFrame, tileCount, transparentSkipped };
  },
  write(writer: CborWriter, value: OverlayStats): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<i4>('i4').write(writer, value.fps);
    IonFormatterStorage.get<i4>('i4').write(writer, value.captureTimeMs);
    IonFormatterStorage.get<i4>('i4').write(writer, value.bytesThisFrame);
    IonFormatterStorage.get<i4>('i4').write(writer, value.tileCount);
    IonFormatterStorage.get<i4>('i4').write(writer, value.transparentSkipped);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("BridgeDirtyTile", {
  read(reader: CborReader): BridgeDirtyTile {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const tx = IonFormatterStorage.get<i4>('i4').read(reader);
    const ty = IonFormatterStorage.get<i4>('i4').read(reader);
    const x = IonFormatterStorage.get<i4>('i4').read(reader);
    const y = IonFormatterStorage.get<i4>('i4').read(reader);
    const w = IonFormatterStorage.get<i4>('i4').read(reader);
    const h = IonFormatterStorage.get<i4>('i4').read(reader);
    const data = IonFormatterStorage.get<bytes>('bytes').read(reader);
    reader.readEndArrayAndSkip(arraySize - 7);
    return { tx, ty, x, y, w, h, data };
  },
  write(writer: CborWriter, value: BridgeDirtyTile): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<i4>('i4').write(writer, value.tx);
    IonFormatterStorage.get<i4>('i4').write(writer, value.ty);
    IonFormatterStorage.get<i4>('i4').write(writer, value.x);
    IonFormatterStorage.get<i4>('i4').write(writer, value.y);
    IonFormatterStorage.get<i4>('i4').write(writer, value.w);
    IonFormatterStorage.get<i4>('i4').write(writer, value.h);
    IonFormatterStorage.get<bytes>('bytes').write(writer, value.data);
    writer.writeEndArray();
  }
});



export interface IHostProc extends IIonService
{
  listenSessionMusic(): Promise<bool>;
  listenActivity(): Promise<bool>;
  allocatePinnedFn(name: string): Promise<PinnedFn>;
  onGameActivityDetected(fn: PinnedFn): Promise<bool>;
  onGameActivityTerminated(fn: PinnedFn): Promise<bool>;
  onMusicSessionPlayStateChanged(fn: PinnedFn): Promise<bool>;
  onMusicSessionStopStateChanged(fn: PinnedFn): Promise<bool>;
  dsn(): Promise<string>;
  getHostKind(): Promise<HostKind>;
  getDisplays(): Promise<IonArray<Screen>>;
  getHWNDs(): Promise<IonArray<WindowInfo>>;
  allocConsole(): Promise<bool>;
  toggleDevTools(): Promise<bool>;
  getCurrentChannel(): Promise<Channel>;
  setCurrentChannel(c: Channel): Promise<void>;
  getIdleTimeSeconds(): Promise<i4>;
  openUrl(url: string): Promise<bool>;
  clipboardRead(): Promise<string>;
  clipboardWrite(val: string): Promise<bool>;
  renderDiagnostic(i: i4): Promise<bool>;
  getStorageSpace(): Promise<StorageInfo>;
  getActivityDiagnostic(activityKind: ActivityKind, limit: i4, offset: i4, search: string | null): Promise<IonArray<ActivityLogEntity>>;
  getConfig(): Promise<IonArray<ConfigSectionMetadata_Value>>;
  setConfigValue(set: SetRequest): Promise<SetResult>;
  hotkeyRegister(desc: HotkeyDescriptor): Promise<void>;
  hotkeyUnregister(id: string): Promise<void>;
  hotkeyCaptureOnce(): Promise<HotkeyChord>;
  hotkeyPause(): Promise<void>;
  hotkeyResume(): Promise<void>;
  hotkeyFired(fn: PinnedFn): Promise<bool>;
  startStreaming(parameters: StreamBegin): Promise<void>;
  createPasskey(passkeyId: string, challenge: string, user: PasskeyUser, rpName: string, rpId: string): Promise<ICreatePasskeyResult>;
  validatePasskey(challenge: string, allowedCredentials: IonArray<PasskeyCredential>, rpId: string): Promise<IValidatePasskeyResult>;
  startSharedTextureWithStreamingByMonitor(displayIndex: i4, textureWidth: i4, textureHeight: i4): Promise<string>;
}




export interface IOverlayController extends IIonService
{
  init(cfg: InitCfg): Promise<void>;
  sendFullFrame(frame: FrameData): Promise<void>;
  sendDelta(deltaFrame: FrameDataDelta): Promise<void>;
  clear(): Promise<void>;
  resize(width: i4, height: i4, tileSize: i4, tilesX: i4, tilesY: i4): Promise<void>;
  sendStats(stats: OverlayStats): Promise<void>;
  dispose(): Promise<void>;
}




export interface IHostProc extends IIonService
{
  listenSessionMusic(): Promise<bool>;
  listenActivity(): Promise<bool>;
  allocatePinnedFn(name: string): Promise<PinnedFn>;
  onGameActivityDetected(fn: PinnedFn): Promise<bool>;
  onGameActivityTerminated(fn: PinnedFn): Promise<bool>;
  onMusicSessionPlayStateChanged(fn: PinnedFn): Promise<bool>;
  onMusicSessionStopStateChanged(fn: PinnedFn): Promise<bool>;
  dsn(): Promise<string>;
  getHostKind(): Promise<HostKind>;
  getDisplays(): Promise<IonArray<Screen>>;
  getHWNDs(): Promise<IonArray<WindowInfo>>;
  allocConsole(): Promise<bool>;
  toggleDevTools(): Promise<bool>;
  getCurrentChannel(): Promise<Channel>;
  setCurrentChannel(c: Channel): Promise<void>;
  getIdleTimeSeconds(): Promise<i4>;
  openUrl(url: string): Promise<bool>;
  clipboardRead(): Promise<string>;
  clipboardWrite(val: string): Promise<bool>;
  renderDiagnostic(i: i4): Promise<bool>;
  getStorageSpace(): Promise<StorageInfo>;
  getActivityDiagnostic(activityKind: ActivityKind, limit: i4, offset: i4, search: string | null): Promise<IonArray<ActivityLogEntity>>;
  getConfig(): Promise<IonArray<ConfigSectionMetadata_Value>>;
  setConfigValue(set: SetRequest): Promise<SetResult>;
  hotkeyRegister(desc: HotkeyDescriptor): Promise<void>;
  hotkeyUnregister(id: string): Promise<void>;
  hotkeyCaptureOnce(): Promise<HotkeyChord>;
  hotkeyPause(): Promise<void>;
  hotkeyResume(): Promise<void>;
  hotkeyFired(fn: PinnedFn): Promise<bool>;
  startStreaming(parameters: StreamBegin): Promise<void>;
  createPasskey(passkeyId: string, challenge: string, user: PasskeyUser, rpName: string, rpId: string): Promise<ICreatePasskeyResult>;
  validatePasskey(challenge: string, allowedCredentials: IonArray<PasskeyCredential>, rpId: string): Promise<IValidatePasskeyResult>;
  startSharedTextureWithStreamingByMonitor(displayIndex: i4, textureWidth: i4, textureHeight: i4): Promise<string>;
}




export interface IOverlayController extends IIonService
{
  init(cfg: InitCfg): Promise<void>;
  sendFullFrame(frame: FrameData): Promise<void>;
  sendDelta(deltaFrame: FrameDataDelta): Promise<void>;
  clear(): Promise<void>;
  resize(width: i4, height: i4, tileSize: i4, tilesX: i4, tilesY: i4): Promise<void>;
  sendStats(stats: OverlayStats): Promise<void>;
  dispose(): Promise<void>;
}



//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------

export class HostProc_Executor extends ServiceExecutor<IHostProc> implements IHostProc {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async listenSessionMusic(): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "listenSessionMusic");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async listenActivity(): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "listenActivity");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async allocatePinnedFn(name: string): Promise<PinnedFn> {
    const req = new IonRequest(this.ctx, "IHostProc", "allocatePinnedFn");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, name);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<PinnedFn>("PinnedFn", writer.data, this.signal);
  }
  async onGameActivityDetected(fn: PinnedFn): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "onGameActivityDetected");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<PinnedFn>('PinnedFn').write(writer, fn);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async onGameActivityTerminated(fn: PinnedFn): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "onGameActivityTerminated");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<PinnedFn>('PinnedFn').write(writer, fn);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async onMusicSessionPlayStateChanged(fn: PinnedFn): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "onMusicSessionPlayStateChanged");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<PinnedFn>('PinnedFn').write(writer, fn);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async onMusicSessionStopStateChanged(fn: PinnedFn): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "onMusicSessionStopStateChanged");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<PinnedFn>('PinnedFn').write(writer, fn);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async dsn(): Promise<string> {
    const req = new IonRequest(this.ctx, "IHostProc", "dsn");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async getHostKind(): Promise<HostKind> {
    const req = new IonRequest(this.ctx, "IHostProc", "getHostKind");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<HostKind>("HostKind", writer.data, this.signal);
  }
  async getDisplays(): Promise<IonArray<Screen>> {
    const req = new IonRequest(this.ctx, "IHostProc", "getDisplays");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Screen>>("IonArray<Screen>", writer.data, this.signal);
  }
  async getHWNDs(): Promise<IonArray<WindowInfo>> {
    const req = new IonRequest(this.ctx, "IHostProc", "getHWNDs");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<WindowInfo>>("IonArray<WindowInfo>", writer.data, this.signal);
  }
  async allocConsole(): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "allocConsole");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async toggleDevTools(): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "toggleDevTools");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async getCurrentChannel(): Promise<Channel> {
    const req = new IonRequest(this.ctx, "IHostProc", "getCurrentChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<Channel>("Channel", writer.data, this.signal);
  }
  async setCurrentChannel(c: Channel): Promise<void> {
    const req = new IonRequest(this.ctx, "IHostProc", "setCurrentChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<Channel>('Channel').write(writer, c);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async getIdleTimeSeconds(): Promise<i4> {
    const req = new IonRequest(this.ctx, "IHostProc", "getIdleTimeSeconds");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<i4>("i4", writer.data, this.signal);
  }
  async openUrl(url: string): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "openUrl");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, url);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async clipboardRead(): Promise<string> {
    const req = new IonRequest(this.ctx, "IHostProc", "clipboardRead");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async clipboardWrite(val: string): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "clipboardWrite");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, val);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async renderDiagnostic(i: i4): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "renderDiagnostic");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<i4>('i4').write(writer, i);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async getStorageSpace(): Promise<StorageInfo> {
    const req = new IonRequest(this.ctx, "IHostProc", "getStorageSpace");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<StorageInfo>("StorageInfo", writer.data, this.signal);
  }
  async getActivityDiagnostic(activityKind: ActivityKind, limit: i4, offset: i4, search: string | null): Promise<IonArray<ActivityLogEntity>> {
    const req = new IonRequest(this.ctx, "IHostProc", "getActivityDiagnostic");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<ActivityKind>('ActivityKind').write(writer, activityKind);
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
    IonFormatterStorage.get<i4>('i4').write(writer, offset);
    IonFormatterStorage.writeNullable<string>(writer, search, 'string');
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ActivityLogEntity>>("IonArray<ActivityLogEntity>", writer.data, this.signal);
  }
  async getConfig(): Promise<IonArray<ConfigSectionMetadata_Value>> {
    const req = new IonRequest(this.ctx, "IHostProc", "getConfig");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ConfigSectionMetadata_Value>>("IonArray<ConfigSectionMetadata_Value>", writer.data, this.signal);
  }
  async setConfigValue(set: SetRequest): Promise<SetResult> {
    const req = new IonRequest(this.ctx, "IHostProc", "setConfigValue");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<SetRequest>('SetRequest').write(writer, set);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<SetResult>("SetResult", writer.data, this.signal);
  }
  async hotkeyRegister(desc: HotkeyDescriptor): Promise<void> {
    const req = new IonRequest(this.ctx, "IHostProc", "hotkeyRegister");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<HotkeyDescriptor>('HotkeyDescriptor').write(writer, desc);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async hotkeyUnregister(id: string): Promise<void> {
    const req = new IonRequest(this.ctx, "IHostProc", "hotkeyUnregister");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, id);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async hotkeyCaptureOnce(): Promise<HotkeyChord> {
    const req = new IonRequest(this.ctx, "IHostProc", "hotkeyCaptureOnce");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<HotkeyChord>("HotkeyChord", writer.data, this.signal);
  }
  async hotkeyPause(): Promise<void> {
    const req = new IonRequest(this.ctx, "IHostProc", "hotkeyPause");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async hotkeyResume(): Promise<void> {
    const req = new IonRequest(this.ctx, "IHostProc", "hotkeyResume");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async hotkeyFired(fn: PinnedFn): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "hotkeyFired");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<PinnedFn>('PinnedFn').write(writer, fn);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async startStreaming(parameters: StreamBegin): Promise<void> {
    const req = new IonRequest(this.ctx, "IHostProc", "startStreaming");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<StreamBegin>('StreamBegin').write(writer, parameters);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async createPasskey(passkeyId: string, challenge: string, user: PasskeyUser, rpName: string, rpId: string): Promise<ICreatePasskeyResult> {
    const req = new IonRequest(this.ctx, "IHostProc", "createPasskey");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(5);
          
    IonFormatterStorage.get<string>('string').write(writer, passkeyId);
    IonFormatterStorage.get<string>('string').write(writer, challenge);
    IonFormatterStorage.get<PasskeyUser>('PasskeyUser').write(writer, user);
    IonFormatterStorage.get<string>('string').write(writer, rpName);
    IonFormatterStorage.get<string>('string').write(writer, rpId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ICreatePasskeyResult>("ICreatePasskeyResult", writer.data, this.signal);
  }
  async validatePasskey(challenge: string, allowedCredentials: IonArray<PasskeyCredential>, rpId: string): Promise<IValidatePasskeyResult> {
    const req = new IonRequest(this.ctx, "IHostProc", "validatePasskey");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<string>('string').write(writer, challenge);
    IonFormatterStorage.writeArray<PasskeyCredential>(writer, allowedCredentials, 'PasskeyCredential');
    IonFormatterStorage.get<string>('string').write(writer, rpId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IValidatePasskeyResult>("IValidatePasskeyResult", writer.data, this.signal);
  }
  async startSharedTextureWithStreamingByMonitor(displayIndex: i4, textureWidth: i4, textureHeight: i4): Promise<string> {
    const req = new IonRequest(this.ctx, "IHostProc", "startSharedTextureWithStreamingByMonitor");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<i4>('i4').write(writer, displayIndex);
    IonFormatterStorage.get<i4>('i4').write(writer, textureWidth);
    IonFormatterStorage.get<i4>('i4').write(writer, textureHeight);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IHostProc>('HostProc', HostProc_Executor);

export class OverlayController_Executor extends ServiceExecutor<IOverlayController> implements IOverlayController {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async init(cfg: InitCfg): Promise<void> {
    const req = new IonRequest(this.ctx, "IOverlayController", "init");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<InitCfg>('InitCfg').write(writer, cfg);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async sendFullFrame(frame: FrameData): Promise<void> {
    const req = new IonRequest(this.ctx, "IOverlayController", "sendFullFrame");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<FrameData>('FrameData').write(writer, frame);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async sendDelta(deltaFrame: FrameDataDelta): Promise<void> {
    const req = new IonRequest(this.ctx, "IOverlayController", "sendDelta");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<FrameDataDelta>('FrameDataDelta').write(writer, deltaFrame);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async clear(): Promise<void> {
    const req = new IonRequest(this.ctx, "IOverlayController", "clear");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async resize(width: i4, height: i4, tileSize: i4, tilesX: i4, tilesY: i4): Promise<void> {
    const req = new IonRequest(this.ctx, "IOverlayController", "resize");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(5);
          
    IonFormatterStorage.get<i4>('i4').write(writer, width);
    IonFormatterStorage.get<i4>('i4').write(writer, height);
    IonFormatterStorage.get<i4>('i4').write(writer, tileSize);
    IonFormatterStorage.get<i4>('i4').write(writer, tilesX);
    IonFormatterStorage.get<i4>('i4').write(writer, tilesY);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async sendStats(stats: OverlayStats): Promise<void> {
    const req = new IonRequest(this.ctx, "IOverlayController", "sendStats");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<OverlayStats>('OverlayStats').write(writer, stats);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async dispose(): Promise<void> {
    const req = new IonRequest(this.ctx, "IOverlayController", "dispose");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IOverlayController>('OverlayController', OverlayController_Executor);


export function createClient(endpoint: string, interceptors: IonInterceptor[]) {
  const ctx = {
    baseUrl: endpoint,
    interceptors: interceptors
  } as IonClientContext;
  const controller = new AbortController();

  return new Proxy(
    {},
    {
      get(_target, propKey) {
        if (typeof propKey !== "string") return undefined;
        if (propKey === "HostProc") return IonFormatterStorage.createExecutor("HostProc", ctx, controller.signal);
        if (propKey === "OverlayController") return IonFormatterStorage.createExecutor("OverlayController", ctx, controller.signal);


        throw new Error(`${propKey} service is not defined`);
      },
    }
  ) as {
    HostProc: IHostProc;
    OverlayController: IOverlayController;

  };
}

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------
import { 
  CborReader, 
  CborWriter, 
  
  DateOnly, 
  DateTimeOffset, 
  Duration, 
  TimeOnly, 
  Guid, 
  
  IonFormatterStorage,

  IonArray, 
  IonMaybe,

  IIonService,
  IIonUnion,
  
  ServiceExecutor,
  IonClientContext,
  IonRequest,
  IonWsClient,
  IonInterceptor
} from "@argon-chat/ion.webcore";

type guid = Guid;
type timeonly = TimeOnly;
type duration = Duration;
type datetime = DateTimeOffset;
type dateonly = DateOnly;

declare type bool = boolean;

declare type i1 = number;
declare type i2 = number;
declare type i4 = number;
declare type i8 = bigint;
declare type i16 = bigint;


declare type u1 = number;
declare type u2 = number;
declare type u4 = number;
declare type u8 = bigint;
declare type u16 = bigint;


declare type f2 = number;
declare type f4 = number;
declare type f8 = number;

export interface ChannelEntitlementOverwrite {
  channelId: guid;
  archetypeId: guid | null;
  serverMemberId: guid | null;
  allow: ArgonEntitlement;
  deny: ArgonEntitlement;
  creatorId: guid;
  id: guid;
};


export interface Archetype {
  id: guid;
  spaceId: guid;
  name: string;
  description: string;
  isMentionable: bool;
  colour: i4;
  isHidden: bool;
  isLocked: bool;
  isGroup: bool;
  isDefault: bool;
  iconFileId: string | null;
  entitlement: ArgonEntitlement;
};


export interface CreateChannelRequest {
  spaceId: guid;
  name: string;
  kind: ChannelType;
  desc: string;
};


export interface RealtimeChannel {
  channel: ArgonChannel;
  users: IonArray<RealtimeChannelUser>;
};


export interface ArgonChannel {
  type: ChannelType;
  spaceId: guid;
  channelId: guid;
  name: string;
  description: string | null;
  categoryId: guid;
};


export interface ArgonMessage {
  messageId: i8;
  replyId: i8 | null;
  channelId: guid;
  spaceId: guid;
  text: string;
  entities: IonArray<IMessageEntity>;
  timeSent: datetime;
  sender: guid;
};


export interface RealtimeChannelUser {
  userId: guid;
  state: ChannelMemberState;
};


export interface UserActivityPresence {
  kind: ActivityPresenceKind;
  startTimestampSeconds: u8;
  titleName: string;
};


export enum ChannelType
{
  Text = 0,
  Voice = 1,
  Announcement = 2,
}


export enum JoinToChannelError
{
  NONE = 0,
  CHANNEL_IS_NOT_VOICE = 1,
}


export enum EntityType
{
  Hashtag = 0,
  Mention = 1,
  Email = 2,
  Url = 3,
  Monospace = 4,
  Quote = 5,
  Spoiler = 6,
  Strikethrough = 7,
  Bold = 8,
  Italic = 9,
  Underline = 10,
  Fraction = 11,
  Ordinal = 12,
  Capitalized = 13,
}


export enum ActivityPresenceKind
{
  GAME = 0,
  SOFTWARE = 1,
  STREAMING = 2,
  LISTEN = 3,
}


export enum ChannelMemberState
{
  NONE = 0,
  MUTED = 2,
  MUTED_BY_SERVER = 4,
  MUTED_HEADPHONES = 8,
  MUTED_HEADPHONES_BY_SERVER = 16,
  STREAMING = 32,
}


export interface FriendRequest {
  requestId: guid;
  fromUser: guid;
  toUser: guid;
  requestTime: datetime;
};


export enum FriendRequestStatus
{
  Pending = 0,
  Accepted = 1,
  Declined = 2,
  Cancelled = 3,
  Expired = 4,
  Blocked = 5,
}


export enum BadAuthKind
{
  SESSION_EXPIRED = 0,
  REQUIRED_RELOGIN = 1,
  BAD_TOKEN = 2,
}


export interface InventoryItem {
  id: string;
  instanceId: guid;
  grantedDate: datetime;
  usable: bool;
  giftable: bool;
  usableVector: ItemUseVector | null;
  receivedFrom: guid | null;
  ttl: duration | null;
};


export interface DetailedInventoryItem {
  item: InventoryItem;
  containedItem: InventoryItem | null;
};


export interface InventoryNotification {
  inventoryItemId: guid;
  id: string;
  createdAt: datetime;
};


export enum ItemUseVector
{
  RedeemCode = 0,
  Premium = 1,
  Box = 2,
  QualifierBox = 3,
}


export enum RedeemError
{
  NOT_FOUND = 0,
  INACTIVE = 1,
  EXPIRED = 2,
  LIMIT_REACHED = 3,
  ALREADY = 4,
}


export interface JoinMeetResponse {
  voiceToken: string;
  endpoint: RtcEndpoint;
  meetInfo: MeetInfo;
};


export interface MeetInfo {
  title: string;
  startTime: u4;
  roomId: string;
};


export interface RtcEndpoint {
  endpoint: string;
  ices: IonArray<IceEndpoint>;
};


export interface IceEndpoint {
  endpoint: string;
  username: string;
  password: string;
};


export enum MeetJoinError
{
  OK = 0,
  NO_LINK_EXIST = 1,
  YOU_ARE_BANNED = 2,
}


export interface ArgonSpaceBase {
  spaceId: guid;
  name: string;
  description: string;
  avatarFieldId: string | null;
  topBannerFileId: string | null;
};


export interface ArgonSpace {
  spaceId: guid;
  name: string;
  description: string;
  avatarFieldId: string | null;
  topBannerFileId: string | null;
  channels: IonArray<ArgonChannel>;
  members: IonArray<SpaceMember>;
  archetypes: IonArray<Archetype>;
};


export interface ArchetypeGroup {
  archetype: Archetype;
  members: IonArray<guid>;
};


export interface SpaceMemberArchetype {
  serverMemberId: guid;
  archetypeId: guid;
};


export interface SpaceMember {
  userId: guid;
  spaceId: guid;
  joinedAt: datetime;
  memberId: guid;
  user: ArgonUser;
  archetypes: IonArray<SpaceMemberArchetype>;
};


export interface RealtimeServerMember {
  member: SpaceMember;
  status: UserStatus;
  presence: UserActivityPresence | null;
};


export interface InviteCodeEntity {
  code: InviteCode;
  spaceId: guid;
  issuerId: guid;
  expireTime: datetime;
  used: u8;
};


export interface InviteCode {
  inviteCode: string;
};


export interface ArgonUser {
  userId: guid;
  username: string;
  displayName: string;
  avatarFileId: string | null;
};


export interface ArgonUserProfile {
  userId: guid;
  customStatus: string | null;
  customStatusIconId: string | null;
  bannerFileID: string | null;
  dateOfBirth: dateonly | null;
  bio: string | null;
  isPremium: bool;
  badges: IonArray<string>;
  archetypes: IonArray<SpaceMemberArchetype>;
};


export enum UserStatus
{
  Offline = 0,
  Online = 1,
  Away = 2,
  InGame = 3,
  Listen = 4,
  TouchGrass = 5,
  DoNotDisturb = 6,
}


export enum ArgonEntitlement
{
  None = 0n as any,
  ViewChannel = 1n as any,
  ReadHistory = 2n as any,
  JoinToVoice = 4n as any,
  SendMessages = 32n as any,
  SendVoice = 64n as any,
  AttachFiles = 128n as any,
  AddReactions = 256n as any,
  AnyMentions = 512n as any,
  MentionEveryone = 1024n as any,
  ExternalEmoji = 2048n as any,
  ExternalStickers = 4096n as any,
  UseCommands = 8192n as any,
  PostEmbeddedLinks = 16384n as any,
  Connect = 1048576n as any,
  Speak = 2097152n as any,
  Video = 4194304n as any,
  Stream = 8388608n as any,
  UseASIO = 1073741824n as any,
  AdditionalStreams = 2147483648n as any,
  DisconnectMember = 1099511627776n as any,
  MoveMember = 2199023255552n as any,
  BanMember = 4398046511104n as any,
  MuteMember = 8796093022208n as any,
  KickMember = 17592186044416n as any,
  ManageChannels = 1125899906842624n as any,
  ManageArchetype = 2251799813685248n as any,
  ManageBots = 4503599627370496n as any,
  ManageEvents = 9007199254740992n as any,
  ManageBehaviour = 18014398509481984n as any,
  ManageServer = 36028797018963968n as any,
}


export interface ArgonIonTicket {
  userId: guid;
  ip: string;
  ray: string;
  clientName: string;
  hostName: string;
  appId: string;
  sessionId: guid;
  machineId: string;
  region: string;
};


export interface UserEditInput {
  displayName: string | null;
  avatarId: string | null;
};


export interface FeatureFlag {
  key: string;
  enabled: bool;
  variant: string | null;
  parameters: IonArray<FeatureFlagParameter>;
};


export interface FeatureFlagParameter {
  key: string;
  value: string;
};


export interface CreateServerRequest {
  name: string;
  description: string;
  avatarFieldId: string;
};


export interface UserCredentialsInput {
  email: string | null;
  phone: string | null;
  username: string | null;
  password: string | null;
  otpCode: string | null;
  captchaToken: string | null;
};


export interface UserLoginInput {
  email: string | null;
  phone: string | null;
  username: string | null;
};


export interface NewUserCredentialsInput {
  email: string;
  username: string;
  password: string;
  displayName: string;
  argreeTos: bool;
  birthDate: dateonly;
  argreeOptionalEmails: bool;
  captchaToken: string | null;
};


export enum UploadFileError
{
  NONE = 0,
  NOT_AUTHORIZED = 1,
  INTERNAL_ERROR = 2,
}


export enum CreateSpaceError
{
  UNKNOWN = 0,
  LIMIT_REACHED = 1,
}


export enum AcceptInviteError
{
  NONE = 0,
  NOT_FOUND = 1,
  EXPIRED = 2,
  YOU_ARE_BANNED = 3,
}


export enum AuthorizationError
{
  NONE = 0,
  BAD_CREDENTIALS = 1,
  REQUIRED_OTP = 2,
  BAD_OTP = 3,
}


export enum RegistrationError
{
  USERNAME_ALREADY_TAKEN = 0,
  USERNAME_RESERVED = 1,
  EMAIL_ALREADY_REGISTERED = 2,
  REGION_BANNED = 3,
  EMAIL_BANNED = 4,
  SSO_EMAILS_NOT_ALLOWED = 5,
  INTERNAL_ERROR = 6,
  VALIDATION_FAILED = 7,
}


export enum LockdownReason
{
  NONE = 0,
  UNDER_INVESTIGATION = 1,
  COMPROMISED_ACCOUNT = 2,
  PAYMENT_FRAUD = 3,
  MULTI_ACCOUNT_ABUSE = 4,
  DOXXING = 5,
  CSAM = 6,
  SPAM_SCAM_ACCOUNT = 7,
  INCITING_MOMENT = 8,
  NON_BINARY_PERSON = 9,
  TOS_VIOLATION = 10,
  LGBT_AGITATION = 11,
  DRUG_VIOLATION = 12,
  TERRORISM_AGITATION = 13,
  TERRORISM_CONTENT = 14,
  SELF_HARM_PROMOTION = 15,
  CHILD_ABUSE = 16,
}


export enum LockdownSeverity
{
  Low = 0,
  Middle = 1,
  Critical = 2,
}



export abstract class IMessageEntity implements IIonUnion<IMessageEntity>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
    abstract type: EntityType;
  abstract offset: i4;
  abstract length: i4;
  abstract version: i4;

  
  
  public isMessageEntityMention(): this is MessageEntityMention {
    return this.UnionKey === "MessageEntityMention";
  }
  public isMessageEntityEmail(): this is MessageEntityEmail {
    return this.UnionKey === "MessageEntityEmail";
  }
  public isMessageEntityHashTag(): this is MessageEntityHashTag {
    return this.UnionKey === "MessageEntityHashTag";
  }
  public isMessageEntityQuote(): this is MessageEntityQuote {
    return this.UnionKey === "MessageEntityQuote";
  }
  public isMessageEntityUnderline(): this is MessageEntityUnderline {
    return this.UnionKey === "MessageEntityUnderline";
  }
  public isMessageEntityUrl(): this is MessageEntityUrl {
    return this.UnionKey === "MessageEntityUrl";
  }

}


export class MessageEntityMention extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public userId: guid) { super(); }

  UnionKey: string = "MessageEntityMention";
  UnionIndex: number = 0;
}

export class MessageEntityEmail extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public email: string) { super(); }

  UnionKey: string = "MessageEntityEmail";
  UnionIndex: number = 1;
}

export class MessageEntityHashTag extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public hashtag: string) { super(); }

  UnionKey: string = "MessageEntityHashTag";
  UnionIndex: number = 2;
}

export class MessageEntityQuote extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public quotedUserId: guid) { super(); }

  UnionKey: string = "MessageEntityQuote";
  UnionIndex: number = 3;
}

export class MessageEntityUnderline extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public colour: i4) { super(); }

  UnionKey: string = "MessageEntityUnderline";
  UnionIndex: number = 4;
}

export class MessageEntityUrl extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public domain: string, public path: string) { super(); }

  UnionKey: string = "MessageEntityUrl";
  UnionIndex: number = 5;
}



IonFormatterStorage.register("IMessageEntity", {
  read(reader: CborReader): IMessageEntity {
    reader.readStartArray();
    let value: IMessageEntity = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<MessageEntityMention>("MessageEntityMention").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<MessageEntityEmail>("MessageEntityEmail").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<MessageEntityHashTag>("MessageEntityHashTag").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<MessageEntityQuote>("MessageEntityQuote").read(reader);
    else if (unionIndex == 4)
      value = IonFormatterStorage.get<MessageEntityUnderline>("MessageEntityUnderline").read(reader);
    else if (unionIndex == 5)
      value = IonFormatterStorage.get<MessageEntityUrl>("MessageEntityUrl").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IMessageEntity): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<MessageEntityMention>("MessageEntityMention").write(writer, value as MessageEntityMention);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<MessageEntityEmail>("MessageEntityEmail").write(writer, value as MessageEntityEmail);
    }
    else if (value.UnionIndex == 2) {
        IonFormatterStorage.get<MessageEntityHashTag>("MessageEntityHashTag").write(writer, value as MessageEntityHashTag);
    }
    else if (value.UnionIndex == 3) {
        IonFormatterStorage.get<MessageEntityQuote>("MessageEntityQuote").write(writer, value as MessageEntityQuote);
    }
    else if (value.UnionIndex == 4) {
        IonFormatterStorage.get<MessageEntityUnderline>("MessageEntityUnderline").write(writer, value as MessageEntityUnderline);
    }
    else if (value.UnionIndex == 5) {
        IonFormatterStorage.get<MessageEntityUrl>("MessageEntityUrl").write(writer, value as MessageEntityUrl);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("MessageEntityMention", {
  read(reader: CborReader): MessageEntityMention {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityMention(type, offset, length, version, userId);
  },
  write(writer: CborWriter, value: MessageEntityMention): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityEmail", {
  read(reader: CborReader): MessageEntityEmail {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const email = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityEmail(type, offset, length, version, email);
  },
  write(writer: CborWriter, value: MessageEntityEmail): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<string>('string').write(writer, value.email);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityHashTag", {
  read(reader: CborReader): MessageEntityHashTag {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const hashtag = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityHashTag(type, offset, length, version, hashtag);
  },
  write(writer: CborWriter, value: MessageEntityHashTag): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<string>('string').write(writer, value.hashtag);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityQuote", {
  read(reader: CborReader): MessageEntityQuote {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const quotedUserId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityQuote(type, offset, length, version, quotedUserId);
  },
  write(writer: CborWriter, value: MessageEntityQuote): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.quotedUserId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityUnderline", {
  read(reader: CborReader): MessageEntityUnderline {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const colour = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return new MessageEntityUnderline(type, offset, length, version, colour);
  },
  write(writer: CborWriter, value: MessageEntityUnderline): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<i4>('i4').write(writer, value.colour);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityUrl", {
  read(reader: CborReader): MessageEntityUrl {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const domain = IonFormatterStorage.get<string>('string').read(reader);
    const path = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 6);
    return new MessageEntityUrl(type, offset, length, version, domain, path);
  },
  write(writer: CborWriter, value: MessageEntityUrl): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<string>('string').write(writer, value.domain);
    IonFormatterStorage.get<string>('string').write(writer, value.path);
    writer.writeEndArray();
  }
});



export abstract class IInterlinkResult implements IIonUnion<IInterlinkResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessJoinVoice(): this is SuccessJoinVoice {
    return this.UnionKey === "SuccessJoinVoice";
  }
  public isFailedJoinVoice(): this is FailedJoinVoice {
    return this.UnionKey === "FailedJoinVoice";
  }

}


export class SuccessJoinVoice extends IInterlinkResult
{
  constructor(public rtc: RtcEndpoint, public token: string) { super(); }

  UnionKey: string = "SuccessJoinVoice";
  UnionIndex: number = 0;
}

export class FailedJoinVoice extends IInterlinkResult
{
  constructor(public error: JoinToChannelError) { super(); }

  UnionKey: string = "FailedJoinVoice";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IInterlinkResult", {
  read(reader: CborReader): IInterlinkResult {
    reader.readStartArray();
    let value: IInterlinkResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessJoinVoice>("SuccessJoinVoice").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedJoinVoice>("FailedJoinVoice").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IInterlinkResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessJoinVoice>("SuccessJoinVoice").write(writer, value as SuccessJoinVoice);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedJoinVoice>("FailedJoinVoice").write(writer, value as FailedJoinVoice);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessJoinVoice", {
  read(reader: CborReader): SuccessJoinVoice {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const rtc = IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').read(reader);
    const token = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SuccessJoinVoice(rtc, token);
  },
  write(writer: CborWriter, value: SuccessJoinVoice): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').write(writer, value.rtc);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedJoinVoice", {
  read(reader: CborReader): FailedJoinVoice {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<JoinToChannelError>('JoinToChannelError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedJoinVoice(error);
  },
  write(writer: CborWriter, value: FailedJoinVoice): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<JoinToChannelError>('JoinToChannelError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IArgonEvent implements IIonUnion<IArgonEvent>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
    abstract spaceId: guid;

  
  
  public isArchetypeChanged(): this is ArchetypeChanged {
    return this.UnionKey === "ArchetypeChanged";
  }
  public isArchetypeCreated(): this is ArchetypeCreated {
    return this.UnionKey === "ArchetypeCreated";
  }
  public isChannelCreated(): this is ChannelCreated {
    return this.UnionKey === "ChannelCreated";
  }
  public isChannelModified(): this is ChannelModified {
    return this.UnionKey === "ChannelModified";
  }
  public isChannelRemoved(): this is ChannelRemoved {
    return this.UnionKey === "ChannelRemoved";
  }
  public isUserTypingEvent(): this is UserTypingEvent {
    return this.UnionKey === "UserTypingEvent";
  }
  public isUserStopTypingEvent(): this is UserStopTypingEvent {
    return this.UnionKey === "UserStopTypingEvent";
  }
  public isJoinedToChannelUser(): this is JoinedToChannelUser {
    return this.UnionKey === "JoinedToChannelUser";
  }
  public isJoinToServerUser(): this is JoinToServerUser {
    return this.UnionKey === "JoinToServerUser";
  }
  public isLeavedFromChannelUser(): this is LeavedFromChannelUser {
    return this.UnionKey === "LeavedFromChannelUser";
  }
  public isUserUpdated(): this is UserUpdated {
    return this.UnionKey === "UserUpdated";
  }
  public isOnUserPresenceActivityChanged(): this is OnUserPresenceActivityChanged {
    return this.UnionKey === "OnUserPresenceActivityChanged";
  }
  public isOnUserPresenceActivityRemoved(): this is OnUserPresenceActivityRemoved {
    return this.UnionKey === "OnUserPresenceActivityRemoved";
  }
  public isUserChangedStatus(): this is UserChangedStatus {
    return this.UnionKey === "UserChangedStatus";
  }
  public isMessageSent(): this is MessageSent {
    return this.UnionKey === "MessageSent";
  }
  public isServerModified(): this is ServerModified {
    return this.UnionKey === "ServerModified";
  }

}


export class ArchetypeChanged extends IArgonEvent
{
  constructor(public spaceId: guid, public data: Archetype) { super(); }

  UnionKey: string = "ArchetypeChanged";
  UnionIndex: number = 0;
}

export class ArchetypeCreated extends IArgonEvent
{
  constructor(public spaceId: guid, public data: Archetype) { super(); }

  UnionKey: string = "ArchetypeCreated";
  UnionIndex: number = 1;
}

export class ChannelCreated extends IArgonEvent
{
  constructor(public spaceId: guid, public data: ArgonChannel) { super(); }

  UnionKey: string = "ChannelCreated";
  UnionIndex: number = 2;
}

export class ChannelModified extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public bag: IonArray<string>) { super(); }

  UnionKey: string = "ChannelModified";
  UnionIndex: number = 3;
}

export class ChannelRemoved extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid) { super(); }

  UnionKey: string = "ChannelRemoved";
  UnionIndex: number = 4;
}

export class UserTypingEvent extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "UserTypingEvent";
  UnionIndex: number = 5;
}

export class UserStopTypingEvent extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "UserStopTypingEvent";
  UnionIndex: number = 6;
}

export class JoinedToChannelUser extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "JoinedToChannelUser";
  UnionIndex: number = 7;
}

export class JoinToServerUser extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid) { super(); }

  UnionKey: string = "JoinToServerUser";
  UnionIndex: number = 8;
}

export class LeavedFromChannelUser extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "LeavedFromChannelUser";
  UnionIndex: number = 9;
}

export class UserUpdated extends IArgonEvent
{
  constructor(public spaceId: guid, public dto: ArgonUser) { super(); }

  UnionKey: string = "UserUpdated";
  UnionIndex: number = 10;
}

export class OnUserPresenceActivityChanged extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid, public presence: UserActivityPresence) { super(); }

  UnionKey: string = "OnUserPresenceActivityChanged";
  UnionIndex: number = 11;
}

export class OnUserPresenceActivityRemoved extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid) { super(); }

  UnionKey: string = "OnUserPresenceActivityRemoved";
  UnionIndex: number = 12;
}

export class UserChangedStatus extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid, public status: UserStatus, public bag: IonArray<string>) { super(); }

  UnionKey: string = "UserChangedStatus";
  UnionIndex: number = 13;
}

export class MessageSent extends IArgonEvent
{
  constructor(public spaceId: guid, public message: ArgonMessage) { super(); }

  UnionKey: string = "MessageSent";
  UnionIndex: number = 14;
}

export class ServerModified extends IArgonEvent
{
  constructor(public spaceId: guid, public bag: IonArray<string>) { super(); }

  UnionKey: string = "ServerModified";
  UnionIndex: number = 15;
}



IonFormatterStorage.register("IArgonEvent", {
  read(reader: CborReader): IArgonEvent {
    reader.readStartArray();
    let value: IArgonEvent = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<ArchetypeChanged>("ArchetypeChanged").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<ArchetypeCreated>("ArchetypeCreated").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<ChannelCreated>("ChannelCreated").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<ChannelModified>("ChannelModified").read(reader);
    else if (unionIndex == 4)
      value = IonFormatterStorage.get<ChannelRemoved>("ChannelRemoved").read(reader);
    else if (unionIndex == 5)
      value = IonFormatterStorage.get<UserTypingEvent>("UserTypingEvent").read(reader);
    else if (unionIndex == 6)
      value = IonFormatterStorage.get<UserStopTypingEvent>("UserStopTypingEvent").read(reader);
    else if (unionIndex == 7)
      value = IonFormatterStorage.get<JoinedToChannelUser>("JoinedToChannelUser").read(reader);
    else if (unionIndex == 8)
      value = IonFormatterStorage.get<JoinToServerUser>("JoinToServerUser").read(reader);
    else if (unionIndex == 9)
      value = IonFormatterStorage.get<LeavedFromChannelUser>("LeavedFromChannelUser").read(reader);
    else if (unionIndex == 10)
      value = IonFormatterStorage.get<UserUpdated>("UserUpdated").read(reader);
    else if (unionIndex == 11)
      value = IonFormatterStorage.get<OnUserPresenceActivityChanged>("OnUserPresenceActivityChanged").read(reader);
    else if (unionIndex == 12)
      value = IonFormatterStorage.get<OnUserPresenceActivityRemoved>("OnUserPresenceActivityRemoved").read(reader);
    else if (unionIndex == 13)
      value = IonFormatterStorage.get<UserChangedStatus>("UserChangedStatus").read(reader);
    else if (unionIndex == 14)
      value = IonFormatterStorage.get<MessageSent>("MessageSent").read(reader);
    else if (unionIndex == 15)
      value = IonFormatterStorage.get<ServerModified>("ServerModified").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IArgonEvent): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<ArchetypeChanged>("ArchetypeChanged").write(writer, value as ArchetypeChanged);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<ArchetypeCreated>("ArchetypeCreated").write(writer, value as ArchetypeCreated);
    }
    else if (value.UnionIndex == 2) {
        IonFormatterStorage.get<ChannelCreated>("ChannelCreated").write(writer, value as ChannelCreated);
    }
    else if (value.UnionIndex == 3) {
        IonFormatterStorage.get<ChannelModified>("ChannelModified").write(writer, value as ChannelModified);
    }
    else if (value.UnionIndex == 4) {
        IonFormatterStorage.get<ChannelRemoved>("ChannelRemoved").write(writer, value as ChannelRemoved);
    }
    else if (value.UnionIndex == 5) {
        IonFormatterStorage.get<UserTypingEvent>("UserTypingEvent").write(writer, value as UserTypingEvent);
    }
    else if (value.UnionIndex == 6) {
        IonFormatterStorage.get<UserStopTypingEvent>("UserStopTypingEvent").write(writer, value as UserStopTypingEvent);
    }
    else if (value.UnionIndex == 7) {
        IonFormatterStorage.get<JoinedToChannelUser>("JoinedToChannelUser").write(writer, value as JoinedToChannelUser);
    }
    else if (value.UnionIndex == 8) {
        IonFormatterStorage.get<JoinToServerUser>("JoinToServerUser").write(writer, value as JoinToServerUser);
    }
    else if (value.UnionIndex == 9) {
        IonFormatterStorage.get<LeavedFromChannelUser>("LeavedFromChannelUser").write(writer, value as LeavedFromChannelUser);
    }
    else if (value.UnionIndex == 10) {
        IonFormatterStorage.get<UserUpdated>("UserUpdated").write(writer, value as UserUpdated);
    }
    else if (value.UnionIndex == 11) {
        IonFormatterStorage.get<OnUserPresenceActivityChanged>("OnUserPresenceActivityChanged").write(writer, value as OnUserPresenceActivityChanged);
    }
    else if (value.UnionIndex == 12) {
        IonFormatterStorage.get<OnUserPresenceActivityRemoved>("OnUserPresenceActivityRemoved").write(writer, value as OnUserPresenceActivityRemoved);
    }
    else if (value.UnionIndex == 13) {
        IonFormatterStorage.get<UserChangedStatus>("UserChangedStatus").write(writer, value as UserChangedStatus);
    }
    else if (value.UnionIndex == 14) {
        IonFormatterStorage.get<MessageSent>("MessageSent").write(writer, value as MessageSent);
    }
    else if (value.UnionIndex == 15) {
        IonFormatterStorage.get<ServerModified>("ServerModified").write(writer, value as ServerModified);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("ArchetypeChanged", {
  read(reader: CborReader): ArchetypeChanged {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<Archetype>('Archetype').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ArchetypeChanged(spaceId, data);
  },
  write(writer: CborWriter, value: ArchetypeChanged): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArchetypeCreated", {
  read(reader: CborReader): ArchetypeCreated {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<Archetype>('Archetype').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ArchetypeCreated(spaceId, data);
  },
  write(writer: CborWriter, value: ArchetypeCreated): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelCreated", {
  read(reader: CborReader): ChannelCreated {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<ArgonChannel>('ArgonChannel').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ChannelCreated(spaceId, data);
  },
  write(writer: CborWriter, value: ChannelCreated): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonChannel>('ArgonChannel').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelModified", {
  read(reader: CborReader): ChannelModified {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const bag = IonFormatterStorage.readArray<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 3);
    return new ChannelModified(spaceId, channelId, bag);
  },
  write(writer: CborWriter, value: ChannelModified): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.writeArray<string>(writer, value.bag, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelRemoved", {
  read(reader: CborReader): ChannelRemoved {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ChannelRemoved(spaceId, channelId);
  },
  write(writer: CborWriter, value: ChannelRemoved): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserTypingEvent", {
  read(reader: CborReader): UserTypingEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new UserTypingEvent(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: UserTypingEvent): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserStopTypingEvent", {
  read(reader: CborReader): UserStopTypingEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new UserStopTypingEvent(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: UserStopTypingEvent): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("JoinedToChannelUser", {
  read(reader: CborReader): JoinedToChannelUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new JoinedToChannelUser(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: JoinedToChannelUser): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("JoinToServerUser", {
  read(reader: CborReader): JoinToServerUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new JoinToServerUser(spaceId, userId);
  },
  write(writer: CborWriter, value: JoinToServerUser): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("LeavedFromChannelUser", {
  read(reader: CborReader): LeavedFromChannelUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new LeavedFromChannelUser(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: LeavedFromChannelUser): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserUpdated", {
  read(reader: CborReader): UserUpdated {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const dto = IonFormatterStorage.get<ArgonUser>('ArgonUser').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new UserUpdated(spaceId, dto);
  },
  write(writer: CborWriter, value: UserUpdated): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonUser>('ArgonUser').write(writer, value.dto);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("OnUserPresenceActivityChanged", {
  read(reader: CborReader): OnUserPresenceActivityChanged {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const presence = IonFormatterStorage.get<UserActivityPresence>('UserActivityPresence').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return new OnUserPresenceActivityChanged(spaceId, userId, presence);
  },
  write(writer: CborWriter, value: OnUserPresenceActivityChanged): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<UserActivityPresence>('UserActivityPresence').write(writer, value.presence);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("OnUserPresenceActivityRemoved", {
  read(reader: CborReader): OnUserPresenceActivityRemoved {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new OnUserPresenceActivityRemoved(spaceId, userId);
  },
  write(writer: CborWriter, value: OnUserPresenceActivityRemoved): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserChangedStatus", {
  read(reader: CborReader): UserChangedStatus {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const status = IonFormatterStorage.get<UserStatus>('UserStatus').read(reader);
    const bag = IonFormatterStorage.readArray<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 4);
    return new UserChangedStatus(spaceId, userId, status, bag);
  },
  write(writer: CborWriter, value: UserChangedStatus): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<UserStatus>('UserStatus').write(writer, value.status);
    IonFormatterStorage.writeArray<string>(writer, value.bag, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageSent", {
  read(reader: CborReader): MessageSent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const message = IonFormatterStorage.get<ArgonMessage>('ArgonMessage').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return new MessageSent(spaceId, message);
  },
  write(writer: CborWriter, value: MessageSent): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonMessage>('ArgonMessage').write(writer, value.message);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ServerModified", {
  read(reader: CborReader): ServerModified {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const bag = IonFormatterStorage.readArray<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 2);
    return new ServerModified(spaceId, bag);
  },
  write(writer: CborWriter, value: ServerModified): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.writeArray<string>(writer, value.bag, 'string');
    writer.writeEndArray();
  }
});



export abstract class IArgonClientEvent implements IIonUnion<IArgonClientEvent>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isIAmTypingEvent(): this is IAmTypingEvent {
    return this.UnionKey === "IAmTypingEvent";
  }
  public isIAmStopTypingEvent(): this is IAmStopTypingEvent {
    return this.UnionKey === "IAmStopTypingEvent";
  }
  public isHeartBeatEvent(): this is HeartBeatEvent {
    return this.UnionKey === "HeartBeatEvent";
  }
  public isSubscribeToMySpaces(): this is SubscribeToMySpaces {
    return this.UnionKey === "SubscribeToMySpaces";
  }

}


export class IAmTypingEvent extends IArgonClientEvent
{
  constructor(public channelId: guid) { super(); }

  UnionKey: string = "IAmTypingEvent";
  UnionIndex: number = 0;
}

export class IAmStopTypingEvent extends IArgonClientEvent
{
  constructor(public channelId: guid) { super(); }

  UnionKey: string = "IAmStopTypingEvent";
  UnionIndex: number = 1;
}

export class HeartBeatEvent extends IArgonClientEvent
{
  constructor(public status: UserStatus) { super(); }

  UnionKey: string = "HeartBeatEvent";
  UnionIndex: number = 2;
}

export class SubscribeToMySpaces extends IArgonClientEvent
{
  constructor() { super(); }

  UnionKey: string = "SubscribeToMySpaces";
  UnionIndex: number = 3;
}



IonFormatterStorage.register("IArgonClientEvent", {
  read(reader: CborReader): IArgonClientEvent {
    reader.readStartArray();
    let value: IArgonClientEvent = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<IAmTypingEvent>("IAmTypingEvent").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<IAmStopTypingEvent>("IAmStopTypingEvent").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<HeartBeatEvent>("HeartBeatEvent").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<SubscribeToMySpaces>("SubscribeToMySpaces").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IArgonClientEvent): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<IAmTypingEvent>("IAmTypingEvent").write(writer, value as IAmTypingEvent);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<IAmStopTypingEvent>("IAmStopTypingEvent").write(writer, value as IAmStopTypingEvent);
    }
    else if (value.UnionIndex == 2) {
        IonFormatterStorage.get<HeartBeatEvent>("HeartBeatEvent").write(writer, value as HeartBeatEvent);
    }
    else if (value.UnionIndex == 3) {
        IonFormatterStorage.get<SubscribeToMySpaces>("SubscribeToMySpaces").write(writer, value as SubscribeToMySpaces);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("IAmTypingEvent", {
  read(reader: CborReader): IAmTypingEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new IAmTypingEvent(channelId);
  },
  write(writer: CborWriter, value: IAmTypingEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("IAmStopTypingEvent", {
  read(reader: CborReader): IAmStopTypingEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new IAmStopTypingEvent(channelId);
  },
  write(writer: CborWriter, value: IAmStopTypingEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("HeartBeatEvent", {
  read(reader: CborReader): HeartBeatEvent {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const status = IonFormatterStorage.get<UserStatus>('UserStatus').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new HeartBeatEvent(status);
  },
  write(writer: CborWriter, value: HeartBeatEvent): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<UserStatus>('UserStatus').write(writer, value.status);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SubscribeToMySpaces", {
  read(reader: CborReader): SubscribeToMySpaces {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SubscribeToMySpaces();
  },
  write(writer: CborWriter, value: SubscribeToMySpaces): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});



export abstract class IMyAuthStatus implements IIonUnion<IMyAuthStatus>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isGoodAuthStatus(): this is GoodAuthStatus {
    return this.UnionKey === "GoodAuthStatus";
  }
  public isBadAuthStatus(): this is BadAuthStatus {
    return this.UnionKey === "BadAuthStatus";
  }
  public isLockedAuthStatus(): this is LockedAuthStatus {
    return this.UnionKey === "LockedAuthStatus";
  }

}


export class GoodAuthStatus extends IMyAuthStatus
{
  constructor(public token: string) { super(); }

  UnionKey: string = "GoodAuthStatus";
  UnionIndex: number = 0;
}

export class BadAuthStatus extends IMyAuthStatus
{
  constructor(public error: BadAuthKind) { super(); }

  UnionKey: string = "BadAuthStatus";
  UnionIndex: number = 1;
}

export class LockedAuthStatus extends IMyAuthStatus
{
  constructor(public lockdownReason: LockdownReason | null, public lockDownExpiration: datetime | null, public isAppealable: bool, public severity: LockdownSeverity) { super(); }

  UnionKey: string = "LockedAuthStatus";
  UnionIndex: number = 2;
}



IonFormatterStorage.register("IMyAuthStatus", {
  read(reader: CborReader): IMyAuthStatus {
    reader.readStartArray();
    let value: IMyAuthStatus = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<GoodAuthStatus>("GoodAuthStatus").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<BadAuthStatus>("BadAuthStatus").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<LockedAuthStatus>("LockedAuthStatus").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IMyAuthStatus): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<GoodAuthStatus>("GoodAuthStatus").write(writer, value as GoodAuthStatus);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<BadAuthStatus>("BadAuthStatus").write(writer, value as BadAuthStatus);
    }
    else if (value.UnionIndex == 2) {
        IonFormatterStorage.get<LockedAuthStatus>("LockedAuthStatus").write(writer, value as LockedAuthStatus);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("GoodAuthStatus", {
  read(reader: CborReader): GoodAuthStatus {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new GoodAuthStatus(token);
  },
  write(writer: CborWriter, value: GoodAuthStatus): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("BadAuthStatus", {
  read(reader: CborReader): BadAuthStatus {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<BadAuthKind>('BadAuthKind').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new BadAuthStatus(error);
  },
  write(writer: CborWriter, value: BadAuthStatus): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<BadAuthKind>('BadAuthKind').write(writer, value.error);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("LockedAuthStatus", {
  read(reader: CborReader): LockedAuthStatus {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const lockdownReason = IonFormatterStorage.readNullable<LockdownReason>(reader, 'LockdownReason');
    const lockDownExpiration = IonFormatterStorage.readNullable<datetime>(reader, 'datetime');
    const isAppealable = IonFormatterStorage.get<bool>('bool').read(reader);
    const severity = IonFormatterStorage.get<LockdownSeverity>('LockdownSeverity').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return new LockedAuthStatus(lockdownReason, lockDownExpiration, isAppealable, severity);
  },
  write(writer: CborWriter, value: LockedAuthStatus): void {
    writer.writeStartArray(4);
    IonFormatterStorage.writeNullable<LockdownReason>(writer, value.lockdownReason, 'LockdownReason');
    IonFormatterStorage.writeNullable<datetime>(writer, value.lockDownExpiration, 'datetime');
    IonFormatterStorage.get<bool>('bool').write(writer, value.isAppealable);
    IonFormatterStorage.get<LockdownSeverity>('LockdownSeverity').write(writer, value.severity);
    writer.writeEndArray();
  }
});



export abstract class IRedeemResult implements IIonUnion<IRedeemResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessRedeem(): this is SuccessRedeem {
    return this.UnionKey === "SuccessRedeem";
  }
  public isFailedRedeem(): this is FailedRedeem {
    return this.UnionKey === "FailedRedeem";
  }

}


export class SuccessRedeem extends IRedeemResult
{
  constructor() { super(); }

  UnionKey: string = "SuccessRedeem";
  UnionIndex: number = 0;
}

export class FailedRedeem extends IRedeemResult
{
  constructor(public error: RedeemError) { super(); }

  UnionKey: string = "FailedRedeem";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IRedeemResult", {
  read(reader: CborReader): IRedeemResult {
    reader.readStartArray();
    let value: IRedeemResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessRedeem>("SuccessRedeem").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedRedeem>("FailedRedeem").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IRedeemResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessRedeem>("SuccessRedeem").write(writer, value as SuccessRedeem);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedRedeem>("FailedRedeem").write(writer, value as FailedRedeem);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessRedeem", {
  read(reader: CborReader): SuccessRedeem {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    
    reader.readEndArrayAndSkip(arraySize - 0);
    return new SuccessRedeem();
  },
  write(writer: CborWriter, value: SuccessRedeem): void {
    writer.writeStartArray(0);
    
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedRedeem", {
  read(reader: CborReader): FailedRedeem {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<RedeemError>('RedeemError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedRedeem(error);
  },
  write(writer: CborWriter, value: FailedRedeem): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<RedeemError>('RedeemError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IUploadFileResult implements IIonUnion<IUploadFileResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessUploadFile(): this is SuccessUploadFile {
    return this.UnionKey === "SuccessUploadFile";
  }
  public isFailedUploadFile(): this is FailedUploadFile {
    return this.UnionKey === "FailedUploadFile";
  }

}


export class SuccessUploadFile extends IUploadFileResult
{
  constructor(public blobId: guid) { super(); }

  UnionKey: string = "SuccessUploadFile";
  UnionIndex: number = 0;
}

export class FailedUploadFile extends IUploadFileResult
{
  constructor(public error: UploadFileError) { super(); }

  UnionKey: string = "FailedUploadFile";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IUploadFileResult", {
  read(reader: CborReader): IUploadFileResult {
    reader.readStartArray();
    let value: IUploadFileResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessUploadFile>("SuccessUploadFile").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedUploadFile>("FailedUploadFile").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IUploadFileResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessUploadFile>("SuccessUploadFile").write(writer, value as SuccessUploadFile);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedUploadFile>("FailedUploadFile").write(writer, value as FailedUploadFile);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessUploadFile", {
  read(reader: CborReader): SuccessUploadFile {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const blobId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new SuccessUploadFile(blobId);
  },
  write(writer: CborWriter, value: SuccessUploadFile): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<guid>('guid').write(writer, value.blobId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedUploadFile", {
  read(reader: CborReader): FailedUploadFile {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<UploadFileError>('UploadFileError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedUploadFile(error);
  },
  write(writer: CborWriter, value: FailedUploadFile): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<UploadFileError>('UploadFileError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class ICreateSpaceResult implements IIonUnion<ICreateSpaceResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessCreateSpace(): this is SuccessCreateSpace {
    return this.UnionKey === "SuccessCreateSpace";
  }
  public isFailedCreateSpace(): this is FailedCreateSpace {
    return this.UnionKey === "FailedCreateSpace";
  }

}


export class SuccessCreateSpace extends ICreateSpaceResult
{
  constructor(public space: ArgonSpaceBase) { super(); }

  UnionKey: string = "SuccessCreateSpace";
  UnionIndex: number = 0;
}

export class FailedCreateSpace extends ICreateSpaceResult
{
  constructor(public error: CreateSpaceError) { super(); }

  UnionKey: string = "FailedCreateSpace";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("ICreateSpaceResult", {
  read(reader: CborReader): ICreateSpaceResult {
    reader.readStartArray();
    let value: ICreateSpaceResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessCreateSpace>("SuccessCreateSpace").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedCreateSpace>("FailedCreateSpace").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: ICreateSpaceResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessCreateSpace>("SuccessCreateSpace").write(writer, value as SuccessCreateSpace);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedCreateSpace>("FailedCreateSpace").write(writer, value as FailedCreateSpace);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessCreateSpace", {
  read(reader: CborReader): SuccessCreateSpace {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const space = IonFormatterStorage.get<ArgonSpaceBase>('ArgonSpaceBase').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new SuccessCreateSpace(space);
  },
  write(writer: CborWriter, value: SuccessCreateSpace): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<ArgonSpaceBase>('ArgonSpaceBase').write(writer, value.space);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedCreateSpace", {
  read(reader: CborReader): FailedCreateSpace {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<CreateSpaceError>('CreateSpaceError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedCreateSpace(error);
  },
  write(writer: CborWriter, value: FailedCreateSpace): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<CreateSpaceError>('CreateSpaceError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IAuthorizeResult implements IIonUnion<IAuthorizeResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessAuthorize(): this is SuccessAuthorize {
    return this.UnionKey === "SuccessAuthorize";
  }
  public isFailedAuthorize(): this is FailedAuthorize {
    return this.UnionKey === "FailedAuthorize";
  }

}


export class SuccessAuthorize extends IAuthorizeResult
{
  constructor(public token: string, public refreshToken: string | null) { super(); }

  UnionKey: string = "SuccessAuthorize";
  UnionIndex: number = 0;
}

export class FailedAuthorize extends IAuthorizeResult
{
  constructor(public error: AuthorizationError) { super(); }

  UnionKey: string = "FailedAuthorize";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IAuthorizeResult", {
  read(reader: CborReader): IAuthorizeResult {
    reader.readStartArray();
    let value: IAuthorizeResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessAuthorize>("SuccessAuthorize").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedAuthorize>("FailedAuthorize").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IAuthorizeResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessAuthorize>("SuccessAuthorize").write(writer, value as SuccessAuthorize);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedAuthorize>("FailedAuthorize").write(writer, value as FailedAuthorize);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessAuthorize", {
  read(reader: CborReader): SuccessAuthorize {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    const refreshToken = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SuccessAuthorize(token, refreshToken);
  },
  write(writer: CborWriter, value: SuccessAuthorize): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    IonFormatterStorage.writeNullable<string>(writer, value.refreshToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedAuthorize", {
  read(reader: CborReader): FailedAuthorize {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<AuthorizationError>('AuthorizationError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedAuthorize(error);
  },
  write(writer: CborWriter, value: FailedAuthorize): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<AuthorizationError>('AuthorizationError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IRegistrationResult implements IIonUnion<IRegistrationResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessRegistration(): this is SuccessRegistration {
    return this.UnionKey === "SuccessRegistration";
  }
  public isFailedRegistration(): this is FailedRegistration {
    return this.UnionKey === "FailedRegistration";
  }

}


export class SuccessRegistration extends IRegistrationResult
{
  constructor(public token: string, public refreshToken: string | null) { super(); }

  UnionKey: string = "SuccessRegistration";
  UnionIndex: number = 0;
}

export class FailedRegistration extends IRegistrationResult
{
  constructor(public error: RegistrationError, public field: string | null, public message: string | null) { super(); }

  UnionKey: string = "FailedRegistration";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IRegistrationResult", {
  read(reader: CborReader): IRegistrationResult {
    reader.readStartArray();
    let value: IRegistrationResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessRegistration>("SuccessRegistration").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedRegistration>("FailedRegistration").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IRegistrationResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessRegistration>("SuccessRegistration").write(writer, value as SuccessRegistration);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedRegistration>("FailedRegistration").write(writer, value as FailedRegistration);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessRegistration", {
  read(reader: CborReader): SuccessRegistration {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    const refreshToken = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 2);
    return new SuccessRegistration(token, refreshToken);
  },
  write(writer: CborWriter, value: SuccessRegistration): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    IonFormatterStorage.writeNullable<string>(writer, value.refreshToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedRegistration", {
  read(reader: CborReader): FailedRegistration {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<RegistrationError>('RegistrationError').read(reader);
    const field = IonFormatterStorage.readNullable<string>(reader, 'string');
    const message = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 3);
    return new FailedRegistration(error, field, message);
  },
  write(writer: CborWriter, value: FailedRegistration): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<RegistrationError>('RegistrationError').write(writer, value.error);
    IonFormatterStorage.writeNullable<string>(writer, value.field, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.message, 'string');
    writer.writeEndArray();
  }
});



export abstract class IJoinToSpaceResult implements IIonUnion<IJoinToSpaceResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessJoin(): this is SuccessJoin {
    return this.UnionKey === "SuccessJoin";
  }
  public isFailedJoin(): this is FailedJoin {
    return this.UnionKey === "FailedJoin";
  }

}


export class SuccessJoin extends IJoinToSpaceResult
{
  constructor(public space: ArgonSpace) { super(); }

  UnionKey: string = "SuccessJoin";
  UnionIndex: number = 0;
}

export class FailedJoin extends IJoinToSpaceResult
{
  constructor(public error: AcceptInviteError) { super(); }

  UnionKey: string = "FailedJoin";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IJoinToSpaceResult", {
  read(reader: CborReader): IJoinToSpaceResult {
    reader.readStartArray();
    let value: IJoinToSpaceResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessJoin>("SuccessJoin").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedJoin>("FailedJoin").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IJoinToSpaceResult): void {
    writer.writeStartArray(2);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0) {
        IonFormatterStorage.get<SuccessJoin>("SuccessJoin").write(writer, value as SuccessJoin);
    }
    else if (value.UnionIndex == 1) {
        IonFormatterStorage.get<FailedJoin>("FailedJoin").write(writer, value as FailedJoin);
    }
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessJoin", {
  read(reader: CborReader): SuccessJoin {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const space = IonFormatterStorage.get<ArgonSpace>('ArgonSpace').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new SuccessJoin(space);
  },
  write(writer: CborWriter, value: SuccessJoin): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<ArgonSpace>('ArgonSpace').write(writer, value.space);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedJoin", {
  read(reader: CborReader): FailedJoin {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const error = IonFormatterStorage.get<AcceptInviteError>('AcceptInviteError').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return new FailedJoin(error);
  },
  write(writer: CborWriter, value: FailedJoin): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<AcceptInviteError>('AcceptInviteError').write(writer, value.error);
    writer.writeEndArray();
  }
});



IonFormatterStorage.register("ArgonEntitlement", {
  read(reader: CborReader): ArgonEntitlement {
    const num = (IonFormatterStorage.get<u8>('u8').read(reader))
    return num as any;
  },
  write(writer: CborWriter, value: ArgonEntitlement): void {
    const casted: u8 = value as any;
    IonFormatterStorage.get<u8>('u8').write(writer, casted);
  }
});

IonFormatterStorage.register("ChannelEntitlementOverwrite", {
  read(reader: CborReader): ChannelEntitlementOverwrite {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const archetypeId = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    const serverMemberId = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    const allow = IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').read(reader);
    const deny = IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').read(reader);
    const creatorId = IonFormatterStorage.get<guid>('guid').read(reader);
    const id = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 7);
    return { channelId, archetypeId, serverMemberId, allow, deny, creatorId, id };
  },
  write(writer: CborWriter, value: ChannelEntitlementOverwrite): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.writeNullable<guid>(writer, value.archetypeId, 'guid');
    IonFormatterStorage.writeNullable<guid>(writer, value.serverMemberId, 'guid');
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, value.allow);
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, value.deny);
    IonFormatterStorage.get<guid>('guid').write(writer, value.creatorId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.id);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("Archetype", {
  read(reader: CborReader): Archetype {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<guid>('guid').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.get<string>('string').read(reader);
    const isMentionable = IonFormatterStorage.get<bool>('bool').read(reader);
    const colour = IonFormatterStorage.get<i4>('i4').read(reader);
    const isHidden = IonFormatterStorage.get<bool>('bool').read(reader);
    const isLocked = IonFormatterStorage.get<bool>('bool').read(reader);
    const isGroup = IonFormatterStorage.get<bool>('bool').read(reader);
    const isDefault = IonFormatterStorage.get<bool>('bool').read(reader);
    const iconFileId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const entitlement = IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').read(reader);
    reader.readEndArrayAndSkip(arraySize - 12);
    return { id, spaceId, name, description, isMentionable, colour, isHidden, isLocked, isGroup, isDefault, iconFileId, entitlement };
  },
  write(writer: CborWriter, value: Archetype): void {
    writer.writeStartArray(12);
    IonFormatterStorage.get<guid>('guid').write(writer, value.id);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<string>('string').write(writer, value.description);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isMentionable);
    IonFormatterStorage.get<i4>('i4').write(writer, value.colour);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isHidden);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isLocked);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isGroup);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isDefault);
    IonFormatterStorage.writeNullable<string>(writer, value.iconFileId, 'string');
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, value.entitlement);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelType", {
  read(reader: CborReader): ChannelType {
    const num = (IonFormatterStorage.get<u2>('u2').read(reader))
    return ChannelType[num] !== undefined ? num as ChannelType : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: ChannelType): void {
    const casted: u2 = value;
    IonFormatterStorage.get<u2>('u2').write(writer, casted);
  }
});

IonFormatterStorage.register("CreateChannelRequest", {
  read(reader: CborReader): CreateChannelRequest {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const kind = IonFormatterStorage.get<ChannelType>('ChannelType').read(reader);
    const desc = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return { spaceId, name, kind, desc };
  },
  write(writer: CborWriter, value: CreateChannelRequest): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<ChannelType>('ChannelType').write(writer, value.kind);
    IonFormatterStorage.get<string>('string').write(writer, value.desc);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonChannel", {
  read(reader: CborReader): ArgonChannel {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const type = IonFormatterStorage.get<ChannelType>('ChannelType').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.readNullable<string>(reader, 'string');
    const categoryId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 6);
    return { type, spaceId, channelId, name, description, categoryId };
  },
  write(writer: CborWriter, value: ArgonChannel): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<ChannelType>('ChannelType').write(writer, value.type);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.writeNullable<string>(writer, value.description, 'string');
    IonFormatterStorage.get<guid>('guid').write(writer, value.categoryId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("RealtimeChannel", {
  read(reader: CborReader): RealtimeChannel {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const channel = IonFormatterStorage.get<ArgonChannel>('ArgonChannel').read(reader);
    const users = IonFormatterStorage.readArray<RealtimeChannelUser>(reader, 'RealtimeChannelUser');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { channel, users };
  },
  write(writer: CborWriter, value: RealtimeChannel): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<ArgonChannel>('ArgonChannel').write(writer, value.channel);
    IonFormatterStorage.writeArray<RealtimeChannelUser>(writer, value.users, 'RealtimeChannelUser');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonMessage", {
  read(reader: CborReader): ArgonMessage {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const messageId = IonFormatterStorage.get<i8>('i8').read(reader);
    const replyId = IonFormatterStorage.readNullable<i8>(reader, 'i8');
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const text = IonFormatterStorage.get<string>('string').read(reader);
    const entities = IonFormatterStorage.readArray<IMessageEntity>(reader, 'IMessageEntity');
    const timeSent = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const sender = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 8);
    return { messageId, replyId, channelId, spaceId, text, entities, timeSent, sender };
  },
  write(writer: CborWriter, value: ArgonMessage): void {
    writer.writeStartArray(8);
    IonFormatterStorage.get<i8>('i8').write(writer, value.messageId);
    IonFormatterStorage.writeNullable<i8>(writer, value.replyId, 'i8');
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.text);
    IonFormatterStorage.writeArray<IMessageEntity>(writer, value.entities, 'IMessageEntity');
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.timeSent);
    IonFormatterStorage.get<guid>('guid').write(writer, value.sender);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelMemberState", {
  read(reader: CborReader): ChannelMemberState {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return num as any;
  },
  write(writer: CborWriter, value: ChannelMemberState): void {
    const casted: u4 = value as any;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RealtimeChannelUser", {
  read(reader: CborReader): RealtimeChannelUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const state = IonFormatterStorage.get<ChannelMemberState>('ChannelMemberState').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { userId, state };
  },
  write(writer: CborWriter, value: RealtimeChannelUser): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<ChannelMemberState>('ChannelMemberState').write(writer, value.state);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ActivityPresenceKind", {
  read(reader: CborReader): ActivityPresenceKind {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return ActivityPresenceKind[num] !== undefined ? num as ActivityPresenceKind : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: ActivityPresenceKind): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("UserActivityPresence", {
  read(reader: CborReader): UserActivityPresence {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const kind = IonFormatterStorage.get<ActivityPresenceKind>('ActivityPresenceKind').read(reader);
    const startTimestampSeconds = IonFormatterStorage.get<u8>('u8').read(reader);
    const titleName = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { kind, startTimestampSeconds, titleName };
  },
  write(writer: CborWriter, value: UserActivityPresence): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<ActivityPresenceKind>('ActivityPresenceKind').write(writer, value.kind);
    IonFormatterStorage.get<u8>('u8').write(writer, value.startTimestampSeconds);
    IonFormatterStorage.get<string>('string').write(writer, value.titleName);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("JoinToChannelError", {
  read(reader: CborReader): JoinToChannelError {
    const num = (IonFormatterStorage.get<u2>('u2').read(reader))
    return JoinToChannelError[num] !== undefined ? num as JoinToChannelError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: JoinToChannelError): void {
    const casted: u2 = value;
    IonFormatterStorage.get<u2>('u2').write(writer, casted);
  }
});

IonFormatterStorage.register("EntityType", {
  read(reader: CborReader): EntityType {
    const num = (IonFormatterStorage.get<u2>('u2').read(reader))
    return EntityType[num] !== undefined ? num as EntityType : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: EntityType): void {
    const casted: u2 = value;
    IonFormatterStorage.get<u2>('u2').write(writer, casted);
  }
});

IonFormatterStorage.register("FriendRequest", {
  read(reader: CborReader): FriendRequest {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const requestId = IonFormatterStorage.get<guid>('guid').read(reader);
    const fromUser = IonFormatterStorage.get<guid>('guid').read(reader);
    const toUser = IonFormatterStorage.get<guid>('guid').read(reader);
    const requestTime = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 4);
    return { requestId, fromUser, toUser, requestTime };
  },
  write(writer: CborWriter, value: FriendRequest): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.requestId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.fromUser);
    IonFormatterStorage.get<guid>('guid').write(writer, value.toUser);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.requestTime);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FriendRequestStatus", {
  read(reader: CborReader): FriendRequestStatus {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return FriendRequestStatus[num] !== undefined ? num as FriendRequestStatus : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: FriendRequestStatus): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("BadAuthKind", {
  read(reader: CborReader): BadAuthKind {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return BadAuthKind[num] !== undefined ? num as BadAuthKind : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: BadAuthKind): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("InventoryItem", {
  read(reader: CborReader): InventoryItem {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<string>('string').read(reader);
    const instanceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const grantedDate = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const usable = IonFormatterStorage.get<bool>('bool').read(reader);
    const giftable = IonFormatterStorage.get<bool>('bool').read(reader);
    const usableVector = IonFormatterStorage.readNullable<ItemUseVector>(reader, 'ItemUseVector');
    const receivedFrom = IonFormatterStorage.readNullable<guid>(reader, 'guid');
    const ttl = IonFormatterStorage.readNullable<duration>(reader, 'duration');
    reader.readEndArrayAndSkip(arraySize - 8);
    return { id, instanceId, grantedDate, usable, giftable, usableVector, receivedFrom, ttl };
  },
  write(writer: CborWriter, value: InventoryItem): void {
    writer.writeStartArray(8);
    IonFormatterStorage.get<string>('string').write(writer, value.id);
    IonFormatterStorage.get<guid>('guid').write(writer, value.instanceId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.grantedDate);
    IonFormatterStorage.get<bool>('bool').write(writer, value.usable);
    IonFormatterStorage.get<bool>('bool').write(writer, value.giftable);
    IonFormatterStorage.writeNullable<ItemUseVector>(writer, value.usableVector, 'ItemUseVector');
    IonFormatterStorage.writeNullable<guid>(writer, value.receivedFrom, 'guid');
    IonFormatterStorage.writeNullable<duration>(writer, value.ttl, 'duration');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("DetailedInventoryItem", {
  read(reader: CborReader): DetailedInventoryItem {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const item = IonFormatterStorage.get<InventoryItem>('InventoryItem').read(reader);
    const containedItem = IonFormatterStorage.readNullable<InventoryItem>(reader, 'InventoryItem');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { item, containedItem };
  },
  write(writer: CborWriter, value: DetailedInventoryItem): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<InventoryItem>('InventoryItem').write(writer, value.item);
    IonFormatterStorage.writeNullable<InventoryItem>(writer, value.containedItem, 'InventoryItem');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("InventoryNotification", {
  read(reader: CborReader): InventoryNotification {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const inventoryItemId = IonFormatterStorage.get<guid>('guid').read(reader);
    const id = IonFormatterStorage.get<string>('string').read(reader);
    const createdAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { inventoryItemId, id, createdAt };
  },
  write(writer: CborWriter, value: InventoryNotification): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<guid>('guid').write(writer, value.inventoryItemId);
    IonFormatterStorage.get<string>('string').write(writer, value.id);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.createdAt);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ItemUseVector", {
  read(reader: CborReader): ItemUseVector {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return ItemUseVector[num] !== undefined ? num as ItemUseVector : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: ItemUseVector): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RedeemError", {
  read(reader: CborReader): RedeemError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return RedeemError[num] !== undefined ? num as RedeemError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: RedeemError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RtcEndpoint", {
  read(reader: CborReader): RtcEndpoint {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const endpoint = IonFormatterStorage.get<string>('string').read(reader);
    const ices = IonFormatterStorage.readArray<IceEndpoint>(reader, 'IceEndpoint');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { endpoint, ices };
  },
  write(writer: CborWriter, value: RtcEndpoint): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.endpoint);
    IonFormatterStorage.writeArray<IceEndpoint>(writer, value.ices, 'IceEndpoint');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MeetInfo", {
  read(reader: CborReader): MeetInfo {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const title = IonFormatterStorage.get<string>('string').read(reader);
    const startTime = IonFormatterStorage.get<u4>('u4').read(reader);
    const roomId = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { title, startTime, roomId };
  },
  write(writer: CborWriter, value: MeetInfo): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.title);
    IonFormatterStorage.get<u4>('u4').write(writer, value.startTime);
    IonFormatterStorage.get<string>('string').write(writer, value.roomId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("JoinMeetResponse", {
  read(reader: CborReader): JoinMeetResponse {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const voiceToken = IonFormatterStorage.get<string>('string').read(reader);
    const endpoint = IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').read(reader);
    const meetInfo = IonFormatterStorage.get<MeetInfo>('MeetInfo').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { voiceToken, endpoint, meetInfo };
  },
  write(writer: CborWriter, value: JoinMeetResponse): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.voiceToken);
    IonFormatterStorage.get<RtcEndpoint>('RtcEndpoint').write(writer, value.endpoint);
    IonFormatterStorage.get<MeetInfo>('MeetInfo').write(writer, value.meetInfo);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("IceEndpoint", {
  read(reader: CborReader): IceEndpoint {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const endpoint = IonFormatterStorage.get<string>('string').read(reader);
    const username = IonFormatterStorage.get<string>('string').read(reader);
    const password = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { endpoint, username, password };
  },
  write(writer: CborWriter, value: IceEndpoint): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.endpoint);
    IonFormatterStorage.get<string>('string').write(writer, value.username);
    IonFormatterStorage.get<string>('string').write(writer, value.password);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MeetJoinError", {
  read(reader: CborReader): MeetJoinError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return MeetJoinError[num] !== undefined ? num as MeetJoinError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: MeetJoinError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("ArgonSpaceBase", {
  read(reader: CborReader): ArgonSpaceBase {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.get<string>('string').read(reader);
    const avatarFieldId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const topBannerFileId = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 5);
    return { spaceId, name, description, avatarFieldId, topBannerFileId };
  },
  write(writer: CborWriter, value: ArgonSpaceBase): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<string>('string').write(writer, value.description);
    IonFormatterStorage.writeNullable<string>(writer, value.avatarFieldId, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.topBannerFileId, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonSpace", {
  read(reader: CborReader): ArgonSpace {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.get<string>('string').read(reader);
    const avatarFieldId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const topBannerFileId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const channels = IonFormatterStorage.readArray<ArgonChannel>(reader, 'ArgonChannel');
    const members = IonFormatterStorage.readArray<SpaceMember>(reader, 'SpaceMember');
    const archetypes = IonFormatterStorage.readArray<Archetype>(reader, 'Archetype');
    reader.readEndArrayAndSkip(arraySize - 8);
    return { spaceId, name, description, avatarFieldId, topBannerFileId, channels, members, archetypes };
  },
  write(writer: CborWriter, value: ArgonSpace): void {
    writer.writeStartArray(8);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<string>('string').write(writer, value.description);
    IonFormatterStorage.writeNullable<string>(writer, value.avatarFieldId, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.topBannerFileId, 'string');
    IonFormatterStorage.writeArray<ArgonChannel>(writer, value.channels, 'ArgonChannel');
    IonFormatterStorage.writeArray<SpaceMember>(writer, value.members, 'SpaceMember');
    IonFormatterStorage.writeArray<Archetype>(writer, value.archetypes, 'Archetype');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArchetypeGroup", {
  read(reader: CborReader): ArchetypeGroup {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const archetype = IonFormatterStorage.get<Archetype>('Archetype').read(reader);
    const members = IonFormatterStorage.readArray<guid>(reader, 'guid');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { archetype, members };
  },
  write(writer: CborWriter, value: ArchetypeGroup): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, value.archetype);
    IonFormatterStorage.writeArray<guid>(writer, value.members, 'guid');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SpaceMemberArchetype", {
  read(reader: CborReader): SpaceMemberArchetype {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const serverMemberId = IonFormatterStorage.get<guid>('guid').read(reader);
    const archetypeId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { serverMemberId, archetypeId };
  },
  write(writer: CborWriter, value: SpaceMemberArchetype): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<guid>('guid').write(writer, value.serverMemberId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.archetypeId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonUser", {
  read(reader: CborReader): ArgonUser {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const username = IonFormatterStorage.get<string>('string').read(reader);
    const displayName = IonFormatterStorage.get<string>('string').read(reader);
    const avatarFileId = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 4);
    return { userId, username, displayName, avatarFileId };
  },
  write(writer: CborWriter, value: ArgonUser): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<string>('string').write(writer, value.username);
    IonFormatterStorage.get<string>('string').write(writer, value.displayName);
    IonFormatterStorage.writeNullable<string>(writer, value.avatarFileId, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("SpaceMember", {
  read(reader: CborReader): SpaceMember {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const joinedAt = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const memberId = IonFormatterStorage.get<guid>('guid').read(reader);
    const user = IonFormatterStorage.get<ArgonUser>('ArgonUser').read(reader);
    const archetypes = IonFormatterStorage.readArray<SpaceMemberArchetype>(reader, 'SpaceMemberArchetype');
    reader.readEndArrayAndSkip(arraySize - 6);
    return { userId, spaceId, joinedAt, memberId, user, archetypes };
  },
  write(writer: CborWriter, value: SpaceMember): void {
    writer.writeStartArray(6);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.joinedAt);
    IonFormatterStorage.get<guid>('guid').write(writer, value.memberId);
    IonFormatterStorage.get<ArgonUser>('ArgonUser').write(writer, value.user);
    IonFormatterStorage.writeArray<SpaceMemberArchetype>(writer, value.archetypes, 'SpaceMemberArchetype');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserStatus", {
  read(reader: CborReader): UserStatus {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return UserStatus[num] !== undefined ? num as UserStatus : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: UserStatus): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RealtimeServerMember", {
  read(reader: CborReader): RealtimeServerMember {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const member = IonFormatterStorage.get<SpaceMember>('SpaceMember').read(reader);
    const status = IonFormatterStorage.get<UserStatus>('UserStatus').read(reader);
    const presence = IonFormatterStorage.readNullable<UserActivityPresence>(reader, 'UserActivityPresence');
    reader.readEndArrayAndSkip(arraySize - 3);
    return { member, status, presence };
  },
  write(writer: CborWriter, value: RealtimeServerMember): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<SpaceMember>('SpaceMember').write(writer, value.member);
    IonFormatterStorage.get<UserStatus>('UserStatus').write(writer, value.status);
    IonFormatterStorage.writeNullable<UserActivityPresence>(writer, value.presence, 'UserActivityPresence');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("InviteCode", {
  read(reader: CborReader): InviteCode {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const inviteCode = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return { inviteCode };
  },
  write(writer: CborWriter, value: InviteCode): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<string>('string').write(writer, value.inviteCode);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("InviteCodeEntity", {
  read(reader: CborReader): InviteCodeEntity {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const code = IonFormatterStorage.get<InviteCode>('InviteCode').read(reader);
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const issuerId = IonFormatterStorage.get<guid>('guid').read(reader);
    const expireTime = IonFormatterStorage.get<datetime>('datetime').read(reader);
    const used = IonFormatterStorage.get<u8>('u8').read(reader);
    reader.readEndArrayAndSkip(arraySize - 5);
    return { code, spaceId, issuerId, expireTime, used };
  },
  write(writer: CborWriter, value: InviteCodeEntity): void {
    writer.writeStartArray(5);
    IonFormatterStorage.get<InviteCode>('InviteCode').write(writer, value.code);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.issuerId);
    IonFormatterStorage.get<datetime>('datetime').write(writer, value.expireTime);
    IonFormatterStorage.get<u8>('u8').write(writer, value.used);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonUserProfile", {
  read(reader: CborReader): ArgonUserProfile {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const customStatus = IonFormatterStorage.readNullable<string>(reader, 'string');
    const customStatusIconId = IonFormatterStorage.readNullable<string>(reader, 'string');
    const bannerFileID = IonFormatterStorage.readNullable<string>(reader, 'string');
    const dateOfBirth = IonFormatterStorage.readNullable<dateonly>(reader, 'dateonly');
    const bio = IonFormatterStorage.readNullable<string>(reader, 'string');
    const isPremium = IonFormatterStorage.get<bool>('bool').read(reader);
    const badges = IonFormatterStorage.readArray<string>(reader, 'string');
    const archetypes = IonFormatterStorage.readArray<SpaceMemberArchetype>(reader, 'SpaceMemberArchetype');
    reader.readEndArrayAndSkip(arraySize - 9);
    return { userId, customStatus, customStatusIconId, bannerFileID, dateOfBirth, bio, isPremium, badges, archetypes };
  },
  write(writer: CborWriter, value: ArgonUserProfile): void {
    writer.writeStartArray(9);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.writeNullable<string>(writer, value.customStatus, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.customStatusIconId, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.bannerFileID, 'string');
    IonFormatterStorage.writeNullable<dateonly>(writer, value.dateOfBirth, 'dateonly');
    IonFormatterStorage.writeNullable<string>(writer, value.bio, 'string');
    IonFormatterStorage.get<bool>('bool').write(writer, value.isPremium);
    IonFormatterStorage.writeArray<string>(writer, value.badges, 'string');
    IonFormatterStorage.writeArray<SpaceMemberArchetype>(writer, value.archetypes, 'SpaceMemberArchetype');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArgonIonTicket", {
  read(reader: CborReader): ArgonIonTicket {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const ip = IonFormatterStorage.get<string>('string').read(reader);
    const ray = IonFormatterStorage.get<string>('string').read(reader);
    const clientName = IonFormatterStorage.get<string>('string').read(reader);
    const hostName = IonFormatterStorage.get<string>('string').read(reader);
    const appId = IonFormatterStorage.get<string>('string').read(reader);
    const sessionId = IonFormatterStorage.get<guid>('guid').read(reader);
    const machineId = IonFormatterStorage.get<string>('string').read(reader);
    const region = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 9);
    return { userId, ip, ray, clientName, hostName, appId, sessionId, machineId, region };
  },
  write(writer: CborWriter, value: ArgonIonTicket): void {
    writer.writeStartArray(9);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<string>('string').write(writer, value.ip);
    IonFormatterStorage.get<string>('string').write(writer, value.ray);
    IonFormatterStorage.get<string>('string').write(writer, value.clientName);
    IonFormatterStorage.get<string>('string').write(writer, value.hostName);
    IonFormatterStorage.get<string>('string').write(writer, value.appId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.sessionId);
    IonFormatterStorage.get<string>('string').write(writer, value.machineId);
    IonFormatterStorage.get<string>('string').write(writer, value.region);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserEditInput", {
  read(reader: CborReader): UserEditInput {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const displayName = IonFormatterStorage.readNullable<string>(reader, 'string');
    const avatarId = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 2);
    return { displayName, avatarId };
  },
  write(writer: CborWriter, value: UserEditInput): void {
    writer.writeStartArray(2);
    IonFormatterStorage.writeNullable<string>(writer, value.displayName, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.avatarId, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FeatureFlag", {
  read(reader: CborReader): FeatureFlag {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const key = IonFormatterStorage.get<string>('string').read(reader);
    const enabled = IonFormatterStorage.get<bool>('bool').read(reader);
    const variant = IonFormatterStorage.readNullable<string>(reader, 'string');
    const parameters = IonFormatterStorage.readArray<FeatureFlagParameter>(reader, 'FeatureFlagParameter');
    reader.readEndArrayAndSkip(arraySize - 4);
    return { key, enabled, variant, parameters };
  },
  write(writer: CborWriter, value: FeatureFlag): void {
    writer.writeStartArray(4);
    IonFormatterStorage.get<string>('string').write(writer, value.key);
    IonFormatterStorage.get<bool>('bool').write(writer, value.enabled);
    IonFormatterStorage.writeNullable<string>(writer, value.variant, 'string');
    IonFormatterStorage.writeArray<FeatureFlagParameter>(writer, value.parameters, 'FeatureFlagParameter');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FeatureFlagParameter", {
  read(reader: CborReader): FeatureFlagParameter {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const key = IonFormatterStorage.get<string>('string').read(reader);
    const value = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { key, value };
  },
  write(writer: CborWriter, value: FeatureFlagParameter): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.key);
    IonFormatterStorage.get<string>('string').write(writer, value.value);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("CreateServerRequest", {
  read(reader: CborReader): CreateServerRequest {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const name = IonFormatterStorage.get<string>('string').read(reader);
    const description = IonFormatterStorage.get<string>('string').read(reader);
    const avatarFieldId = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 3);
    return { name, description, avatarFieldId };
  },
  write(writer: CborWriter, value: CreateServerRequest): void {
    writer.writeStartArray(3);
    IonFormatterStorage.get<string>('string').write(writer, value.name);
    IonFormatterStorage.get<string>('string').write(writer, value.description);
    IonFormatterStorage.get<string>('string').write(writer, value.avatarFieldId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserCredentialsInput", {
  read(reader: CborReader): UserCredentialsInput {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const email = IonFormatterStorage.readNullable<string>(reader, 'string');
    const phone = IonFormatterStorage.readNullable<string>(reader, 'string');
    const username = IonFormatterStorage.readNullable<string>(reader, 'string');
    const password = IonFormatterStorage.readNullable<string>(reader, 'string');
    const otpCode = IonFormatterStorage.readNullable<string>(reader, 'string');
    const captchaToken = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 6);
    return { email, phone, username, password, otpCode, captchaToken };
  },
  write(writer: CborWriter, value: UserCredentialsInput): void {
    writer.writeStartArray(6);
    IonFormatterStorage.writeNullable<string>(writer, value.email, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.phone, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.username, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.password, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.otpCode, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.captchaToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserLoginInput", {
  read(reader: CborReader): UserLoginInput {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const email = IonFormatterStorage.readNullable<string>(reader, 'string');
    const phone = IonFormatterStorage.readNullable<string>(reader, 'string');
    const username = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 3);
    return { email, phone, username };
  },
  write(writer: CborWriter, value: UserLoginInput): void {
    writer.writeStartArray(3);
    IonFormatterStorage.writeNullable<string>(writer, value.email, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.phone, 'string');
    IonFormatterStorage.writeNullable<string>(writer, value.username, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("NewUserCredentialsInput", {
  read(reader: CborReader): NewUserCredentialsInput {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const email = IonFormatterStorage.get<string>('string').read(reader);
    const username = IonFormatterStorage.get<string>('string').read(reader);
    const password = IonFormatterStorage.get<string>('string').read(reader);
    const displayName = IonFormatterStorage.get<string>('string').read(reader);
    const argreeTos = IonFormatterStorage.get<bool>('bool').read(reader);
    const birthDate = IonFormatterStorage.get<dateonly>('dateonly').read(reader);
    const argreeOptionalEmails = IonFormatterStorage.get<bool>('bool').read(reader);
    const captchaToken = IonFormatterStorage.readNullable<string>(reader, 'string');
    reader.readEndArrayAndSkip(arraySize - 8);
    return { email, username, password, displayName, argreeTos, birthDate, argreeOptionalEmails, captchaToken };
  },
  write(writer: CborWriter, value: NewUserCredentialsInput): void {
    writer.writeStartArray(8);
    IonFormatterStorage.get<string>('string').write(writer, value.email);
    IonFormatterStorage.get<string>('string').write(writer, value.username);
    IonFormatterStorage.get<string>('string').write(writer, value.password);
    IonFormatterStorage.get<string>('string').write(writer, value.displayName);
    IonFormatterStorage.get<bool>('bool').write(writer, value.argreeTos);
    IonFormatterStorage.get<dateonly>('dateonly').write(writer, value.birthDate);
    IonFormatterStorage.get<bool>('bool').write(writer, value.argreeOptionalEmails);
    IonFormatterStorage.writeNullable<string>(writer, value.captchaToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UploadFileError", {
  read(reader: CborReader): UploadFileError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return UploadFileError[num] !== undefined ? num as UploadFileError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: UploadFileError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("CreateSpaceError", {
  read(reader: CborReader): CreateSpaceError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return CreateSpaceError[num] !== undefined ? num as CreateSpaceError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: CreateSpaceError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("AcceptInviteError", {
  read(reader: CborReader): AcceptInviteError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return AcceptInviteError[num] !== undefined ? num as AcceptInviteError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: AcceptInviteError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("AuthorizationError", {
  read(reader: CborReader): AuthorizationError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return AuthorizationError[num] !== undefined ? num as AuthorizationError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: AuthorizationError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("RegistrationError", {
  read(reader: CborReader): RegistrationError {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return RegistrationError[num] !== undefined ? num as RegistrationError : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: RegistrationError): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("LockdownReason", {
  read(reader: CborReader): LockdownReason {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return LockdownReason[num] !== undefined ? num as LockdownReason : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: LockdownReason): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("LockdownSeverity", {
  read(reader: CborReader): LockdownSeverity {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return LockdownSeverity[num] !== undefined ? num as LockdownSeverity : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: LockdownSeverity): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});



export interface IArchetypeInteraction extends IIonService
{
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  CreateArchetype(spaceId: guid, name: string): Promise<Archetype>;
  UpdateArchetype(spaceId: guid, data: Archetype): Promise<Archetype>;
  SetArchetypeToMember(spaceId: guid, memberId: guid, archetypeId: guid, isGrant: bool): Promise<bool>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  UpsertArchetypeEntitlementForChannel(spaceId: guid, channelId: guid, archetypeId: guid, deny: ArgonEntitlement, allow: ArgonEntitlement): Promise<ChannelEntitlementOverwrite | null>;
}




export interface IChannelInteraction extends IIonService
{
  CreateChannel(spaceId: guid, channelId: guid, request: CreateChannelRequest): Promise<void>;
  DeleteChannel(spaceId: guid, channelId: guid): Promise<void>;
  GetChannels(spaceId: guid, channelId: guid): Promise<IonArray<RealtimeChannel>>;
  QueryMessages(spaceId: guid, channelId: guid, from: i8 | null, limit: i4): Promise<IonArray<ArgonMessage>>;
  SendMessage(spaceId: guid, channelId: guid, text: string, entities: IonArray<IMessageEntity>, randomId: i8, replyTo: i8 | null): Promise<i8>;
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<void>;
  Interlink(spaceId: guid, channelId: guid): Promise<IInterlinkResult>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<bool>;
}


export interface IEventBus extends IIonService
{
  ForServer(spaceId: guid): AsyncIterable<IArgonEvent>;
  Dispatch(ev: IArgonClientEvent): Promise<void>;
  Pipe(ev: AsyncIterable<IArgonClientEvent>): AsyncIterable<IArgonEvent>;
}




export interface IFriendsInteraction extends IIonService
{
}




export interface IIdentityInteraction extends IIonService
{
  Authorize(data: UserCredentialsInput): Promise<IAuthorizeResult>;
  Registration(data: NewUserCredentialsInput): Promise<IRegistrationResult>;
  BeginResetPassword(email: string): Promise<bool>;
  ResetPassword(email: string, otpCode: string, newPassword: string): Promise<IAuthorizeResult>;
  GetAuthorizationScenario(): Promise<string>;
  GetAuthorizationScenarioFor(data: UserLoginInput): Promise<string>;
  GetMyAuthorization(token: string, refreshToken: string | null): Promise<IMyAuthStatus>;
}




export interface IInventoryInteraction extends IIonService
{
  GetMyInventoryItems(): Promise<IonArray<InventoryItem>>;
  MarkSeen(itemIds: IonArray<guid>): Promise<void>;
  GetNotifications(): Promise<IonArray<InventoryNotification>>;
  RedeemCode(code: string): Promise<IRedeemResult>;
  UseItem(itemId: guid): Promise<bool>;
}




export interface IMeetingInteraction extends IIonService
{
  Join(inviteCode: string, username: string): Promise<void>;
  CreateMeetingLink(): Promise<string>;
  SetDefaultPermissions(roomId: string, permissions: i8): Promise<void>;
  BeginRecordAsync(roomId: string): Promise<string>;
  EndRecordAsync(roomId: string): Promise<void>;
}




export interface IServerInteraction extends IIonService
{
  GetMembers(spaceId: guid): Promise<IonArray<RealtimeServerMember>>;
  GetMember(spaceId: guid, userId: guid): Promise<RealtimeServerMember>;
  GetInviteCodes(spaceId: guid): Promise<IonArray<InviteCodeEntity>>;
  CreateInviteCode(spaceId: guid): Promise<InviteCode>;
  PrefetchUser(spaceId: guid, userId: guid): Promise<ArgonUser>;
  PrefetchProfile(spaceId: guid, userId: guid): Promise<ArgonUserProfile>;
  GetChannels(spaceId: guid): Promise<IonArray<RealtimeChannel>>;
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  BeginUploadSpaceProfileHeader(spaceId: guid): Promise<guid>;
  CompleteUploadSpaceProfileHeader(spaceId: guid, blobId: guid): Promise<void>;
  BeginUploadSpaceAvatar(spaceId: guid): Promise<guid>;
  CompleteUploadSpaceAvatar(spaceId: guid, blobId: guid): Promise<void>;
}






export interface IUserInteraction extends IIonService
{
  GetMe(): Promise<ArgonUser>;
  CreateSpace(request: CreateServerRequest): Promise<ICreateSpaceResult>;
  GetSpaces(): Promise<IonArray<ArgonSpaceBase>>;
  UpdateMe(request: UserEditInput): Promise<ArgonUser>;
  JoinToSpace(inviteCode: InviteCode): Promise<IJoinToSpaceResult>;
  BroadcastPresence(presence: UserActivityPresence): Promise<void>;
  RemoveBroadcastPresence(): Promise<void>;
  GetMyFeatures(): Promise<IonArray<FeatureFlag>>;
  GetMyProfile(): Promise<ArgonUserProfile>;
  BeginUploadAvatar(): Promise<IUploadFileResult>;
  CompleteUploadAvatar(blobId: guid): Promise<void>;
  BeginUploadProfileHeader(): Promise<IUploadFileResult>;
  CompleteUploadProfileHeader(blobId: guid): Promise<void>;
}




export interface IPreferenceInteraction extends IIonService
{
  SetPreference(scope: string, value: string): Promise<void>;
  GetPreference(scope: string, value: string): Promise<void>;
}




export interface IVoiceInteraction extends IIonService
{
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<bool>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<void>;
}




export interface IArchetypeInteraction extends IIonService
{
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  CreateArchetype(spaceId: guid, name: string): Promise<Archetype>;
  UpdateArchetype(spaceId: guid, data: Archetype): Promise<Archetype>;
  SetArchetypeToMember(spaceId: guid, memberId: guid, archetypeId: guid, isGrant: bool): Promise<bool>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  UpsertArchetypeEntitlementForChannel(spaceId: guid, channelId: guid, archetypeId: guid, deny: ArgonEntitlement, allow: ArgonEntitlement): Promise<ChannelEntitlementOverwrite | null>;
}




export interface IChannelInteraction extends IIonService
{
  CreateChannel(spaceId: guid, channelId: guid, request: CreateChannelRequest): Promise<void>;
  DeleteChannel(spaceId: guid, channelId: guid): Promise<void>;
  GetChannels(spaceId: guid, channelId: guid): Promise<IonArray<RealtimeChannel>>;
  QueryMessages(spaceId: guid, channelId: guid, from: i8 | null, limit: i4): Promise<IonArray<ArgonMessage>>;
  SendMessage(spaceId: guid, channelId: guid, text: string, entities: IonArray<IMessageEntity>, randomId: i8, replyTo: i8 | null): Promise<i8>;
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<void>;
  Interlink(spaceId: guid, channelId: guid): Promise<IInterlinkResult>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<bool>;
}


export interface IEventBus extends IIonService
{
  ForServer(spaceId: guid): AsyncIterable<IArgonEvent>;
  Dispatch(ev: IArgonClientEvent): Promise<void>;
  Pipe(ev: AsyncIterable<IArgonClientEvent>): AsyncIterable<IArgonEvent>;
}




export interface IFriendsInteraction extends IIonService
{
}




export interface IIdentityInteraction extends IIonService
{
  Authorize(data: UserCredentialsInput): Promise<IAuthorizeResult>;
  Registration(data: NewUserCredentialsInput): Promise<IRegistrationResult>;
  BeginResetPassword(email: string): Promise<bool>;
  ResetPassword(email: string, otpCode: string, newPassword: string): Promise<IAuthorizeResult>;
  GetAuthorizationScenario(): Promise<string>;
  GetAuthorizationScenarioFor(data: UserLoginInput): Promise<string>;
  GetMyAuthorization(token: string, refreshToken: string | null): Promise<IMyAuthStatus>;
}




export interface IInventoryInteraction extends IIonService
{
  GetMyInventoryItems(): Promise<IonArray<InventoryItem>>;
  MarkSeen(itemIds: IonArray<guid>): Promise<void>;
  GetNotifications(): Promise<IonArray<InventoryNotification>>;
  RedeemCode(code: string): Promise<IRedeemResult>;
  UseItem(itemId: guid): Promise<bool>;
}




export interface IMeetingInteraction extends IIonService
{
  Join(inviteCode: string, username: string): Promise<void>;
  CreateMeetingLink(): Promise<string>;
  SetDefaultPermissions(roomId: string, permissions: i8): Promise<void>;
  BeginRecordAsync(roomId: string): Promise<string>;
  EndRecordAsync(roomId: string): Promise<void>;
}




export interface IServerInteraction extends IIonService
{
  GetMembers(spaceId: guid): Promise<IonArray<RealtimeServerMember>>;
  GetMember(spaceId: guid, userId: guid): Promise<RealtimeServerMember>;
  GetInviteCodes(spaceId: guid): Promise<IonArray<InviteCodeEntity>>;
  CreateInviteCode(spaceId: guid): Promise<InviteCode>;
  PrefetchUser(spaceId: guid, userId: guid): Promise<ArgonUser>;
  PrefetchProfile(spaceId: guid, userId: guid): Promise<ArgonUserProfile>;
  GetChannels(spaceId: guid): Promise<IonArray<RealtimeChannel>>;
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  BeginUploadSpaceProfileHeader(spaceId: guid): Promise<guid>;
  CompleteUploadSpaceProfileHeader(spaceId: guid, blobId: guid): Promise<void>;
  BeginUploadSpaceAvatar(spaceId: guid): Promise<guid>;
  CompleteUploadSpaceAvatar(spaceId: guid, blobId: guid): Promise<void>;
}






export interface IUserInteraction extends IIonService
{
  GetMe(): Promise<ArgonUser>;
  CreateSpace(request: CreateServerRequest): Promise<ICreateSpaceResult>;
  GetSpaces(): Promise<IonArray<ArgonSpaceBase>>;
  UpdateMe(request: UserEditInput): Promise<ArgonUser>;
  JoinToSpace(inviteCode: InviteCode): Promise<IJoinToSpaceResult>;
  BroadcastPresence(presence: UserActivityPresence): Promise<void>;
  RemoveBroadcastPresence(): Promise<void>;
  GetMyFeatures(): Promise<IonArray<FeatureFlag>>;
  GetMyProfile(): Promise<ArgonUserProfile>;
  BeginUploadAvatar(): Promise<IUploadFileResult>;
  CompleteUploadAvatar(blobId: guid): Promise<void>;
  BeginUploadProfileHeader(): Promise<IUploadFileResult>;
  CompleteUploadProfileHeader(blobId: guid): Promise<void>;
}




export interface IPreferenceInteraction extends IIonService
{
  SetPreference(scope: string, value: string): Promise<void>;
  GetPreference(scope: string, value: string): Promise<void>;
}




export interface IVoiceInteraction extends IIonService
{
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<bool>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<void>;
}



//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------

export class ArchetypeInteraction_Executor extends ServiceExecutor<IArchetypeInteraction> implements IArchetypeInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "GetServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Archetype>>("IonArray<Archetype>", writer.data, this.signal);
  }
  async CreateArchetype(spaceId: guid, name: string): Promise<Archetype> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "CreateArchetype");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<string>('string').write(writer, name);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<Archetype>("Archetype", writer.data, this.signal);
  }
  async UpdateArchetype(spaceId: guid, data: Archetype): Promise<Archetype> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "UpdateArchetype");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<Archetype>("Archetype", writer.data, this.signal);
  }
  async SetArchetypeToMember(spaceId: guid, memberId: guid, archetypeId: guid, isGrant: bool): Promise<bool> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "SetArchetypeToMember");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, memberId);
    IonFormatterStorage.get<guid>('guid').write(writer, archetypeId);
    IonFormatterStorage.get<bool>('bool').write(writer, isGrant);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "GetDetailedServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArchetypeGroup>>("IonArray<ArchetypeGroup>", writer.data, this.signal);
  }
  async UpsertArchetypeEntitlementForChannel(spaceId: guid, channelId: guid, archetypeId: guid, deny: ArgonEntitlement, allow: ArgonEntitlement): Promise<ChannelEntitlementOverwrite | null> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "UpsertArchetypeEntitlementForChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(5);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, archetypeId);
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, deny);
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, allow);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ChannelEntitlementOverwrite | null>("ChannelEntitlementOverwrite | null", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IArchetypeInteraction>('ArchetypeInteraction', ArchetypeInteraction_Executor);

export class ChannelInteraction_Executor extends ServiceExecutor<IChannelInteraction> implements IChannelInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async CreateChannel(spaceId: guid, channelId: guid, request: CreateChannelRequest): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "CreateChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<CreateChannelRequest>('CreateChannelRequest').write(writer, request);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async DeleteChannel(spaceId: guid, channelId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "DeleteChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetChannels(spaceId: guid, channelId: guid): Promise<IonArray<RealtimeChannel>> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "GetChannels");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<RealtimeChannel>>("IonArray<RealtimeChannel>", writer.data, this.signal);
  }
  async QueryMessages(spaceId: guid, channelId: guid, from: i8 | null, limit: i4): Promise<IonArray<ArgonMessage>> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "QueryMessages");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.writeNullable<i8>(writer, from, 'i8');
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArgonMessage>>("IonArray<ArgonMessage>", writer.data, this.signal);
  }
  async SendMessage(spaceId: guid, channelId: guid, text: string, entities: IonArray<IMessageEntity>, randomId: i8, replyTo: i8 | null): Promise<i8> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "SendMessage");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(6);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<string>('string').write(writer, text);
    IonFormatterStorage.writeArray<IMessageEntity>(writer, entities, 'IMessageEntity');
    IonFormatterStorage.get<i8>('i8').write(writer, randomId);
    IonFormatterStorage.writeNullable<i8>(writer, replyTo, 'i8');
      
    writer.writeEndArray();
          
    return await req.callAsyncT<i8>("i8", writer.data, this.signal);
  }
  async DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "DisconnectFromVoiceChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async Interlink(spaceId: guid, channelId: guid): Promise<IInterlinkResult> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "Interlink");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IInterlinkResult>("IInterlinkResult", writer.data, this.signal);
  }
  async KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "KickMemberFromChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, memberId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IChannelInteraction>('ChannelInteraction', ChannelInteraction_Executor);

export class EventBus_Executor extends ServiceExecutor<IEventBus> implements IEventBus {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  ForServer(spaceId: guid): AsyncIterable<IArgonEvent> {
    const ws = new IonWsClient(this.ctx, "IEventBus", "ForServer");
    
    const writer = new CborWriter();
    
    writer.writeStartArray(1);
    
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    
    writer.writeEndArray();
    
    return ws.callServerStreaming<IArgonEvent>("IArgonEvent", writer.data, this.signal);
  }
  async Dispatch(ev: IArgonClientEvent): Promise<void> {
    const req = new IonRequest(this.ctx, "IEventBus", "Dispatch");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<IArgonClientEvent>('IArgonClientEvent').write(writer, ev);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  Pipe(inputStream: AsyncIterable<IArgonClientEvent>): AsyncIterable<IArgonEvent> {
    const ws = new IonWsClient(this.ctx, "IEventBus", "Pipe");
    
    const writer = new CborWriter();
    
    writer.writeStartArray(0);
    
    
    
    writer.writeEndArray();
    
    return ws.callServerStreamingFullDuplex<IArgonEvent, IArgonClientEvent>("IArgonEvent", writer.data, inputStream, "IArgonClientEvent", this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IEventBus>('EventBus', EventBus_Executor);

export class FriendsInteraction_Executor extends ServiceExecutor<IFriendsInteraction> implements IFriendsInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  

}

IonFormatterStorage.registerClientExecutor<IFriendsInteraction>('FriendsInteraction', FriendsInteraction_Executor);

export class IdentityInteraction_Executor extends ServiceExecutor<IIdentityInteraction> implements IIdentityInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async Authorize(data: UserCredentialsInput): Promise<IAuthorizeResult> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "Authorize");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserCredentialsInput>('UserCredentialsInput').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IAuthorizeResult>("IAuthorizeResult", writer.data, this.signal);
  }
  async Registration(data: NewUserCredentialsInput): Promise<IRegistrationResult> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "Registration");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<NewUserCredentialsInput>('NewUserCredentialsInput').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IRegistrationResult>("IRegistrationResult", writer.data, this.signal);
  }
  async BeginResetPassword(email: string): Promise<bool> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "BeginResetPassword");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, email);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async ResetPassword(email: string, otpCode: string, newPassword: string): Promise<IAuthorizeResult> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "ResetPassword");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<string>('string').write(writer, email);
    IonFormatterStorage.get<string>('string').write(writer, otpCode);
    IonFormatterStorage.get<string>('string').write(writer, newPassword);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IAuthorizeResult>("IAuthorizeResult", writer.data, this.signal);
  }
  async GetAuthorizationScenario(): Promise<string> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "GetAuthorizationScenario");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async GetAuthorizationScenarioFor(data: UserLoginInput): Promise<string> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "GetAuthorizationScenarioFor");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserLoginInput>('UserLoginInput').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async GetMyAuthorization(token: string, refreshToken: string | null): Promise<IMyAuthStatus> {
    const req = new IonRequest(this.ctx, "IIdentityInteraction", "GetMyAuthorization");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, token);
    IonFormatterStorage.writeNullable<string>(writer, refreshToken, 'string');
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IMyAuthStatus>("IMyAuthStatus", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IIdentityInteraction>('IdentityInteraction', IdentityInteraction_Executor);

export class InventoryInteraction_Executor extends ServiceExecutor<IInventoryInteraction> implements IInventoryInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetMyInventoryItems(): Promise<IonArray<InventoryItem>> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "GetMyInventoryItems");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<InventoryItem>>("IonArray<InventoryItem>", writer.data, this.signal);
  }
  async MarkSeen(itemIds: IonArray<guid>): Promise<void> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "MarkSeen");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.writeArray<guid>(writer, itemIds, 'guid');
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetNotifications(): Promise<IonArray<InventoryNotification>> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "GetNotifications");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<InventoryNotification>>("IonArray<InventoryNotification>", writer.data, this.signal);
  }
  async RedeemCode(code: string): Promise<IRedeemResult> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "RedeemCode");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, code);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IRedeemResult>("IRedeemResult", writer.data, this.signal);
  }
  async UseItem(itemId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IInventoryInteraction", "UseItem");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, itemId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IInventoryInteraction>('InventoryInteraction', InventoryInteraction_Executor);

export class MeetingInteraction_Executor extends ServiceExecutor<IMeetingInteraction> implements IMeetingInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async Join(inviteCode: string, username: string): Promise<void> {
    const req = new IonRequest(this.ctx, "IMeetingInteraction", "Join");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, inviteCode);
    IonFormatterStorage.get<string>('string').write(writer, username);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async CreateMeetingLink(): Promise<string> {
    const req = new IonRequest(this.ctx, "IMeetingInteraction", "CreateMeetingLink");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async SetDefaultPermissions(roomId: string, permissions: i8): Promise<void> {
    const req = new IonRequest(this.ctx, "IMeetingInteraction", "SetDefaultPermissions");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, roomId);
    IonFormatterStorage.get<i8>('i8').write(writer, permissions);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async BeginRecordAsync(roomId: string): Promise<string> {
    const req = new IonRequest(this.ctx, "IMeetingInteraction", "BeginRecordAsync");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, roomId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async EndRecordAsync(roomId: string): Promise<void> {
    const req = new IonRequest(this.ctx, "IMeetingInteraction", "EndRecordAsync");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, roomId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IMeetingInteraction>('MeetingInteraction', MeetingInteraction_Executor);

export class ServerInteraction_Executor extends ServiceExecutor<IServerInteraction> implements IServerInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetMembers(spaceId: guid): Promise<IonArray<RealtimeServerMember>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetMembers");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<RealtimeServerMember>>("IonArray<RealtimeServerMember>", writer.data, this.signal);
  }
  async GetMember(spaceId: guid, userId: guid): Promise<RealtimeServerMember> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetMember");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<RealtimeServerMember>("RealtimeServerMember", writer.data, this.signal);
  }
  async GetInviteCodes(spaceId: guid): Promise<IonArray<InviteCodeEntity>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetInviteCodes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<InviteCodeEntity>>("IonArray<InviteCodeEntity>", writer.data, this.signal);
  }
  async CreateInviteCode(spaceId: guid): Promise<InviteCode> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "CreateInviteCode");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<InviteCode>("InviteCode", writer.data, this.signal);
  }
  async PrefetchUser(spaceId: guid, userId: guid): Promise<ArgonUser> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "PrefetchUser");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUser>("ArgonUser", writer.data, this.signal);
  }
  async PrefetchProfile(spaceId: guid, userId: guid): Promise<ArgonUserProfile> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "PrefetchProfile");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUserProfile>("ArgonUserProfile", writer.data, this.signal);
  }
  async GetChannels(spaceId: guid): Promise<IonArray<RealtimeChannel>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetChannels");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<RealtimeChannel>>("IonArray<RealtimeChannel>", writer.data, this.signal);
  }
  async GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Archetype>>("IonArray<Archetype>", writer.data, this.signal);
  }
  async GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetDetailedServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArchetypeGroup>>("IonArray<ArchetypeGroup>", writer.data, this.signal);
  }
  async BeginUploadSpaceProfileHeader(spaceId: guid): Promise<guid> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "BeginUploadSpaceProfileHeader");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<guid>("guid", writer.data, this.signal);
  }
  async CompleteUploadSpaceProfileHeader(spaceId: guid, blobId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "CompleteUploadSpaceProfileHeader");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, blobId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async BeginUploadSpaceAvatar(spaceId: guid): Promise<guid> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "BeginUploadSpaceAvatar");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<guid>("guid", writer.data, this.signal);
  }
  async CompleteUploadSpaceAvatar(spaceId: guid, blobId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "CompleteUploadSpaceAvatar");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, blobId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IServerInteraction>('ServerInteraction', ServerInteraction_Executor);

export class UserInteraction_Executor extends ServiceExecutor<IUserInteraction> implements IUserInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetMe(): Promise<ArgonUser> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetMe");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUser>("ArgonUser", writer.data, this.signal);
  }
  async CreateSpace(request: CreateServerRequest): Promise<ICreateSpaceResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "CreateSpace");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<CreateServerRequest>('CreateServerRequest').write(writer, request);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ICreateSpaceResult>("ICreateSpaceResult", writer.data, this.signal);
  }
  async GetSpaces(): Promise<IonArray<ArgonSpaceBase>> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetSpaces");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArgonSpaceBase>>("IonArray<ArgonSpaceBase>", writer.data, this.signal);
  }
  async UpdateMe(request: UserEditInput): Promise<ArgonUser> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "UpdateMe");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserEditInput>('UserEditInput').write(writer, request);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUser>("ArgonUser", writer.data, this.signal);
  }
  async JoinToSpace(inviteCode: InviteCode): Promise<IJoinToSpaceResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "JoinToSpace");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<InviteCode>('InviteCode').write(writer, inviteCode);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IJoinToSpaceResult>("IJoinToSpaceResult", writer.data, this.signal);
  }
  async BroadcastPresence(presence: UserActivityPresence): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "BroadcastPresence");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserActivityPresence>('UserActivityPresence').write(writer, presence);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async RemoveBroadcastPresence(): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "RemoveBroadcastPresence");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetMyFeatures(): Promise<IonArray<FeatureFlag>> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetMyFeatures");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<FeatureFlag>>("IonArray<FeatureFlag>", writer.data, this.signal);
  }
  async GetMyProfile(): Promise<ArgonUserProfile> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetMyProfile");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUserProfile>("ArgonUserProfile", writer.data, this.signal);
  }
  async BeginUploadAvatar(): Promise<IUploadFileResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "BeginUploadAvatar");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IUploadFileResult>("IUploadFileResult", writer.data, this.signal);
  }
  async CompleteUploadAvatar(blobId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "CompleteUploadAvatar");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, blobId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async BeginUploadProfileHeader(): Promise<IUploadFileResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "BeginUploadProfileHeader");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IUploadFileResult>("IUploadFileResult", writer.data, this.signal);
  }
  async CompleteUploadProfileHeader(blobId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "CompleteUploadProfileHeader");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, blobId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IUserInteraction>('UserInteraction', UserInteraction_Executor);

export class PreferenceInteraction_Executor extends ServiceExecutor<IPreferenceInteraction> implements IPreferenceInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async SetPreference(scope: string, value: string): Promise<void> {
    const req = new IonRequest(this.ctx, "IPreferenceInteraction", "SetPreference");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, scope);
    IonFormatterStorage.get<string>('string').write(writer, value);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetPreference(scope: string, value: string): Promise<void> {
    const req = new IonRequest(this.ctx, "IPreferenceInteraction", "GetPreference");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<string>('string').write(writer, scope);
    IonFormatterStorage.get<string>('string').write(writer, value);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IPreferenceInteraction>('PreferenceInteraction', PreferenceInteraction_Executor);

export class VoiceInteraction_Executor extends ServiceExecutor<IVoiceInteraction> implements IVoiceInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IVoiceInteraction", "DisconnectFromVoiceChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IVoiceInteraction", "KickMemberFromChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, memberId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IVoiceInteraction>('VoiceInteraction', VoiceInteraction_Executor);


export function createClient(endpoint: string, interceptors: IonInterceptor[]) {
  const ctx = {
    baseUrl: endpoint,
    interceptors: interceptors
  } as IonClientContext;
  const controller = new AbortController();

  return new Proxy(
    {},
    {
      get(_target, propKey) {
        if (typeof propKey !== "string") return undefined;
        if (propKey === "ArchetypeInteraction") return IonFormatterStorage.createExecutor("ArchetypeInteraction", ctx, controller.signal);
        if (propKey === "ChannelInteraction") return IonFormatterStorage.createExecutor("ChannelInteraction", ctx, controller.signal);
        if (propKey === "EventBus") return IonFormatterStorage.createExecutor("EventBus", ctx, controller.signal);
        if (propKey === "FriendsInteraction") return IonFormatterStorage.createExecutor("FriendsInteraction", ctx, controller.signal);
        if (propKey === "IdentityInteraction") return IonFormatterStorage.createExecutor("IdentityInteraction", ctx, controller.signal);
        if (propKey === "InventoryInteraction") return IonFormatterStorage.createExecutor("InventoryInteraction", ctx, controller.signal);
        if (propKey === "MeetingInteraction") return IonFormatterStorage.createExecutor("MeetingInteraction", ctx, controller.signal);
        if (propKey === "ServerInteraction") return IonFormatterStorage.createExecutor("ServerInteraction", ctx, controller.signal);
        if (propKey === "UserInteraction") return IonFormatterStorage.createExecutor("UserInteraction", ctx, controller.signal);
        if (propKey === "PreferenceInteraction") return IonFormatterStorage.createExecutor("PreferenceInteraction", ctx, controller.signal);
        if (propKey === "VoiceInteraction") return IonFormatterStorage.createExecutor("VoiceInteraction", ctx, controller.signal);


        throw new Error(`${propKey} service is not defined`);
      },
    }
  ) as {
    ArchetypeInteraction: IArchetypeInteraction;
    ChannelInteraction: IChannelInteraction;
    EventBus: IEventBus;
    FriendsInteraction: IFriendsInteraction;
    IdentityInteraction: IIdentityInteraction;
    InventoryInteraction: IInventoryInteraction;
    MeetingInteraction: IMeetingInteraction;
    ServerInteraction: IServerInteraction;
    UserInteraction: IUserInteraction;
    PreferenceInteraction: IPreferenceInteraction;
    VoiceInteraction: IVoiceInteraction;

  };
}

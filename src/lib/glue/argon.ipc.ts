//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------
import { 
  CborReader, 
  CborWriter, 
  
  DateOnly, 
  DateTimeOffset, 
  Duration, 
  TimeOnly, 
  Guid, 
  
  IonFormatterStorage,

  IonArray, 
  IonMaybe,

  IIonService,
  IIonUnion,
  
  ServiceExecutor,
  IonClientContext,
  IonRequest,
  IonWsClient,
  IonInterceptor
} from "@argon-chat/ion.webcore";

type guid = Guid;
type timeonly = TimeOnly;
type duration = Duration;
type datetime = DateTimeOffset;
type dateonly = DateOnly;

declare type bool = boolean;

declare type i1 = number;
declare type i2 = number;
declare type i4 = number;
declare type i8 = bigint;
declare type i16 = bigint;


declare type u1 = number;
declare type u2 = number;
declare type u4 = number;
declare type u8 = bigint;
declare type u16 = bigint;


declare type f2 = number;
declare type f4 = number;
declare type f8 = number;

export interface StorageInfo {
  totalSize: string;
  availableFreeSpace: string;
};


export interface Screen {
  displayIndex: i4;
  width: i4;
  height: i4;
  left: i4;
  top: i4;
  isPrimary: bool;
  freq: i4;
};


export interface WindowInfo {
  deviceId: string;
  title: string;
};


export interface PinnedFn {
  id: i4;
};


export enum Channel
{
  live = 0,
  beta = 1,
  canary = 2,
}


export enum HostKind
{
  WindowsDesktop = 0,
  MacOs = 1,
}



IonFormatterStorage.register("StorageInfo", {
  read(reader: CborReader): StorageInfo {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const totalSize = IonFormatterStorage.get<string>('string').read(reader);
    const availableFreeSpace = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { totalSize, availableFreeSpace };
  },
  write(writer: CborWriter, value: StorageInfo): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.totalSize);
    IonFormatterStorage.get<string>('string').write(writer, value.availableFreeSpace);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("Screen", {
  read(reader: CborReader): Screen {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const displayIndex = IonFormatterStorage.get<i4>('i4').read(reader);
    const width = IonFormatterStorage.get<i4>('i4').read(reader);
    const height = IonFormatterStorage.get<i4>('i4').read(reader);
    const left = IonFormatterStorage.get<i4>('i4').read(reader);
    const top = IonFormatterStorage.get<i4>('i4').read(reader);
    const isPrimary = IonFormatterStorage.get<bool>('bool').read(reader);
    const freq = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 7);
    return { displayIndex, width, height, left, top, isPrimary, freq };
  },
  write(writer: CborWriter, value: Screen): void {
    writer.writeStartArray(7);
    IonFormatterStorage.get<i4>('i4').write(writer, value.displayIndex);
    IonFormatterStorage.get<i4>('i4').write(writer, value.width);
    IonFormatterStorage.get<i4>('i4').write(writer, value.height);
    IonFormatterStorage.get<i4>('i4').write(writer, value.left);
    IonFormatterStorage.get<i4>('i4').write(writer, value.top);
    IonFormatterStorage.get<bool>('bool').write(writer, value.isPrimary);
    IonFormatterStorage.get<i4>('i4').write(writer, value.freq);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("WindowInfo", {
  read(reader: CborReader): WindowInfo {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const deviceId = IonFormatterStorage.get<string>('string').read(reader);
    const title = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArrayAndSkip(arraySize - 2);
    return { deviceId, title };
  },
  write(writer: CborWriter, value: WindowInfo): void {
    writer.writeStartArray(2);
    IonFormatterStorage.get<string>('string').write(writer, value.deviceId);
    IonFormatterStorage.get<string>('string').write(writer, value.title);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("PinnedFn", {
  read(reader: CborReader): PinnedFn {
    const arraySize = reader.readStartArray() ?? (() => { throw new Error("undefined len array not allowed") })();
    const id = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArrayAndSkip(arraySize - 1);
    return { id };
  },
  write(writer: CborWriter, value: PinnedFn): void {
    writer.writeStartArray(1);
    IonFormatterStorage.get<i4>('i4').write(writer, value.id);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("Channel", {
  read(reader: CborReader): Channel {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return Channel[num] !== undefined ? num as Channel : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: Channel): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});

IonFormatterStorage.register("HostKind", {
  read(reader: CborReader): HostKind {
    const num = (IonFormatterStorage.get<u4>('u4').read(reader))
    return HostKind[num] !== undefined ? num as HostKind : (() => {throw new Error('invalid enum type')})();
  },
  write(writer: CborWriter, value: HostKind): void {
    const casted: u4 = value;
    IonFormatterStorage.get<u4>('u4').write(writer, casted);
  }
});



export interface IHostProc extends IIonService
{
  listenSessionMusic(): Promise<bool>;
  listenActivity(): Promise<bool>;
  allocatePinnedFn(name: string): Promise<PinnedFn>;
  onGameActivityDetected(fn: PinnedFn): Promise<bool>;
  onGameActivityTerminated(fn: PinnedFn): Promise<bool>;
  onMusicSessionPlayStateChanged(fn: PinnedFn): Promise<bool>;
  dsn(): Promise<string>;
  getHostKind(): Promise<HostKind>;
  getDisplays(): Promise<IonArray<Screen>>;
  getHWNDs(): Promise<IonArray<WindowInfo>>;
  allocConsole(): Promise<bool>;
  toggleDevTools(): Promise<bool>;
  getCurrentChannel(): Promise<Channel>;
  setCurrentChannel(c: Channel): Promise<void>;
  getIdleTimeSeconds(): Promise<i4>;
  openUrl(url: string): Promise<bool>;
  clipboardRead(): Promise<string>;
  clipboardWrite(val: string): Promise<bool>;
  renderDiagnostic(i: i4): Promise<bool>;
  getStorageSpace(): Promise<StorageInfo>;
}




export interface IHostProc extends IIonService
{
  listenSessionMusic(): Promise<bool>;
  listenActivity(): Promise<bool>;
  allocatePinnedFn(name: string): Promise<PinnedFn>;
  onGameActivityDetected(fn: PinnedFn): Promise<bool>;
  onGameActivityTerminated(fn: PinnedFn): Promise<bool>;
  onMusicSessionPlayStateChanged(fn: PinnedFn): Promise<bool>;
  dsn(): Promise<string>;
  getHostKind(): Promise<HostKind>;
  getDisplays(): Promise<IonArray<Screen>>;
  getHWNDs(): Promise<IonArray<WindowInfo>>;
  allocConsole(): Promise<bool>;
  toggleDevTools(): Promise<bool>;
  getCurrentChannel(): Promise<Channel>;
  setCurrentChannel(c: Channel): Promise<void>;
  getIdleTimeSeconds(): Promise<i4>;
  openUrl(url: string): Promise<bool>;
  clipboardRead(): Promise<string>;
  clipboardWrite(val: string): Promise<bool>;
  renderDiagnostic(i: i4): Promise<bool>;
  getStorageSpace(): Promise<StorageInfo>;
}



//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------

export class HostProc_Executor extends ServiceExecutor<IHostProc> implements IHostProc {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async listenSessionMusic(): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "listenSessionMusic");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async listenActivity(): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "listenActivity");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async allocatePinnedFn(name: string): Promise<PinnedFn> {
    const req = new IonRequest(this.ctx, "IHostProc", "allocatePinnedFn");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, name);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<PinnedFn>("PinnedFn", writer.data, this.signal);
  }
  async onGameActivityDetected(fn: PinnedFn): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "onGameActivityDetected");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<PinnedFn>('PinnedFn').write(writer, fn);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async onGameActivityTerminated(fn: PinnedFn): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "onGameActivityTerminated");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<PinnedFn>('PinnedFn').write(writer, fn);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async onMusicSessionPlayStateChanged(fn: PinnedFn): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "onMusicSessionPlayStateChanged");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<PinnedFn>('PinnedFn').write(writer, fn);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async dsn(): Promise<string> {
    const req = new IonRequest(this.ctx, "IHostProc", "dsn");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async getHostKind(): Promise<HostKind> {
    const req = new IonRequest(this.ctx, "IHostProc", "getHostKind");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<HostKind>("HostKind", writer.data, this.signal);
  }
  async getDisplays(): Promise<IonArray<Screen>> {
    const req = new IonRequest(this.ctx, "IHostProc", "getDisplays");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Screen>>("IonArray<Screen>", writer.data, this.signal);
  }
  async getHWNDs(): Promise<IonArray<WindowInfo>> {
    const req = new IonRequest(this.ctx, "IHostProc", "getHWNDs");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<WindowInfo>>("IonArray<WindowInfo>", writer.data, this.signal);
  }
  async allocConsole(): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "allocConsole");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async toggleDevTools(): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "toggleDevTools");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async getCurrentChannel(): Promise<Channel> {
    const req = new IonRequest(this.ctx, "IHostProc", "getCurrentChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<Channel>("Channel", writer.data, this.signal);
  }
  async setCurrentChannel(c: Channel): Promise<void> {
    const req = new IonRequest(this.ctx, "IHostProc", "setCurrentChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<Channel>('Channel').write(writer, c);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async getIdleTimeSeconds(): Promise<i4> {
    const req = new IonRequest(this.ctx, "IHostProc", "getIdleTimeSeconds");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<i4>("i4", writer.data, this.signal);
  }
  async openUrl(url: string): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "openUrl");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, url);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async clipboardRead(): Promise<string> {
    const req = new IonRequest(this.ctx, "IHostProc", "clipboardRead");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<string>("string", writer.data, this.signal);
  }
  async clipboardWrite(val: string): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "clipboardWrite");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, val);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async renderDiagnostic(i: i4): Promise<bool> {
    const req = new IonRequest(this.ctx, "IHostProc", "renderDiagnostic");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<i4>('i4').write(writer, i);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async getStorageSpace(): Promise<StorageInfo> {
    const req = new IonRequest(this.ctx, "IHostProc", "getStorageSpace");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<StorageInfo>("StorageInfo", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IHostProc>('HostProc', HostProc_Executor);


export function createClient(endpoint: string, interceptors: IonInterceptor[]) {
  const ctx = {
    baseUrl: endpoint,
    interceptors: interceptors
  } as IonClientContext;
  const controller = new AbortController();

  return new Proxy(
    {},
    {
      get(_target, propKey) {
        if (typeof propKey !== "string") return undefined;
        if (propKey === "HostProc") return IonFormatterStorage.createExecutor("HostProc", ctx, controller.signal);


        throw new Error(`${propKey} service is not defined`);
      },
    }
  ) as {
    HostProc: IHostProc;

  };
}
